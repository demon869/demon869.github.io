<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Demon</title>
  
  
  <link href="https://www.demon-w.com/atom.xml" rel="self"/>
  
  <link href="https://www.demon-w.com/"/>
  <updated>2020-08-30T10:05:37.687Z</updated>
  <id>https://www.demon-w.com/</id>
  
  <author>
    <name>Demon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 系统服务</title>
    <link href="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</id>
    <published>2018-01-13T16:10:01.000Z</published>
    <updated>2020-08-30T10:05:37.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Linux启动流程"><a href="#1-Linux启动流程" class="headerlink" title="1.Linux启动流程"></a>1.Linux启动流程</h2><p>Linux系统的启动过程，其过程可以分为5个阶段：</p><blockquote><ul><li><strong>1. 内核的引导。</strong></li><li><strong>2. 运行 init。</strong></li><li><strong>3. 系统初始化。</strong></li><li><strong>4. 建立终端 。</strong></li><li><strong>5. 用户登录系统。</strong></li></ul></blockquote><blockquote><p><strong>1.init程序的类型：</strong><br>1.<code>SysV</code>: init, CentOS 5之前, 配置文件： /etc/inittab。<br>2.<code>Upstart</code>: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。<br>3.<code>Systemd</code>：systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。</p></blockquote><h3 id="1-内核引导"><a href="#1-内核引导" class="headerlink" title="1.内核引导"></a>1.内核引导</h3><blockquote><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。<br>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/1.jpg" alt="1"></p></blockquote><h3 id="2-运行init"><a href="#2-运行init" class="headerlink" title="2.运行init"></a>2.运行init</h3><blockquote><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p><p>init 程序首先是需要读取配置文件 /etc/inittab。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/2.jpg" alt="2"></p></blockquote><h4 id="1-运行级别"><a href="#1-运行级别" class="headerlink" title="1.运行级别"></a>1.运行级别</h4><blockquote><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。<br>init进程的一大任务，就是去运行这些开机启动的程序。<br>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。<br>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/3.jpg" alt="3"></p></blockquote><h5 id="1-Linux系统有7个运行级别-runlevel-："><a href="#1-Linux系统有7个运行级别-runlevel-：" class="headerlink" title="1.Linux系统有7个运行级别(runlevel)："></a>1.Linux系统有7个运行级别(runlevel)：</h5><table><thead><tr><th align="left">System V init运行级别</th><th align="left">systemd目标名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">runlevel0.target, poweroff.target</td><td align="left">系统关机机状态，系统默认运行级别不能设为0，否则不能正常启动</td></tr><tr><td align="left">1</td><td align="left">runlevel1.target, rescue.target</td><td align="left">单用户工作状态，root权限，用于系统维护，禁止远程登陆</td></tr><tr><td align="left">2</td><td align="left">runlevel2.target, multi-user.target</td><td align="left">多用户状态(没有NFS)</td></tr><tr><td align="left">3</td><td align="left">runlevel3.target, multi-user.target</td><td align="left">完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</td></tr><tr><td align="left">4</td><td align="left">runlevel4.target, multi-user.target</td><td align="left">系统未使用，保留</td></tr><tr><td align="left">5</td><td align="left">runlevel5.target, graphical.target</td><td align="left">X11控制台，登陆后进入图形GUI模式</td></tr><tr><td align="left">6</td><td align="left">runlevel6.target, reboot.target</td><td align="left">系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</td></tr></tbody></table><h5 id="2-如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标"><a href="#2-如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标" class="headerlink" title="2.如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标:"></a>2.如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看系统默认运行级别</span></span><br><span class="line">[root@demo ~]<span class="comment"># systemctl get-default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.要设置默认目标，请运行</span></span><br><span class="line">[root@demo ~]<span class="comment"># systemctl set-default TARGET.target</span></span><br></pre></td></tr></table></figure><h3 id="3-系统初始化"><a href="#3-系统初始化" class="headerlink" title="3.系统初始化"></a>3.系统初始化</h3><blockquote><p>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。<br>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。<br><code>l5:5:wait:/etc/rc.d/rc 5</code><br>这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。<br>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。<br>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。<br>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。<br>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。<br>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/4.jpg" alt="4"></p></blockquote><h3 id="4-建立终端"><a href="#4-建立终端" class="headerlink" title="4.建立终端"></a>4.建立终端</h3><blockquote><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。<br>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure><blockquote><p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。<br>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p></blockquote><h3 id="5-用户登录系统"><a href="#5-用户登录系统" class="headerlink" title="5.用户登录系统"></a>5.用户登录系统</h3><blockquote><p>一般来说，用户的登录方式有三种：</p><ol><li>命令行登录</li><li>ssh登录</li><li>图形界面登录<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/5.jpg" alt="5"><br>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。<br>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。<br>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。<br>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。<br>这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。<br>/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</li></ol></blockquote><h4 id="1-图形模式与文字模式的切换方式"><a href="#1-图形模式与文字模式的切换方式" class="headerlink" title="1.图形模式与文字模式的切换方式"></a>1.图形模式与文字模式的切换方式</h4><blockquote><p>Linux预设提供了六个命令窗口终端机让我们来登录。<br>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。<br>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。<br>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。<br>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1<del>F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1</del>F6 切换至命令窗口。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/6.jpg" alt="6"></p></blockquote><h2 id="2-Linux-systemd"><a href="#2-Linux-systemd" class="headerlink" title="2.Linux systemd"></a>2.Linux systemd</h2><h3 id="1-systemd的由来"><a href="#1-systemd的由来" class="headerlink" title="1.systemd的由来"></a>1.systemd的由来</h3><blockquote><p>Linux一直以来都是采用init进程作为内核启动的第一个用户级进程，但是init有两个缺点：</p><ul><li>1、启动时间长。Init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>2、启动脚本复杂，初始化完成后系统会加载很多脚本，脚本都会处理各自的情况，这会让脚本多而复杂。</li><li>Centos5 是启动速度最慢的，串行启动过程，无论进程相互之间有无依赖关系。</li><li>Centos6 相对启动速度有所改进。有依赖的进程之间依次启动而其他与之没有依赖关系的则并行同步启动。</li><li>Centos7 所有进程无论有无依赖关系则都是并行启动（当然很多时候进程没有真正启动而是只有一个信号或者说是标记而已，在真正利用的时候才会真正启动。）<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/7.jpg" alt="7"></li></ul></blockquote><h3 id="2-什么是systemd"><a href="#2-什么是systemd" class="headerlink" title="2.什么是systemd"></a>2.什么是systemd</h3><blockquote><p><code>systemd</code>即为<code>system daemon</code>守护进程，<code>systemd</code>主要解决上文的问题而诞生，<code>systemd</code>的目标是，为系统的启动和管理提供一套完整的解决方案。</p></blockquote><h3 id="3-systemd的优势"><a href="#3-systemd的优势" class="headerlink" title="3.systemd的优势"></a>3.systemd的优势</h3><blockquote><ol><li>最新系统都采用<code>systemd</code>管理（RedHat7,CentOS7,Ubuntu15等）</li><li><code>Centos7</code>支持开机并行启动服务，显著提高开机启动效率。</li><li><code>Centos7</code>关机只关闭正在运行的服务，而<code>Centos6</code>全部都关闭一次。</li><li><code>Centos7</code>服务的启动与停止不在使用脚本进行管理，也就是<code>/etc/init.d</code>下不在有脚本。</li><li><code>Centos7</code>使用<code>systemd</code>解决原有模式缺陷，比如原有<code>service</code>不会关闭程序产生的子进程。</li></ol></blockquote><h3 id="4-systemd相关配置文件"><a href="#4-systemd相关配置文件" class="headerlink" title="4.systemd相关配置文件"></a>4.systemd相关配置文件</h3><blockquote><p><code>/usr/lib/systemd/system/</code> #类似<code>Centos6</code>系统的启动脚本，<code>/etc/init.d/</code><br><code>/etc/systemd/system/</code> #类似<code>Centos6</code>系统的<code>/etc/rc.d/rcN.d/</code><br><code>/etc/systemd/system/multi-user.target.wants/</code></p></blockquote><h3 id="5-systemd管理服务相关命令"><a href="#5-systemd管理服务相关命令" class="headerlink" title="5.systemd管理服务相关命令"></a>5.systemd管理服务相关命令</h3><blockquote><p><strong><code>systemctl</code>管理服务的启动、重启、停止、重载、查看状态等常用命令</strong></p></blockquote><table><thead><tr><th align="left">systemctl命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">systemctl start crond.service</td><td align="left">启动服务</td></tr><tr><td align="left">systemctl stop crond.service</td><td align="left">停止服务</td></tr><tr><td align="left">systemctl restart crond.service</td><td align="left">重启服务</td></tr><tr><td align="left">systemctl reload crond.service</td><td align="left">重新加载配置</td></tr><tr><td align="left">systemctl status crond.servre</td><td align="left">查看服务运行状态</td></tr><tr><td align="left">systemctl is-active sshd.servic</td><td align="left">e    查看服务是否在运行中</td></tr><tr><td align="left">systemctl mask crond.servre</td><td align="left">禁止服务运行</td></tr><tr><td align="left">systemctl unmask crond.servre</td><td align="left">取消禁止服务运行</td></tr></tbody></table><blockquote><p><strong>当我们使用<code>systemctl</code>启动一个守护进程后，可以通过<code>systemctl status</code>查看此守护进程的状态</strong></p></blockquote><table><thead><tr><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">loaded</td><td align="left">服务单元的配置文件已经被处理</td></tr><tr><td align="left">active(running)</td><td align="left">服务持续运行</td></tr><tr><td align="left">active(exited)</td><td align="left">服务成功完成一次的配置</td></tr><tr><td align="left">active(waiting)</td><td align="left">服务已经运行但在等待某个事件</td></tr><tr><td align="left">inactive</td><td align="left">服务没有在运行</td></tr><tr><td align="left">enabled</td><td align="left">服务设定为开机运行</td></tr><tr><td align="left">disabled</td><td align="left">服务设定为开机不运行</td></tr><tr><td align="left">static</td><td align="left">服务开机不启动，但可以被其他服务调用启动</td></tr></tbody></table><blockquote><p><strong>systemctl 设置服务开机启动、不启动、查看各级别下服务启动状态等常用命令</strong></p></blockquote><table><thead><tr><th align="left">systemctl命令（7系统）</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">systemctl enable crond.service</td><td align="left">开机自动启动</td></tr><tr><td align="left">systemctl disable crond.service</td><td align="left">开机不自动启动</td></tr><tr><td align="left">systemctl list-unit-files</td><td align="left">查看各个级别下服务的启动与禁用</td></tr><tr><td align="left">systemctl is-enabled crond.service</td><td align="left">查看特定服务是否为开机自启动</td></tr><tr><td align="left">systemctl daemon-reload</td><td align="left">创建新服务文件需要重载变更</td></tr></tbody></table><blockquote><p><strong><code>CentOS7</code>系统, 管理员可以使用<code>systemctl</code> 命令来管理服务器启动与停止</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关机相关命令</span></span><br><span class="line">systemctl poweroff      <span class="comment">#立即关机，常用</span></span><br><span class="line"><span class="comment">#重启相关命令</span></span><br><span class="line">systemctl reboot        <span class="comment">#重启命令，常用</span></span><br></pre></td></tr></table></figure><blockquote><p><strong><code>systemctl</code>的<code>journalctl</code>日志</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n 20    <span class="comment">#查看最后20行</span></span><br><span class="line">journalctl -f       <span class="comment">#动态查看日志</span></span><br><span class="line">journalctl -p err   <span class="comment">#查看日志的级别</span></span><br><span class="line">journalctl -u crond <span class="comment">#查看某个服务的单元的日志</span></span><br></pre></td></tr></table></figure><h2 id="3-Linux-关机"><a href="#3-Linux-关机" class="headerlink" title="3.Linux 关机"></a>3.Linux 关机</h2><blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。<br>正确的关机流程为：<code>sync</code> &gt; <code>shutdown</code> &gt; <code>reboot</code> &gt; <code>halt</code><br>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。<br>例如你可以运行如下命令关机：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure><blockquote><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。<br>关机的命令有 <code>shutdown –h now halt poweroff</code> 和 <code>init 0</code> , 重启系统的命令有 <code>shutdown –r now reboot init 6</code>。</p></blockquote><h2 id="4-Linux单用户模式"><a href="#4-Linux单用户模式" class="headerlink" title="4.Linux单用户模式"></a>4.Linux单用户模式</h2><h3 id="第1步：重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面"><a href="#第1步：重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面" class="headerlink" title="第1步：重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面"></a>第1步：重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/8.jpg" alt="8"></p><h3 id="第2步：在linux16这行的后面添加enforcing-0-init-bin-bash，然后按下Ctrl-X组合键来运行修改过的内核程序"><a href="#第2步：在linux16这行的后面添加enforcing-0-init-bin-bash，然后按下Ctrl-X组合键来运行修改过的内核程序" class="headerlink" title="第2步：在linux16这行的后面添加enforcing=0 init=/bin/bash，然后按下Ctrl + X组合键来运行修改过的内核程序"></a>第2步：在linux16这行的后面添加enforcing=0 init=/bin/bash，然后按下Ctrl + X组合键来运行修改过的内核程序</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/9.jpg" alt="9"></p><h3 id="第3步：大约5秒过后，进入到系统的单用户模式，依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了。命令行执行效果如图所示。"><a href="#第3步：大约5秒过后，进入到系统的单用户模式，依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了。命令行执行效果如图所示。" class="headerlink" title="第3步：大约5秒过后，进入到系统的单用户模式，依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了。命令行执行效果如图所示。"></a>第3步：大约5秒过后，进入到系统的单用户模式，依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了。命令行执行效果如图所示。</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/10.jpg" alt="10"></p><p><a href="https://mp.weixin.qq.com/s/1f-zCq8j4gL3xiB3AV9K3A" target="_blank">Centos7单用户破解密码详细版</a></p><h2 id="5-Linux下救援模式"><a href="#5-Linux下救援模式" class="headerlink" title="5.Linux下救援模式"></a>5.Linux下救援模式</h2><h3 id="场景一：当系统坏了，无法登陆系统，但需要把里面的数据复制出来，怎么办？"><a href="#场景一：当系统坏了，无法登陆系统，但需要把里面的数据复制出来，怎么办？" class="headerlink" title="场景一：当系统坏了，无法登陆系统，但需要把里面的数据复制出来，怎么办？"></a>场景一：当系统坏了，无法登陆系统，但需要把里面的数据复制出来，怎么办？</h3><h4 id="步骤一、先挂载光盘，然后选择光盘引导为第一位"><a href="#步骤一、先挂载光盘，然后选择光盘引导为第一位" class="headerlink" title="步骤一、先挂载光盘，然后选择光盘引导为第一位"></a>步骤一、先挂载光盘，然后选择光盘引导为第一位</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/11.jpg" alt="11"></p><h4 id="步骤二、进入故障排除模式—-gt-然后选择救援模式"><a href="#步骤二、进入故障排除模式—-gt-然后选择救援模式" class="headerlink" title="步骤二、进入故障排除模式—&gt;然后选择救援模式"></a>步骤二、进入故障排除模式—&gt;然后选择救援模式</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/12.jpg" alt="12"><br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/13.jpg" alt="13"></p><h4 id="步骤三、挂载真实系统后，发现数据都还存在"><a href="#步骤三、挂载真实系统后，发现数据都还存在" class="headerlink" title="步骤三、挂载真实系统后，发现数据都还存在"></a>步骤三、挂载真实系统后，发现数据都还存在</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/14.jpg" alt="14"></p><h3 id="场景二、修复MBR，主要出现在安装双系统时，后安装的系统把原来系统的MBR删除了，需要修复。"><a href="#场景二、修复MBR，主要出现在安装双系统时，后安装的系统把原来系统的MBR删除了，需要修复。" class="headerlink" title="场景二、修复MBR，主要出现在安装双系统时，后安装的系统把原来系统的MBR删除了，需要修复。"></a>场景二、修复MBR，主要出现在安装双系统时，后安装的系统把原来系统的MBR删除了，需要修复。</h3><h4 id="步骤一、破坏硬盘的前446字节，模拟MBR引号损坏，会发现重启无法启动系统"><a href="#步骤一、破坏硬盘的前446字节，模拟MBR引号损坏，会发现重启无法启动系统" class="headerlink" title="步骤一、破坏硬盘的前446字节，模拟MBR引号损坏，会发现重启无法启动系统"></a>步骤一、破坏硬盘的前446字节，模拟MBR引号损坏，会发现重启无法启动系统</h4><p><code>[root@demo ~]# dd if=/dev/zero of=/dev/sda bs=1 count=446</code><br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/15.jpg" alt="15"></p><h4 id="步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复"><a href="#步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复" class="headerlink" title="步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复"></a>步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/16.jpg" alt="16"></p><h4 id="步骤三、修复MBR引导，然后重启连接服务器"><a href="#步骤三、修复MBR引导，然后重启连接服务器" class="headerlink" title="步骤三、修复MBR引导，然后重启连接服务器"></a>步骤三、修复MBR引导，然后重启连接服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用grub修复</span></span><br><span class="line"><span class="comment"># grub2-install /dev/sda</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.然后退出</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.最后重启进入系统</span></span><br><span class="line"><span class="comment"># reboot</span></span><br></pre></td></tr></table></figure><h3 id="场景三、Centos7误删除grub文件如何进行修复。"><a href="#场景三、Centos7误删除grub文件如何进行修复。" class="headerlink" title="场景三、Centos7误删除grub文件如何进行修复。"></a>场景三、Centos7误删除grub文件如何进行修复。</h3><h4 id="步骤一、模拟误删故障"><a href="#步骤一、模拟误删故障" class="headerlink" title="步骤一、模拟误删故障"></a>步骤一、模拟误删故障</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.删除grub2 </span></span><br><span class="line">[root@demo ~]<span class="comment"># rm -rf  /boot/grub2 </span></span><br><span class="line"><span class="comment">#2.重启计算机 </span></span><br><span class="line">[root@demo ~]<span class="comment"># reboot </span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/17.jpg" alt="17"></p><h4 id="步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复-1"><a href="#步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复-1" class="headerlink" title="步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复"></a>步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/18.jpg" alt="18"></p><h4 id="步骤三、使用grub2-install、grub2-mkconfig恢复配置文件"><a href="#步骤三、使用grub2-install、grub2-mkconfig恢复配置文件" class="headerlink" title="步骤三、使用grub2-install、grub2-mkconfig恢复配置文件"></a>步骤三、使用grub2-install、grub2-mkconfig恢复配置文件</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/14/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/19.jpg" alt="19"><br><mark><strong>注意: 最后别忘记修改 BIOS 引导，让硬盘回归到第一引导</strong></mark></p>]]></content>
    
    
    <summary type="html">Linux 系统服务</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 系统服务" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 进程管理</title>
    <link href="https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-13T13:10:01.000Z</published>
    <updated>2020-08-29T12:18:48.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-进程基本概念"><a href="#1-进程基本概念" class="headerlink" title="1.进程基本概念"></a>1.进程基本概念</h2><h3 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h3><blockquote><p>比如：开发写的代码我们称为程序，那么将开发的代码运行起来。我们称为进程。<br>总结一句话就是：当我们运行一个程序，那么我们将运行的程序叫进程。</p><ul><li>PS1：当程序运行为进程后，系统会为该进程分配内存，以及进程运行的身份和权限。</li><li>PS2：在进程运行的过程中，系统会有各种指标来表示当前运行的状态。</li></ul></blockquote><h3 id="2-程序和进程的区别"><a href="#2-程序和进程的区别" class="headerlink" title="2.程序和进程的区别"></a>2.程序和进程的区别</h3><blockquote><ul><li>1.程序是数据和指令的集合，是一个静态的概念。比如/bin/ls、/bin/cp等二进制文件。同时程序可以长期存在系统中。</li><li>2.进程是程序运行的过程，是一个动态的概念。进程是存在生命周期的概念的，也就是说进程会随着程序的终止而销毁，不会永久存在系统中。</li></ul></blockquote><h3 id="3-进程的生命周期"><a href="#3-进程的生命周期" class="headerlink" title="3.进程的生命周期"></a>3.进程的生命周期</h3><blockquote><p>生命周期就是指一个对象的生老病死。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.jpg" alt="1"></p></blockquote><blockquote><p>当父进程接收到任务调度时，会通过fock派生子进程来处理，那么子进程会继承父进程属性。</p><ul><li>1.子进程在处理任务代码时，父进程会进入等待状态中…</li><li>2.子进程在处理任务代码后，会执行退出，然后唤醒父进程来回收子进程的资源。</li><li>3.如果子进程在处理任务过程中，父进程退出了，子进程没有退出，那么这些子进程就没有父进程来管理了，就变成<code>僵尸进程</code>。<br><mark>PS: PID是进程ID，PPID是父进程ID。</mark></li></ul></blockquote><h2 id="2-监控进程状态"><a href="#2-监控进程状态" class="headerlink" title="2.监控进程状态"></a>2.监控进程状态</h2><blockquote><p>程序在运行后，我们需要了解进程的运行状态。查看进程的状态分为: <code>静态</code>和<code>动态</code>两种方式</p></blockquote><h3 id="1-使用ps命令查看当前的进程状态-静态"><a href="#1-使用ps命令查看当前的进程状态-静态" class="headerlink" title="1.使用ps命令查看当前的进程状态(静态)"></a>1.使用ps命令查看当前的进程状态(静态)</h3><h4 id="1-示例：ps-aux常用组合，查看进程：用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等"><a href="#1-示例：ps-aux常用组合，查看进程：用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等" class="headerlink" title="1.示例：ps -aux常用组合，查看进程：用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等"></a>1.示例：ps -aux常用组合，查看进程：用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.jpg" alt="2"></p><table><thead><tr><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">USER</td><td align="left">启动进程的用户</td></tr><tr><td align="left">PID</td><td align="left">进程运行的ID号</td></tr><tr><td align="left">%CPU</td><td align="left">进程占用CPU百分比</td></tr><tr><td align="left">%MEM</td><td align="left">进程占用内存百分比</td></tr><tr><td align="left">VSZ</td><td align="left">进程占用虚拟内存大小 (单位KB)</td></tr><tr><td align="left">RSS</td><td align="left">进程占用物理内存实际大小 (单位KB)</td></tr><tr><td align="left">TTY</td><td align="left">进程是由哪个终端运行启动的tty1、pts/0等 ?表示内核程序与终端无关</td></tr><tr><td align="left">STAT</td><td align="left">进程运行过程中的状态 (man ps 命令可查看有哪些状态，及其含义)</td></tr><tr><td align="left">START</td><td align="left">进程的启动时间</td></tr><tr><td align="left">TIME</td><td align="left">进程占用 CPU 的总时间(为0表示还没超过秒)</td></tr><tr><td align="left">COMMAND</td><td align="left">程序的运行指令，[ 方括号 ] 属于内核态的进程。 没有 [ ] 的是用户态进程。</td></tr></tbody></table><h4 id="2-STAT状态的S、Ss、S-、R、R、S-等等，具体含义"><a href="#2-STAT状态的S、Ss、S-、R、R、S-等等，具体含义" class="headerlink" title="2.STAT状态的S、Ss、S+、R、R、S+等等，具体含义"></a>2.STAT状态的S、Ss、S+、R、R、S+等等，具体含义</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.jpg" alt="3"><br>|STAT基本状态|描述|STAT状态+符号|描述|<br>|:–|:–|:–|:–|<br>|R    |进程运行    |s|进程是控制进程， Ss进程的领导者，父进程|<br>|S    |可中断睡眠    |&lt;|进程运行在高优先级上，S&lt;优先级较高的进程|<br>|T    |进程被暂停    |N|进程运行在低优先级上，SN优先级较低的进程|<br>|D    |不可中断睡眠|+|当前进程运行在前台，R+该表示进程在前台运行|<br>|Z    |僵尸进程    |l|进程是多线程的，Sl表示进程是以线程方式运行|</p><h5 id="案例一、PS命令查看进程状态切换"><a href="#案例一、PS命令查看进程状态切换" class="headerlink" title="案例一、PS命令查看进程状态切换"></a>案例一、PS命令查看进程状态切换</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.在终端1上运行vim</span></span><br><span class="line">[root@demo ~]<span class="comment"># vim oldboy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.在终端2上运行ps命令查看状态</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps aux|grep oldboy    #S表示睡眠模式，+表示前台运行</span></span><br><span class="line">root      58118  0.4  0.2 151788  5320 pts/1    S+   22:11   0:00 oldboy</span><br><span class="line">root      58120  0.0  0.0 112720   996 pts/0    R+   22:12   0:00 grep --color=auto oldboy</span><br><span class="line"><span class="comment">#在终端1上挂起vim命令，按下：ctrl+z </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.回到终端2再次运行ps命令查看状态</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps aux|grep oldboy    #T表示停止状态</span></span><br><span class="line">root      58118  0.1  0.2 151788  5320 pts/1    T    22:11   0:00 vim oldboy</span><br><span class="line">root      58125  0.0  0.0 112720   996 pts/0    R+   22:12   0:00 grep --color=auto oldboy</span><br></pre></td></tr></table></figure><h5 id="案例二、PS命令查看不可中断状态进程"><a href="#案例二、PS命令查看不可中断状态进程" class="headerlink" title="案例二、PS命令查看不可中断状态进程"></a>案例二、PS命令查看不可中断状态进程</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用tar打包文件时，可以通过终端不断查看状态，由S+，R+变为D+</span></span><br><span class="line">[root@demo ~]<span class="comment"># tar -czf etc.tar.gz /etc/ /usr/ /var/</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.5  0.2 127924  5456 pts/1    R+   22:22   0:04 tar -czf etc.tar.gz /etc/ </span><br><span class="line">[root@demo ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.5  0.2 127088  4708 pts/1    S+   22:22   0:03 tar -czf etc.tar.gz /etc/ </span><br><span class="line">[root@demo ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.6  0.2 127232  4708 pts/1    D+   22:22   0:03 tar -czf etc.tar.gz /etc/ </span><br></pre></td></tr></table></figure><h3 id="2-使用top命令查看当前的进程状态-动态"><a href="#2-使用top命令查看当前的进程状态-动态" class="headerlink" title="2.使用top命令查看当前的进程状态(动态)"></a>2.使用top命令查看当前的进程状态(动态)</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/4.jpg" alt="4"><br>|任务|含义|<br>|:–|:–|<br>|Tasks: 98 total|当然进程的总数|<br>|1 running    |正在运行的进程数|<br>|97 sleeping|睡眠的进程数|<br>|0 stopped    |停止的进程数|<br>|0 zombie    |僵尸进程数|<br>|%Cpu(s): 0.0 us|系统用户进程使用CPU百分比|<br>|0.0 sy    |内核中的进程占用CPU百分比，通常内核是于硬件进行交互|<br>|0.0 ni |用户进程空间内改变过优先级的进程占用CPU百分比|<br>|100 id|空闲CPU的百分比|<br>|0.0 wa|CPU等待IO完成的时间|<br>|0.0 hi|硬中断，占的CPU百分比|<br>|0.0 si|软中断，占的CPU百分比|<br>|0.0 st|比如虚拟机占用物理CPU的时间|</p><blockquote><p><mark><strong><a href="https://www.cnblogs.com/dunitian/p/4822808.html#ai" target="_blank">什么是中断？</a></strong></mark></p></blockquote><h3 id="1-top-常见指令"><a href="#1-top-常见指令" class="headerlink" title="1.top 常见指令"></a>1.top 常见指令</h3><table><thead><tr><th align="left">字母</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">h</td><td align="left">查看帮出</td></tr><tr><td align="left">1</td><td align="left">数字1，显示所有CPU核心的负载</td></tr><tr><td align="left">z</td><td align="left">以高亮显示数据</td></tr><tr><td align="left">b</td><td align="left">高亮显示处于R状态的进程</td></tr><tr><td align="left">M</td><td align="left">按内存使用百分比排序输出</td></tr><tr><td align="left">P</td><td align="left">按CPU使用百分比排序输出</td></tr><tr><td align="left">q</td><td align="left">退出top</td></tr></tbody></table><h2 id="3-管理进程状态"><a href="#3-管理进程状态" class="headerlink" title="3.管理进程状态"></a>3.管理进程状态</h2><blockquote><p>当程序运行为进程后，如果希望停止进程，怎么办呢? 那么此时我们可以使用linux的<code>kill</code>命令对进程发送关闭信号。当然除了<code>kill</code>、还有<code>killall</code>，<code>pkill</code></p></blockquote><h3 id="1-使用kill-l列出当前系统所支持的信号"><a href="#1-使用kill-l列出当前系统所支持的信号" class="headerlink" title="1.使用kill -l列出当前系统所支持的信号"></a>1.使用kill -l列出当前系统所支持的信号</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/13/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/5.jpg" alt="5"></p><blockquote><p>虽然linux支持信号很多，但是我们仅列出我们最为常用的3个信号</p></blockquote><p>|数字编号|信号含义|信号翻译|<br>|:–|:–|:–|:–|<br>|1|SIGHUP|通常用来重新加载配置文件|<br>|9|SIGKILL|强制杀死进程|<br>|15|SIGTERM|终止进程，默认kill使用该信号|</p><h3 id="2-使用kill命令杀死指定PID的进程。"><a href="#2-使用kill命令杀死指定PID的进程。" class="headerlink" title="2.使用kill命令杀死指定PID的进程。"></a>2.使用kill命令杀死指定PID的进程。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># yum -y install vsftpd</span></span><br><span class="line">[root@demo ~]<span class="comment"># systemctl start vsftpd</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps aux|grep vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.发送重载信号，例如 vsftpd 的配置文件发生改变，希望重新加载</span></span><br><span class="line">[root@demo ~]<span class="comment"># kill -1 9160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.发送停止信号，当然vsftpd 服务有停止的脚本 systemctl stop vsftpd</span></span><br><span class="line">[root@demo ~]<span class="comment"># kill 9160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.发送强制停止信号，当无法停止服务时，可强制终止信号</span></span><br><span class="line">[root@demo ~]<span class="comment"># kill -9 9160</span></span><br></pre></td></tr></table></figure><h3 id="3-Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。"><a href="#3-Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。" class="headerlink" title="3.Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。"></a>3.Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例1、通过服务名称杀掉进程</span></span><br><span class="line">[root@demo ~]<span class="comment"># pkill nginx</span></span><br><span class="line">[root@demo ~]<span class="comment"># killall nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例2、使用pkill踢出从远程登录到本机的用户，终止pts/0上所有进程, 并且bash也结束（用户被强制退出）</span></span><br><span class="line">[root@demo ~]<span class="comment"># pkill -9 -t pts/0</span></span><br></pre></td></tr></table></figure><h2 id="4-管理后台进程"><a href="#4-管理后台进程" class="headerlink" title="4.管理后台进程"></a>4.管理后台进程</h2><h3 id="1-什么是后台进程"><a href="#1-什么是后台进程" class="headerlink" title="1.什么是后台进程"></a>1.什么是后台进程</h3><blockquote><p>通常进程都会在终端前台运行，一旦关闭终端，进程也会随着结束，那么此时我们就希望进程能在&gt;后台运行，就是将在前台运行的进程放入后台运行，这样及时我们关闭了终端也不影响进程的正常&gt;运行。</p></blockquote><h3 id="2-我们为什么要将进程放入后台运行"><a href="#2-我们为什么要将进程放入后台运行" class="headerlink" title="2.我们为什么要将进程放入后台运行"></a>2.我们为什么要将进程放入后台运行</h3><blockquote><p>比如：我们此前在国内服务器往国外服务器传输大文件时，由于网络的问题需要传输很久，如果在传输的过程中出现网络抖动或者不小心关闭了终端则会导致传输失败，如果能将传输的进程放入后台，是不是就能解决此类问题了。</p></blockquote><h3 id="3-使用什么工具将进程放入后台"><a href="#3-使用什么工具将进程放入后台" class="headerlink" title="3.使用什么工具将进程放入后台"></a>3.使用什么工具将进程放入后台</h3><blockquote><p>早期的时候大家都选择使用&amp;符号将进程放入后台，然后在使用<code>jobs</code>、<code>bg</code>、<code>fg</code>等方式查看进程状态，但太麻烦了。也不直观，所以我们推荐使用<code>screen</code>！！！</p></blockquote><h3 id="4-jobs、bg、fg的使用-强烈不推荐，了解即可"><a href="#4-jobs、bg、fg的使用-强烈不推荐，了解即可" class="headerlink" title="4.jobs、bg、fg的使用(强烈不推荐，了解即可)"></a>4.jobs、bg、fg的使用(强烈不推荐，了解即可)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># sleep 3000 &amp; //运行程序(时)，让其在后台执行 </span></span><br><span class="line">[root@demo ~]<span class="comment"># sleep 4000 //^Z,将前台的程序挂起(暂停)到后台 </span></span><br><span class="line">[2]+ Stopped sleep 4000</span><br><span class="line">[root@demo ~]<span class="comment"># ps aux |grep sleep</span></span><br><span class="line">[root@demo ~]<span class="comment"># jobs  //查看后台作业</span></span><br><span class="line">[1]- Running sleep 3000 &amp; </span><br><span class="line">[2]+ Stopped sleep 4000</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># bg %2     //让作业 2 在后台运行</span></span><br><span class="line">[root@demo ~]<span class="comment"># fg %1     //将作业 1 调回到前台</span></span><br><span class="line">[root@demo ~]<span class="comment"># kill %1   //kill 1，终止 PID 为 1 的进程</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># (while :; do date; sleep 2; done) &amp; //进程在后台运行，但输出依然在当前终端</span></span><br><span class="line">[root@demo ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;&gt;/dev/null &amp;</span></span><br></pre></td></tr></table></figure><h3 id="5-screen的使用-强烈推荐，生产必用"><a href="#5-screen的使用-强烈推荐，生产必用" class="headerlink" title="5.screen的使用(强烈推荐，生产必用)"></a>5.screen的使用(强烈推荐，生产必用)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install screen -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.开启一个screen窗口,指定名称</span></span><br><span class="line">[root@demo ~]<span class="comment"># screen -S wget_mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在screen窗口中执行任务即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.平滑的退出screen,但不会终止screen中的任务。注意: 如果使用exit 才算真的关闭screen窗口</span></span><br><span class="line">ctrl+a+d</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.查看当前正在运行的screen有哪些</span></span><br><span class="line">[root@demo ~]<span class="comment"># screen -list</span></span><br><span class="line">There is a screen on:</span><br><span class="line">    22058.wget_mysql    (Detached)</span><br><span class="line">1 Socket <span class="keyword">in</span> /var/run/screen/S-root.</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.进入正在运行的screen</span></span><br><span class="line">[root@demo ~]<span class="comment"># screen -r wget_mysql</span></span><br><span class="line">[root@demo ~]<span class="comment"># screen -r 22058</span></span><br></pre></td></tr></table></figure><h2 id="5-进程的优先级"><a href="#5-进程的优先级" class="headerlink" title="5.进程的优先级"></a>5.进程的优先级</h2><h3 id="1-什么优先级"><a href="#1-什么优先级" class="headerlink" title="1.什么优先级"></a>1.什么优先级</h3><blockquote><p>优先级指的是优先享受资源，比如排队买票时，军人优先、老人优先。等等</p></blockquote><h3 id="2-为什么要有系统优先级"><a href="#2-为什么要有系统优先级" class="headerlink" title="2.为什么要有系统优先级"></a>2.为什么要有系统优先级</h3><blockquote><p>举个例子: 海底捞火锅正常情况下响应就特别快，那么当节假日来临时人员突增则会导致处理请求特别慢，那么假设我是海底捞VIP客户(最高优先级)，无论门店多么繁忙，我都不用排队，海底捞人员会直接服务于我，满足我的需求。至于没有VIP的人员(较低优先级)则进入排队等待状态。</p></blockquote><h3 id="3-系统中如何给进程配置优先级"><a href="#3-系统中如何给进程配置优先级" class="headerlink" title="3.系统中如何给进程配置优先级?"></a>3.系统中如何给进程配置优先级?</h3><blockquote><p>在启动进程时，为不同的进程使用不同的调度策略。</p><ul><li><strong>cnice 值越高： 表示优先级越低，例如+19，该进程容易将CPU 使用量让给其他进程。</strong></li><li><strong>nice 值越低： 表示优先级越高，例如-20，该进程更不倾向于让出CPU。</strong></li></ul></blockquote><h4 id="1-使用top或ps命令查看进程的优先级"><a href="#1-使用top或ps命令查看进程的优先级" class="headerlink" title="1.使用top或ps命令查看进程的优先级"></a>1.使用top或ps命令查看进程的优先级</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用top可以查看nice优先级。 </span></span><br><span class="line">    NI: 实际nice级别，默认是0。</span><br><span class="line">    PR: 显示nice值，-20映射到0，+19映射到39</span><br><span class="line">    </span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR  S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">1083 root     20  0     298628  2808   1544 S  0.3  0.1   2:49.28 vmtoolsd</span><br><span class="line">5    root      0  -20   0       0      0    S  0.0  0.0   0:00.00 kworker/0:+</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用ps查看进程优先级</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo command,nice |grep sshd|grep -v grep</span></span><br><span class="line">/usr/sbin/sshd -D             0</span><br><span class="line">sshd: root@pts/2              0</span><br></pre></td></tr></table></figure><h4 id="2-nice指定程序的优先级。语法格式-nice-n-优先级数字-进程名称"><a href="#2-nice指定程序的优先级。语法格式-nice-n-优先级数字-进程名称" class="headerlink" title="2.nice指定程序的优先级。语法格式 nice -n 优先级数字 进程名称"></a>2.nice指定程序的优先级。语法格式 nice -n 优先级数字 进程名称</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.开启vim并且指定程序优先级为-5</span></span><br><span class="line">[root@m01 ~]<span class="comment"># nice -n -5 vim &amp;</span></span><br><span class="line">[1] 98417</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查看该进程的优先级情况</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 98417</span></span><br><span class="line"> 98417 vim                       </span><br></pre></td></tr></table></figure><h4 id="3-enice命令修改一个正在运行的进程优先级。语法格式-renice-n-优先级数字-进程pid"><a href="#3-enice命令修改一个正在运行的进程优先级。语法格式-renice-n-优先级数字-进程pid" class="headerlink" title="3.enice命令修改一个正在运行的进程优先级。语法格式 renice -n 优先级数字 进程pid"></a>3.enice命令修改一个正在运行的进程优先级。语法格式 renice -n 优先级数字 进程pid</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看sshd进程当前的优先级状态</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps axo pid,command,nice |grep sshd</span></span><br><span class="line">  1210 /usr/sbin/sshd -D             0</span><br><span class="line"> 11215 sshd: root@pts/0              0</span><br><span class="line"> 11321 grep --color=auto sshd        0</span><br><span class="line"> </span><br><span class="line"><span class="comment">#2.调整sshd主进程的优先级</span></span><br><span class="line">[root@demo ~]<span class="comment"># renice -n -20 1210</span></span><br><span class="line">1210 (process ID) old priority 0, new priority -20</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.调整之后记得退出终端</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps axo pid,command,nice |grep sshd</span></span><br><span class="line"> 70840 sshd: root@pts/2              0</span><br><span class="line"> 1210 /usr/sbin/sshd -D            -20</span><br><span class="line">[root@demo ~]<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.当再次登陆sshd服务，会由主进程fork子进程(那么子进程会继承主进程的优先级)</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps axo pid,command,nice |grep sshd</span></span><br><span class="line"> 98002 /usr/sbin/sshd -D           -20</span><br><span class="line"> 98122 sshd: root@pts/0            -20</span><br></pre></td></tr></table></figure><h2 id="6-系统平均负载"><a href="#6-系统平均负载" class="headerlink" title="6.系统平均负载"></a>6.系统平均负载</h2><blockquote><p>每次发现系统变慢时，我们通常会执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># uptime</span></span><br><span class="line"> 04:49:26 up 2 days,  2:33,  2 users,  load average: 0.70, 0.04, 0.05</span><br><span class="line"><span class="comment">#我们已经比较熟悉前面几列，它们分别是当前时间、系统运行时间以及正在登录用户数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而最后三个数字呢，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</span></span><br></pre></td></tr></table></figure><h3 id="1-什么是平均负载？"><a href="#1-什么是平均负载？" class="headerlink" title="1.什么是平均负载？"></a>1.什么是平均负载？</h3><blockquote><p>平均负载不就是单位时间内的 CPU 使用率吗？上面的 0.70，就代表 CPU 使用率是 70%。其实不然…..<br>那到底如何理解平均负载：<strong>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数</strong><br><mark>PS: 平均负载与 CPU 使用率并没有直接关系。</mark></p></blockquote><h3 id="2-可运行状态和不可中断状态是什么？"><a href="#2-可运行状态和不可中断状态是什么？" class="headerlink" title="2.可运行状态和不可中断状态是什么？"></a>2.可运行状态和不可中断状态是什么？</h3><blockquote><ul><li>1.可运行状态进程，是指正在使用 <code>CPU</code> 或者正在等待 <code>CPU</code> 的进程，也就是我们ps 命令看到处于 R 状态的进程。</li><li>2.不可中断进程，(你做什么事情的时候是不能打断的?) 系统中最常见的是等待<code>硬件设备</code>的<code> I/O 响应</code>，也就是我们<code> ps</code> 命令中看到的<code>D </code>状态（也称为 <code>Disk Sleep</code>）的进程。<br>例如：当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程中断或打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种<code>保护机制</code>。</li></ul></blockquote><blockquote><p><mark><strong>【重点】：因此你可以简单理解为，平均负载其实就是单位时间内的活跃进程数。</strong></mark></p></blockquote><h3 id="3-那平均负载为多少时合理？"><a href="#3-那平均负载为多少时合理？" class="headerlink" title="3.那平均负载为多少时合理？"></a>3.那平均负载为多少时合理？</h3><blockquote><p>最理想的状态是<code>每个 CPU</code> 上都刚好运行着一个进程，这样<code>每个 CPU</code> 都得到了充分利用。所以在评判平均负载时，首先你要知道系统有<code>几个 CPU</code>，这可以通过 <code>top</code> 命令获取，或<code>grep &#39;model name&#39; /proc/cpuinfo</code></p></blockquote><blockquote><p>例1、假设现在有三个系统，各自的CPU数为：4、2、1，如果平均负载为 2 时，意味着什么呢？</p><ul><li>Q1.在4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</li><li>Q2.在2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</li><li>Q3.而1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</li></ul></blockquote><h4 id="1-平均负载有三个数值，我们应该关注哪个呢"><a href="#1-平均负载有三个数值，我们应该关注哪个呢" class="headerlink" title="1.平均负载有三个数值，我们应该关注哪个呢?"></a>1.平均负载有三个数值，我们应该关注哪个呢?</h4><blockquote><ul><li>1.如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</li><li>2.但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</li><li>3.反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续上升，所以就需要持续观察。</li></ul></blockquote><div class="note danger">            <p>一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析问题，并要想办法优化了</p>          </div><blockquote><p>例子：假设我们在有<code>2个 CPU</code> 系统上看到平均负载为 <code>2.73</code>，<code>6.90</code>，<code>12.98</code></p><ul><li>那么说明在过去1 分钟内，系统有 136% 的超载 (2.73/2=136%)</li><li>而在过去 5 分钟内，有 345% 的超载 (6.90/2=345%)</li><li>而在过去15 分钟内，有 649% 的超载，(12.98/2=649%)</li><li>但从整体趋势来看，系统的负载是在逐步的降低。</li></ul></blockquote><h3 id="4-那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？"><a href="#4-那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？" class="headerlink" title="4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？"></a>4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？</h3><blockquote><ul><li><strong>当平均负载高于 <code>CPU 数量 70% </code>的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</strong></li><li><strong>但<code> 70%</code>这个数字并不是绝对的，最<code>推荐的方法</code>，还是把<code>系统的平均负载监控</code>起来，然后根据更多的历史数据，<code>判断负载</code>的变化趋势。当发现负载有<code>明显升高趋势</code>时，比如说<code>负载翻倍</code>了，你再去做<code>分析</code>和<code>调查</code>。</strong></li></ul></blockquote><h3 id="5-平均负载与-CPU-使用率有什么关系？"><a href="#5-平均负载与-CPU-使用率有什么关系？" class="headerlink" title="5.平均负载与 CPU 使用率有什么关系？"></a>5.平均负载与 CPU 使用率有什么关系？</h3><blockquote><p><strong>在实际工作中，我们经常容易把<code>平均负载</code>和 <code>CPU 使用率</code>混淆，所以在这里，我也做一个区分。可能你会疑惑，既然<code>平均负载</code>代表的是<code>活跃进程数</code>，那<code>平均负载</code>高了，不就意味着<code> CPU 使用率</code>高吗？</strong><br><strong>我们还是要回到<code>平均负载</code>的含义上来，平均负载是指<code>单位时间</code>内，处于<code>可运行状态</code>和<code>不可中断状态</code>的<code>进程数</code>。所以，它不仅包括了正在使用 <code>CPU 的进程</code>，还包括<code>等待 CPU </code>和<code>等待 I/O </code>的进程。</strong></p><p>而 <code>CPU 使用率</code>，是<code>单位时间</code>内 <code>CPU</code> 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p><ul><li><strong>1.CPU 密集型进程：使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</strong></li><li><strong>2.I/O 密集型进程：等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</strong></li><li><strong>3.大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</strong></li></ul></blockquote><h3 id="平均负载案例分析实战"><a href="#平均负载案例分析实战" class="headerlink" title="平均负载案例分析实战"></a>平均负载案例分析实战</h3><blockquote><p>下面，我们以三个示例分别来看这三种情况，并用 <code>stress、mpstat、pidstat </code>等工具，找出平均负载升高的根源。<br><code>stress</code> 是 <code>Linux 系统</code>压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。<br><code>mpstat</code> 是多核<code> CPU 性能</code>分析工具，用来实时查看每个 <code>CPU</code> 的性能指标，以及所有 <code>CPU</code> 的平均指标。<br><code>pidstat</code> 是一个常用的进程性能分析工具，用来实时查看进程的 <code>CPU、内存、I/O </code>以及上下文切换等性能指标。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果出现无法使用mpstat、pidstat命令查看%wait指标建议更新下软件包</span></span><br><span class="line">wget http://pagesperso-orange.fr/sebastien.godard/sysstat-11.7.3-1.x86_64.rpm</span><br><span class="line">rpm -Uvh sysstat-11.7.3-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h4 id="场景一：CPU-密集型进程"><a href="#场景一：CPU-密集型进程" class="headerlink" title="场景一：CPU 密集型进程"></a>场景一：CPU 密集型进程</h4><blockquote><p>1.首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress --cpu 1 --timeout 600</span></span><br></pre></td></tr></table></figure><blockquote><p>2.接着，在第二个终端运行 uptime 查看平均负载的变化情况</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用watch -d 参数表示高亮显示变化的区域(注意负载会持续升高)</span></span><br><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">17:27:44 up 2 days,  3:11,  3 users,  load average: 1.10, 0.30, 0.17</span><br></pre></td></tr></table></figure><blockquote><p>3.最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2017年04月29日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">17时32分03秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">17时32分08秒  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">17时32分08秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="comment">#单核CPU所以只有一个all和0</span></span><br></pre></td></tr></table></figure><blockquote><p>4.从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 <code>pidstat</code> 来查询</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line"></span><br><span class="line">17时33分21秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">17时33分26秒     0    110019   98.80    0.00    0.00   98.80     0  stress</span><br><span class="line"></span><br><span class="line"><span class="comment">#从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</span></span><br></pre></td></tr></table></figure><h4 id="场景二：I-O-密集型进程"><a href="#场景二：I-O-密集型进程" class="headerlink" title="场景二：I/O 密集型进程"></a>场景二：I/O 密集型进程</h4><blockquote><p>1.首先还是运行<code> stress</code> 命令，但这次模拟 I/O 压力，即不停地执行 sync</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress  --io 1 --timeout 600s</span></span><br></pre></td></tr></table></figure><blockquote><p>2.然后在第二个终端运行 <code>uptime</code>查看平均负载的变化情况：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">18:43:51 up 2 days,  4:27,  3 users,  load average: 1.12, 0.65, 0.00</span><br></pre></td></tr></table></figure><blockquote><p>3.最后第三个终端运行 <code>mpstat</code> 查看 CPU 使用率的变化情况：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">Linux 3.10.0-693.2.2.el7.x86_64 (bgx.com)   2019年05月07日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">14时20分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">14时20分12秒  all    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">14时20分12秒    0    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="comment">#会发现cpu的与内核打交道的sys占用非常高</span></span><br></pre></td></tr></table></figure><blockquote><p>4.那么到底是哪个进程，导致<code>iowait</code> 这么高呢？我们还是用<code>pidstat</code> 来查询</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line">18时29分37秒   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">18时29分42秒     0    127259   32.60    0.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127261    4.60   28.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127262    4.20   28.60    0.00   67.20   32.80     0  stress</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以发现，还是 stress 进程导致的。</span></span><br></pre></td></tr></table></figure><h4 id="场景三：大量进程的场景"><a href="#场景三：大量进程的场景" class="headerlink" title="场景三：大量进程的场景"></a>场景三：大量进程的场景</h4><blockquote><p>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p><p>1.首先，我们还是使用 <code>stress</code>，但这次模拟的是 <code>4</code> 个进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress -c 4 --timeout 600</span></span><br></pre></td></tr></table></figure><blockquote><p>2.由于系统只有 1 个 CPU，明显比 4 个进程要少得多，因而，系统的 CPU 处于严重过载状态</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">19:11:07 up 2 days,  4:45,  3 users,  load average: 4.65, 2.65, 4.65</span><br></pre></td></tr></table></figure><blockquote><p>3.然后，再运行 <code>pidstat</code> 来看一下进程的情况：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">平均时间:   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">平均时间:     0    130290   24.55    0.00    0.00   75.25   24.55     -  stress</span><br><span class="line">平均时间:     0    130291   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130292   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130293   24.75    0.00    0.00   74.65   24.75     -  stress</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，<code>4 个</code>进程在争抢 <code>1 个 CPU</code>，每个进程等待 <code>CPU 的时间</code>（也就是代码块中的 %wait 列）高达 <code>75%</code>。这些超出<code> CPU 计算能力</code>的进程，最终导致<code> CPU 过载</code>。</p><p>分析完这三个案例，总结一下平均负载与CPU</p><ul><li>1.平均负载提供了一个快速查看<code>系统整体性能</code>的手段，反映了整体的<code>负载情况</code>。但只看<code>平均负载</code>本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：<br>A.<code>平均负载高</code>有可能是 <code>CPU 密集型进程</code>导致的；<br>B.平均负载高并不一定代表 <code>CPU 使用率高</code>，还有可能是 <code>/O</code>更繁忙了；<br><mark>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源</mark></li></ul></blockquote><p><strong><a href="https://www.cnblogs.com/muahao/p/6346775.html" target="_blank">stress工具使用参考</a></strong></p>]]></content>
    
    
    <summary type="html">Linux 进程管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 进程管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 磁盘管理</title>
    <link href="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-12T15:10:01.000Z</published>
    <updated>2020-08-25T15:24:39.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-磁盘的基本概念"><a href="#1-磁盘的基本概念" class="headerlink" title="1.磁盘的基本概念"></a>1.磁盘的基本概念</h2><h3 id="1-什么是磁盘"><a href="#1-什么是磁盘" class="headerlink" title="1.什么是磁盘"></a>1.什么是磁盘</h3><blockquote><p><strong>磁盘（disk）是指利用磁记录技术存储数据的存储器</strong><br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/1.gif" alt="1"></p></blockquote><blockquote><p>每个硬盘中心都是一摞高速运转的圆盘，在圆盘上附着一圈金属颗粒，每个金属颗粒都有自己的磁化程度，用于储存0和1。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/2.gif" alt="2"></p></blockquote><blockquote><p>当记录数据时，硬盘的磁头开始通电，形成强磁场，数据在磁场的作用下转变成电流，使颗粒磁化，从而将信息记录在圆盘上。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/3.gif" alt="3"></p></blockquote><blockquote><p>由海量颗粒组成的信息，就是我们存在硬盘里的数据。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/4.jpg" alt="4"></p></blockquote><h2 id="2-磁盘的基本结构"><a href="#2-磁盘的基本结构" class="headerlink" title="2.磁盘的基本结构"></a>2.磁盘的基本结构</h2><blockquote><ol><li>什么是盘片：硬盘一般有一个或多个盘片，每个盘片可以有两面，即第一个盘片的正面为0面，反面为1面然后依次类推。</li><li>什么是磁道：每个盘片的盘面在出厂的时候被划分出了多个同心圆环，数据就存储在这样的同心圆环上面，我们将这样的圆环称为磁道(Track)，每个盘面可以划分多个磁道。但肉眼不可见。</li><li>什么是扇区：在硬盘出厂时会对磁盘进行一次低格，其实就是每个磁道划分若干个弧段，每个弧段就是一个扇区 (Sector)。扇区是硬盘上存储的物理单位，现在每个扇区可存储<code>512字节</code>数据已经成了业界的约定。</li><li>什么是柱面：柱面实际上就是我们抽象出来的一个逻辑概念，简单来说就是处于同一个垂直区域的磁道称为柱面 ，即各盘面上面相同位置磁道的集合。这样数据如果存储到相同半径磁道上的同一扇区，这样可以实现并行读取，主要是<code>减少磁头寻道时间</code>。</li><li>什么是磁头：读取磁盘磁道上面金属块，主要负责读或写入数据。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/5.jpg" alt="5"><br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/6.jpg" alt="6"></li></ol></blockquote><h2 id="磁盘基础知识"><a href="#磁盘基础知识" class="headerlink" title="磁盘基础知识"></a>磁盘基础知识</h2><h3 id="1-磁盘的接口类型"><a href="#1-磁盘的接口类型" class="headerlink" title="1.磁盘的接口类型"></a>1.磁盘的接口类型</h3><blockquote><ol><li>IDE</li><li>SCSI（已经被淘汰）<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/7.jpg" alt="7"></li></ol></blockquote><blockquote><ol start="3"><li>SATA 3.0 与 SAS (企业使用较多)<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/12/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/8.jpg" alt="8"></li></ol></blockquote><blockquote><ol start="4"><li>mSATA接口的SSD是为超极本设计，但后来被M.2接口的SSD替代，而M.2接口(支持SATA、PCI-E双通道协议)</li></ol></blockquote><h3 id="2-磁盘的基本术语"><a href="#2-磁盘的基本术语" class="headerlink" title="2.磁盘的基本术语"></a>2.磁盘的基本术语</h3><blockquote><p><strong>尺寸: 2.5英寸、3.5英寸</strong><br><strong>容量：KB、MB、GB、TB、PB、EB</strong><br><strong>转速：7500、15000</strong><br><strong>IOPS：每秒能够发生IO的次数</strong></p></blockquote><h3 id="3-磁盘在Linux系统上的命名方式"><a href="#3-磁盘在Linux系统上的命名方式" class="headerlink" title="3.磁盘在Linux系统上的命名方式"></a>3.磁盘在Linux系统上的命名方式</h3><table><thead><tr><th align="left">设备名称</th><th align="left">分区信息</th><th align="left">设备类型</th></tr></thead><tbody><tr><td align="left">/dev/sda</td><td align="left">/dev/sda1</td><td align="left">第一块物理磁盘第一分区</td></tr><tr><td align="left">/dev/sdb</td><td align="left">/dev/sdb2</td><td align="left">第二块物理磁盘第二个分区</td></tr><tr><td align="left">/dev/vdd</td><td align="left">/dev/vdd4</td><td align="left">第四块虚拟磁盘的第四个分区</td></tr></tbody></table><blockquote><p><mark>1.【注意】：系统中分区由数字编号表示，1~4留给主分区使用和扩展分区，逻辑分区从5开始，因为MBR分区表只能分配4个主分区，</mark>具体原因请看链接：<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/7612638" target="_blank">MBR为什么只能划分4个主分区</a></p></blockquote><blockquote><p><mark>2.【注意】：前面我们已经提到过MBR分区表只能分配4个主分区，但现在还有一种新型的分区表GPT，GPT支持分配128个主分区。注意MBR与GPT之间不能互转，会导致数据丢失。</mark>具体原因请看链接：<a href="http://www.udaxia.com/wtjd/6117.html" target="_blank">MBR与GPT之间又有什么区别</a></p></blockquote><h2 id="4-磁盘基本分区Fdisk"><a href="#4-磁盘基本分区Fdisk" class="headerlink" title="4.磁盘基本分区Fdisk"></a>4.磁盘基本分区Fdisk</h2><h3 id="1-添加一块小于2TB的磁盘进行使用，步骤如下"><a href="#1-添加一块小于2TB的磁盘进行使用，步骤如下" class="headerlink" title="1.添加一块小于2TB的磁盘进行使用，步骤如下:"></a>1.添加一块小于2TB的磁盘进行使用，步骤如下:</h3><blockquote><ol><li>给服务器添加一块新的硬盘</li><li>使用fdisk进行分区</li><li>使用mkfs进行格式化</li><li>使用mount进行挂载</li></ol></blockquote><h4 id="fdisk命令示例"><a href="#fdisk命令示例" class="headerlink" title="fdisk命令示例"></a>fdisk命令示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># fdisk  /dev/sdb</span></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m         <span class="comment">#输入m列出常用的命令</span></span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag               <span class="comment">#切换分区启动标记</span></span><br><span class="line">   b   edit bsd disklabel                   <span class="comment">#编辑sdb磁盘标签</span></span><br><span class="line">   c   toggle the dos compatibility flag    <span class="comment">#切换dos兼容模式</span></span><br><span class="line">   d   delete a partition                   <span class="comment">#删除分区</span></span><br><span class="line">   l   list known partition types           <span class="comment">#显示分区类型</span></span><br><span class="line">   m   <span class="built_in">print</span> this menu                      <span class="comment">#显示帮助菜单</span></span><br><span class="line">   n   add a new partition                  <span class="comment">#新建分区</span></span><br><span class="line">   o   create a new empty DOS partition table   <span class="comment">#创建新的空白分区表</span></span><br><span class="line">   p   <span class="built_in">print</span> the partition table            <span class="comment">#显示分区表的信息</span></span><br><span class="line">   q   quit without saving changes          <span class="comment">#不保存退出</span></span><br><span class="line">   s   create a new empty Sun disklabel     <span class="comment">#创建新的Sun磁盘标签</span></span><br><span class="line">   t   change a partitions system id        <span class="comment">#修改分区ID,可以通过l查看id</span></span><br><span class="line">   u   change display/entry units           <span class="comment">#修改容量单位,磁柱或扇区</span></span><br><span class="line">   v   verify the partition table           <span class="comment">#检验分区表</span></span><br><span class="line">   w   write table to disk and <span class="built_in">exit</span>         <span class="comment">#保存退出</span></span><br><span class="line">   x   extra functionality (experts only)   <span class="comment">#拓展功能</span></span><br></pre></td></tr></table></figure><h4 id="1-给服务器添加一块新的硬盘"><a href="#1-给服务器添加一块新的硬盘" class="headerlink" title="1. 给服务器添加一块新的硬盘"></a>1. 给服务器添加一块新的硬盘</h4><h4 id="2-使用fdisk进行分区"><a href="#2-使用fdisk进行分区" class="headerlink" title="2. 使用fdisk进行分区"></a>2. 使用fdisk进行分区</h4><h5 id="1-fdisk创建主分区"><a href="#1-fdisk创建主分区" class="headerlink" title="1.fdisk创建主分区"></a>1.fdisk创建主分区</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)  <span class="comment">#主分区</span></span><br><span class="line">   e   extended  <span class="comment">#扩展分区</span></span><br><span class="line">Select (default p): p   <span class="comment">#选择创建主分区</span></span><br><span class="line">Partition number (1-4, default 1):  <span class="comment">#默认创建第一个主分区</span></span><br><span class="line">First sector (2048-2097151, default 2048): <span class="comment">#默认扇区回车</span></span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +50M <span class="comment">#分配50MB</span></span><br></pre></td></tr></table></figure><h5 id="2-fdisk创建扩展分区"><a href="#2-fdisk创建扩展分区" class="headerlink" title="2.fdisk创建扩展分区"></a>2.fdisk创建扩展分区</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n  <span class="comment">#新建分区</span></span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e   <span class="comment">#创建扩展分区</span></span><br><span class="line">Partition number (2-4, default 2):</span><br><span class="line">First sector (104448-2097151, default 104448):</span><br><span class="line">Using default value 104448</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104448-2097151, default 2097151): <span class="comment">#空间都给到扩展分区</span></span><br></pre></td></tr></table></figure><h5 id="3-fdisk创建逻辑分区"><a href="#3-fdisk创建逻辑分区" class="headerlink" title="3.fdisk创建逻辑分区"></a>3.fdisk创建逻辑分区</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n  <span class="comment">#新建分区</span></span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l   <span class="comment">#创建逻辑分区</span></span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (106496-2097151, default 106496):</span><br><span class="line">Using default value 106496</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (106496-2097151, default 2097151): +100M  <span class="comment">#分配100MB空间</span></span><br></pre></td></tr></table></figure><h5 id="4-fdisk查看分区情况，并保存"><a href="#4-fdisk查看分区情况，并保存" class="headerlink" title="4.fdisk查看分区情况，并保存"></a>4.fdisk查看分区情况，并保存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p <span class="comment">#查看分区创建</span></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048      104447       51200   83  Linux</span><br><span class="line">/dev/sdb2          104448     2097151      996352    5  Extended</span><br><span class="line">/dev/sdb5          106496      311295      102400   83  Linux</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存分区</span></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查磁盘是否是MBR分区方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># fdisk /dev/sdb -l|grep type</span></span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装parted, 刷新内核立即生效,无需重启</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum -y install parted</span></span><br><span class="line">[root@demo ~]<span class="comment"># partprobe /dev/sdb</span></span><br></pre></td></tr></table></figure><h4 id="3-使用mkfs进行格式化"><a href="#3-使用mkfs进行格式化" class="headerlink" title="3. 使用mkfs进行格式化"></a>3. 使用mkfs进行格式化</h4><blockquote><p>mkfs格式化磁盘，实质是创建文件系统，文件系统类似于将房子装修成3室一厅，还是2室一厅。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项: </span></span><br><span class="line"><span class="comment"># -b  设定数据区块占用空间大小，目前支持1024、2048、4096 bytes每个块。</span></span><br><span class="line"><span class="comment"># -t  用来指定什么类型的文件系统，可以是ext4, xfs</span></span><br><span class="line"><span class="comment"># -i  设定inode的大小</span></span><br><span class="line"><span class="comment"># -N  设定inode数量，防止Inode数量不够导致磁盘不足</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.格式化整个磁盘</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkfs.ext4  /dev/sdb </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.格式化磁盘的某个分区</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkfs.xfs  /dev/sdb1</span></span><br></pre></td></tr></table></figure><h4 id="4-使用mount进行挂载"><a href="#4-使用mount进行挂载" class="headerlink" title="4. 使用mount进行挂载"></a>4. 使用mount进行挂载</h4><blockquote><p>如果需要使用该磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># mkdir /data</span></span><br><span class="line">[root@demo ~]<span class="comment"># mount /dev/sdb1 /data</span></span><br></pre></td></tr></table></figure><h2 id="5-磁盘的基本分区Gdisk"><a href="#5-磁盘的基本分区Gdisk" class="headerlink" title="5.磁盘的基本分区Gdisk"></a>5.磁盘的基本分区Gdisk</h2><blockquote><p>前面我们已经了解到<code>fdisk分区</code>，但<code>fdisk</code>不支持给高于<code>2TB</code>的磁盘进行分区。如果有单块盘高于<code>2TB</code>，建议使用<code>Gdisk</code>进行分区。</p></blockquote><h3 id="1-使用gdisk进行磁盘分区"><a href="#1-使用gdisk进行磁盘分区" class="headerlink" title="1.使用gdisk进行磁盘分区"></a>1.使用gdisk进行磁盘分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.安装gdisk分区工具</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install gdisk -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建一个新分区，500MB大小</span></span><br><span class="line">[root@demo ~]<span class="comment"># gdisk /dev/sdb</span></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): n     <span class="comment">#创建新分区</span></span><br><span class="line">Partition number (1-128, default 1):</span><br><span class="line">First sector (34-2097118, default = 2048) or &#123;+-&#125;size&#123;KMGTP&#125;:</span><br><span class="line">Last sector (2048-2097118, default = 2097118) or &#123;+-&#125;size&#123;KMGTP&#125;: +500M <span class="comment">#分配500M大小</span></span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): p <span class="comment">#打印查看</span></span><br><span class="line">Number  Start (sector)    End (sector)  Size       Code  Name</span><br><span class="line">   1            2048         1026047   500.0 MiB   8300  Linux filesystem</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): w <span class="comment">#保存分区</span></span><br><span class="line">Do you want to proceed? (Y/N): y    <span class="comment">#确认</span></span><br><span class="line">OK; writing new GUID partition table (GPT) to /dev/sdb.</span><br><span class="line">The operation has completed successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建完成后，可以尝试检查磁盘是否为gpt格式</span></span><br><span class="line">[root@demo /]<span class="comment"># fdisk /dev/sdb -l|grep type</span></span><br><span class="line">Disk label <span class="built_in">type</span>: gpt</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.安装parted, 刷新内核立即生效,无需重启</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum -y install parted</span></span><br><span class="line">[root@demo ~]<span class="comment"># partprobe /dev/sdb</span></span><br></pre></td></tr></table></figure><h3 id="2-使用mkfs进行格式化磁盘。"><a href="#2-使用mkfs进行格式化磁盘。" class="headerlink" title="2.使用mkfs进行格式化磁盘。"></a>2.使用mkfs进行格式化磁盘。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># mkfs.xfs  /dev/sdb</span></span><br></pre></td></tr></table></figure><h3 id="3-使用mount命令将某个目录挂载该分区，进行使用。"><a href="#3-使用mount命令将某个目录挂载该分区，进行使用。" class="headerlink" title="3.使用mount命令将某个目录挂载该分区，进行使用。"></a>3.使用mount命令将某个目录挂载该分区，进行使用。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># mkdir /data_gdisk</span></span><br><span class="line">[root@demo ~]<span class="comment"># mount /dev/sdb /data_gdisk</span></span><br></pre></td></tr></table></figure><h2 id="6-磁盘挂载方式Mount"><a href="#6-磁盘挂载方式Mount" class="headerlink" title="6.磁盘挂载方式Mount"></a>6.磁盘挂载方式Mount</h2><blockquote><p>前面我们已经提到过，如果需要使用磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。<code>mount</code>主要是为文件系统指定一个访问入口。<br>类似我的商场没有门，那么就无法进入购买商品，此时通过mount命令可以创建一个入口。给超市安装一个门。</p></blockquote><h3 id="1-通过mount进行挂载，但重启将会失效。我们称为临时生效。"><a href="#1-通过mount进行挂载，但重启将会失效。我们称为临时生效。" class="headerlink" title="1.通过mount进行挂载，但重启将会失效。我们称为临时生效。"></a>1.通过mount进行挂载，但重启将会失效。我们称为临时生效。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选项：-t指定文件系统挂载分区 </span></span><br><span class="line">       -a 挂载/etc/fstab中的配置文件 </span><br><span class="line">       -o 指定挂载参数</span><br><span class="line"><span class="comment"># 挂载/dev/sdb1至db1目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir /db1</span></span><br><span class="line">[root@demo ~]<span class="comment"># mount -t xfs /dev/sdb1  /db1/ </span></span><br></pre></td></tr></table></figure><h3 id="2-挂载的磁盘，如果不想使用可以使用umount进行卸载。"><a href="#2-挂载的磁盘，如果不想使用可以使用umount进行卸载。" class="headerlink" title="2.挂载的磁盘，如果不想使用可以使用umount进行卸载。"></a>2.挂载的磁盘，如果不想使用可以使用umount进行卸载。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项： -l 强制卸载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.卸载目录方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># umount /db1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.卸载设备方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># umount /dev/sdb1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.umount不能卸载的情况</span></span><br><span class="line">[root@demo db1]<span class="comment"># umount /db1  </span></span><br><span class="line">umount: /db1: device is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS: 如上情况解决办法有两种, 1.切换至其他目录 2.使用&#x27;-l&#x27;选项强制卸载    </span></span><br><span class="line">[root@demo db1]<span class="comment"># umount -l /db1</span></span><br></pre></td></tr></table></figure><h3 id="3-如果需要实现永久挂载，则需要将挂载信息写入-etc-fstab配置文件中实现。"><a href="#3-如果需要实现永久挂载，则需要将挂载信息写入-etc-fstab配置文件中实现。" class="headerlink" title="3.如果需要实现永久挂载，则需要将挂载信息写入/etc/fstab配置文件中实现。"></a>3.如果需要实现永久挂载，则需要将挂载信息写入/etc/fstab配置文件中实现。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用blkid命令获取各设备的UUID</span></span><br><span class="line">[root@demo ~]<span class="comment"># blkid |grep &quot;sdb1&quot;</span></span><br><span class="line">/dev/sdb1: UUID=<span class="string">&quot;e271b5b2-b1ba-4b18-bde5-66e394fb02d9&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用UUID挂载磁盘sdb1分区至于db1， 测试挂载</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mount UUID=&quot;e271b5b2-b1ba-4b18-bde5-66e394fb02d9&quot; /db1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.写入/etc/fstab中，实现开机自动挂载</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -1 /etc/fstab    </span></span><br><span class="line">UUID=e271b5b2-b1ba-4b18-bde5-66e394fb02d9 /db1 xfs  defaults 0  0</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.加载fstab配置文件, 同时检测语法是否有错误</span></span><br><span class="line">[root@demo ~]<span class="comment"># mount –a</span></span><br></pre></td></tr></table></figure><h4 id="1-etc-fstab配置文件编写格式"><a href="#1-etc-fstab配置文件编写格式" class="headerlink" title="1./etc/fstab配置文件编写格式"></a>1./etc/fstab配置文件编写格式</h4><table><thead><tr><th align="left">要挂载的设备</th><th align="left">挂载点(入口)</th><th align="left">文件系统类型</th><th align="left">挂载参数</th><th align="left">是否备份</th><th align="left">是否检查</th></tr></thead><tbody><tr><td align="left">/dev/sdb1</td><td align="left">/db1</td><td align="left">xfs</td><td align="left">defaults</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><h4 id="2-第四列：挂载参数，挂载参数有很多，在这块我们了解即可，不必深究。"><a href="#2-第四列：挂载参数，挂载参数有很多，在这块我们了解即可，不必深究。" class="headerlink" title="2.第四列：挂载参数，挂载参数有很多，在这块我们了解即可，不必深究。"></a>2.第四列：挂载参数，挂载参数有很多，在这块我们了解即可，不必深究。</h4><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">async/sync</td><td align="left">是否为同步方式运行。默认async</td></tr><tr><td align="left">user/nouser</td><td align="left">是否允许普通用户使用mount命令挂载。默认nouser</td></tr><tr><td align="left">exec/noexe</td><td align="left">是否允许可执行文件执行。默认exec</td></tr><tr><td align="left">suid/nosuid</td><td align="left">是否允许存在suid属性的文件。默认suid</td></tr><tr><td align="left">auto/noauto</td><td align="left">执行mount -a 命令时，此文件系统是否被主动挂载。默认auto</td></tr><tr><td align="left">rw/ro</td><td align="left">是否以只读或者读写模式进行挂载。默认rw</td></tr><tr><td align="left">default</td><td align="left">具有rw,suid,dev,exec,auto,nouser,async等默认参数的设定</td></tr></tbody></table><h4 id="3-第五列：是否进行备份，通常这个参数的值为0或者1"><a href="#3-第五列：是否进行备份，通常这个参数的值为0或者1" class="headerlink" title="3.第五列：是否进行备份，通常这个参数的值为0或者1"></a>3.第五列：是否进行备份，通常这个参数的值为0或者1</h4><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">代表不做备份</td></tr><tr><td align="left">1</td><td align="left">代表要每天进行备份操作</td></tr><tr><td align="left">2</td><td align="left">代表不定日期的进行备份操作</td></tr></tbody></table><h4 id="4-第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整"><a href="#4-第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整" class="headerlink" title="4.第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整"></a>4.第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整</h4><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">不要检验磁盘是否有坏道</td></tr><tr><td align="left">1</td><td align="left">检验</td></tr><tr><td align="left">2</td><td align="left">校验 (当1级别检验完成之后进行2级别检验)</td></tr></tbody></table><h2 id="7-虚拟磁盘介绍Swap"><a href="#7-虚拟磁盘介绍Swap" class="headerlink" title="7.虚拟磁盘介绍Swap"></a>7.虚拟磁盘介绍Swap</h2><blockquote><p><code>Swap分区</code>在系统的物理内存不够时，将硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。<br><mark>PS: 当物理内存不够时会随机kill占用内存的进程，从而产生<code>oom</code>，临时使用<code>swap</code>可以解决。</mark></p></blockquote><h3 id="1-创建分区，并格式化为swap分区"><a href="#1-创建分区，并格式化为swap分区" class="headerlink" title="1.创建分区，并格式化为swap分区"></a>1.创建分区，并格式化为swap分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># fdisk  /dev/sdb       #分1个G大小</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkswap /dev/sdb1      #格式化为swap</span></span><br></pre></td></tr></table></figure><h3 id="2-查看当前swap分区大小，然后进行扩展和缩小"><a href="#2-查看当前swap分区大小，然后进行扩展和缩小" class="headerlink" title="2.查看当前swap分区大小，然后进行扩展和缩小"></a>2.查看当前swap分区大小，然后进行扩展和缩小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1980        1475          80          10         424         242</span><br><span class="line">Swap:          2047           4        2043</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.扩展swap分区大小</span></span><br><span class="line">[root@demo ~]<span class="comment"># swapon /dev/sdb2</span></span><br><span class="line">[root@demo ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1980        1475          80          10         424         242</span><br><span class="line">Swap:          3047           4        2043</span><br><span class="line">[root@demo ~]<span class="comment"># swapon -a #代表激活所有的swap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.缩小swap分区大小</span></span><br><span class="line">[root@demo ~]<span class="comment"># swapoff /dev/sdb1</span></span><br><span class="line">[root@demo ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1980        1475          80          10         424         242</span><br><span class="line">Swap:          2047           4        2043</span><br><span class="line">[root@demo ~]<span class="comment"># swapoff -a #代表关闭所有的swap</span></span><br></pre></td></tr></table></figure><h3 id="3-检查当前swap分区有哪些设备"><a href="#3-检查当前swap分区有哪些设备" class="headerlink" title="3.检查当前swap分区有哪些设备"></a>3.检查当前swap分区有哪些设备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># swapon -s</span></span><br><span class="line">文件名         类型         大小     已用    权限</span><br><span class="line">/dev/dm-1   partition   2097148   4616    -2</span><br><span class="line">/dev/sdb1   partition   1048572   0       -2</span><br></pre></td></tr></table></figure><h3 id="4-如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘"><a href="#4-如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘" class="headerlink" title="4.如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘"></a>4.如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># dd if=/dev/zero of=/opt/swap_file bs=1M count=500</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 0600 /opt/swap_file</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkswap -f /opt/swap_file </span></span><br><span class="line">[root@demo ~]<span class="comment"># swapon /opt/swap_file</span></span><br><span class="line">[root@demo ~]<span class="comment"># free -m</span></span><br></pre></td></tr></table></figure><p><mark><strong>PS: 如果希望swap开机自动挂载，将swap信息追加至/etc/fstab即可。</strong></mark></p>]]></content>
    
    
    <summary type="html">Linux 磁盘管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 磁盘管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 软件管理</title>
    <link href="https://www.demon-w.com/2018/01/11/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/11/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-11T15:45:01.000Z</published>
    <updated>2020-08-24T16:31:25.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-RPM基本概述"><a href="#1-RPM基本概述" class="headerlink" title="1.RPM基本概述"></a>1.RPM基本概述</h2><h3 id="1-什么是rpm"><a href="#1-什么是rpm" class="headerlink" title="1.什么是rpm?"></a>1.什么是rpm?</h3><blockquote><p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p></blockquote><h3 id="2-rpm包名组成部分"><a href="#2-rpm包名组成部分" class="headerlink" title="2.rpm包名组成部分?"></a>2.rpm包名组成部分?</h3><blockquote><p><strong>RPM包命名以 “-“ 将软件分成了若干部分</strong></p><p><strong>示例： bash-4.2.46-28.el7.x86_64.rpm</strong></p><ul><li><strong>1.name，如：bash，是软件的名称</strong></li><li><strong>2.version，如：4.2.46，是软件的版本号，版本号格式通常为“主版本号.次版本号.修正号”。28，是发布版本号，表示这个rpm软件包是第几次编译生成的</strong></li><li><strong>3.特殊名称：</strong></li><li>（1）el*：表示发行商的版本，el7表示这个软件包是在rhel7.x/centos7.x下使用；</li><li>（2）devel：表示这个rpm包是软件的开发包</li><li>（3）noarch：说明这样的软件包可以在任何平台安装和运行，不需要特定的硬件平台</li></ul></blockquote><h3 id="3-如何获取rpm包"><a href="#3-如何获取rpm包" class="headerlink" title="3.如何获取rpm包"></a>3.如何获取rpm包</h3><blockquote><p>通过开源镜像站，去搜索自己需要的rpm包</p><ul><li>1.阿里云：<a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/</a></li><li>2.网易：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></li><li>3.清华大学：<a href="http://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a><br>还有很多的开源镜像站，此处就不一一列举了</li></ul></blockquote><h3 id="4-扩展-Linux中除了rpm安装软件，是否还有安装软件方式"><a href="#4-扩展-Linux中除了rpm安装软件，是否还有安装软件方式" class="headerlink" title="4.扩展: Linux中除了rpm安装软件，是否还有安装软件方式?"></a>4.扩展: Linux中除了rpm安装软件，是否还有安装软件方式?</h3><table><thead><tr><th align="left">分类</th><th align="left">安装</th><th align="left">版本</th></tr></thead><tbody><tr><td align="left">rpm包</td><td align="left">预先编译打包,安装简单</td><td align="left">软件版本偏低</td></tr><tr><td align="left">源码包</td><td align="left">手动编译打包,安装繁琐</td><td align="left">软件版本随意</td></tr><tr><td align="left">二进制包</td><td align="left">解压即可使用, 安装简单</td><td align="left">不能修改源码</td></tr></tbody></table><h2 id="2-RPM使用示例"><a href="#2-RPM使用示例" class="headerlink" title="2.RPM使用示例"></a>2.RPM使用示例</h2><h3 id="1-rpm包如何安装"><a href="#1-rpm包如何安装" class="headerlink" title="1.rpm包如何安装"></a>1.rpm包如何安装</h3><blockquote><p>以下列出了rpm命令进行安装软件的常用参数<br>|选项|描述|<br>|:—|:—|<br>|-i    |安装rpm|<br>|-v    |显示安装详细信息|<br>|-h    |显示安装rpm进度|<br>|–force|强制重新安装|<br>|–nodeps|忽略依赖关系|</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装软件包, 需要指定软件包绝对路径</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ivh /mnt/Packages/tree-1.6.0-10.el7.x86_64.rpm</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ivh /mnt/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在软件包所在目录下可以不指定绝对路径</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /mnt/Packages/</span></span><br><span class="line">[root@demo Packages]<span class="comment"># rpm -ivh zsh-5.0.2-28.el7.x86_64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果软件包存在, 强制再次安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ivh --force /mnt/Packages/tree-1.5.3-3.el6.x86_64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装samba服务需要依赖其他组件, 使用--nodeps可重新强制安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ivh --nodeps  /mnt/Packages/tree-1.6.0-10.el7.x86_64.rpm</span></span><br></pre></td></tr></table></figure><h3 id="2-如何查询已安装好的rpm包"><a href="#2-如何查询已安装好的rpm包" class="headerlink" title="2.如何查询已安装好的rpm包"></a>2.如何查询已安装好的rpm包</h3><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">rpm -q</td><td align="left">查看指定软件包是否安装</td></tr><tr><td align="left">rpm -qa</td><td align="left">查看系统中已安装的所有RPM软件包列表</td></tr><tr><td align="left">rpm -qi</td><td align="left">查看指定软件的详细信息</td></tr><tr><td align="left">rpm -ql</td><td align="left">查询指定软件包所安装的目录、文件列表</td></tr><tr><td align="left">rpm -qc</td><td align="left">查询指定软件包的配置文件</td></tr><tr><td align="left">rpm -qf</td><td align="left">查询文件或目录属于哪个RPM软件</td></tr><tr><td align="left">rpm -qip</td><td align="left">查询未安装的rpm包详细信息</td></tr><tr><td align="left">rpm -qlp</td><td align="left">查询未安装的软件包会产生哪些文件</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询vsftpd这个rpm包是否安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -q vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模糊查找系统已安装的rpm包</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qa |grep ftp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询vsftpd软件包的相关信息</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qi vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询rpm包所安装的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ql vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询rpm包相关的配置文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qc vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询配置文件或命令来自于哪个rpm包</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qf /etc/vsftpd/vsftpd.conf</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qf /usr/sbin/vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询未安装的软件包会产生哪些文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qlp /mnt/Packages/samba-3.6.23-41.el6.x86_64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询未安装的软件包会产生哪些文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qip /mnt/Packages/samba-3.6.23-41.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure><h3 id="3-RPM包升级"><a href="#3-RPM包升级" class="headerlink" title="3.RPM包升级"></a>3.RPM包升级</h3><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">rpm -U</td><td align="left">如果老版本不存在则全新安装，如果存在有新版即升级</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget  https://mirrors.aliyun.com/zabbix/zabbix/3.0/rhel/7/x86_64/zabbix-agent-3.0.9-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="comment"># wget  https://mirrors.aliyun.com/zabbix/zabbix/4.2/rhel/7/x86_64/zabbix-agent-4.2.0-1.el7.x86_64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.先安装低版本</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ivh zabbix-agent-3.0.9-1.el7.x86_64.rpm</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#2.尝试安装高版本(会出现错误)</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -ivh zabbix-agent-4.2.0-1.el7.x86_64.rpm</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#3.使用升级的方式,完美解决替换</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -Uvh zabbix-agent-4.2.0-1.el7.x86_64.rpm</span></span><br></pre></td></tr></table></figure><h3 id="4-RPM包卸载"><a href="#4-RPM包卸载" class="headerlink" title="4.RPM包卸载"></a>4.RPM包卸载</h3><div class="note danger">            <p>卸载包时需要先把依赖的包卸载掉，如果依赖的包是系统所必须的，那就不能卸载这个包，否则会造成系统崩溃。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先查询, 然后卸载 </span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qa |grep sh</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -e zsh</span></span><br></pre></td></tr></table></figure><h3 id="5-RPM包校验-扩展了解"><a href="#5-RPM包校验-扩展了解" class="headerlink" title="5.RPM包校验(扩展了解)"></a>5.RPM包校验(扩展了解)</h3><blockquote><p>软件相关的数据库存放于<code>/var/lib/rpm</code>目录<br>|参数|描述|<br>|:—|:—|<br>|S    |文件的容量大小是否被改变|<br>|M    |文件的类型或者文件的属性是否被修改|<br>|5    |MD5 这一种指纹加密的内容已经不同|<br>|L    |路径已经被改变|<br>|U    |文件的所属主已被修改|<br>|G    |文件的所属组已被修改|<br>|T    |文件的创建时间已被改变|</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># rpm -V vsftpd</span></span><br><span class="line">S.5....T.  c /etc/pam.d/vsftpd</span><br><span class="line">.......T.  c /etc/vsftpd/ftpusers</span><br><span class="line">S.5....T.  c /etc/vsftpd/vsftpd.conf</span><br><span class="line">.M.......    /var/ftp/pub</span><br></pre></td></tr></table></figure><h2 id="3-YUM基本介绍"><a href="#3-YUM基本介绍" class="headerlink" title="3.YUM基本介绍"></a>3.YUM基本介绍</h2><h3 id="1-什么是YUM"><a href="#1-什么是YUM" class="headerlink" title="1.什么是YUM"></a>1.什么是YUM</h3><blockquote><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p><p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记，</p></blockquote><h3 id="2-YUM源是什么"><a href="#2-YUM源是什么" class="headerlink" title="2.YUM源是什么"></a>2.YUM源是什么</h3><blockquote><p>要成功的使用 YUM 工具安装更新软件或系统，就需要有一个包含各种 rpm 软件包的repository（软件仓库），这个软件仓库我们习惯称为 yum 源。(可以是本地源、网络源)</p></blockquote><h3 id="3-YUM源配置示例"><a href="#3-YUM源配置示例" class="headerlink" title="3.YUM源配置示例"></a>3.YUM源配置示例</h3><h4 id="1-配置阿里yum源"><a href="#1-配置阿里yum源" class="headerlink" title="1.配置阿里yum源"></a>1.配置阿里yum源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 备份系统默认基础源</span><br><span class="line">[root@demo ~]<span class="comment"># mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认系统是国外源，需要替换为国内的源</span></span><br><span class="line">[root@demo ~]<span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo \ https://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line">1. 备份系统默认epel源(如有配置其他epel源)</span><br><span class="line">[root@demo ~]<span class="comment"># mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span></span><br><span class="line"><span class="comment">#扩展源，有很多软件在基本源中没有</span></span><br><span class="line">[root@demo ~]<span class="comment"># wget -O /etc/yum.repos.d/epel.repo \ http://mirrors.aliyun.com/repo/epel-7.repo</span></span><br></pre></td></tr></table></figure><h2 id="4-YUM实践示例"><a href="#4-YUM实践示例" class="headerlink" title="4.YUM实践示例"></a>4.YUM实践示例</h2><h3 id="1-使用yum查询软件包的方式"><a href="#1-使用yum查询软件包的方式" class="headerlink" title="1.使用yum查询软件包的方式"></a>1.使用yum查询软件包的方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># yum list</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum list|grep ftp</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum info ftp</span></span><br></pre></td></tr></table></figure><h3 id="2-使用yum安装软件包的方式"><a href="#2-使用yum安装软件包的方式" class="headerlink" title="2.使用yum安装软件包的方式"></a>2.使用yum安装软件包的方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># yum install tree</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install tree -y    #非交互</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装本地的rpm包, 如果有依赖关系, 会自动从软件仓库中下载所需依赖</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum localinstall /mnt/Packages/bind-9.9.4-50.el7.x86_64.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直接安装网络上的rpm包</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</span></span><br></pre></td></tr></table></figure><h3 id="3-使用yum重新安装软件包的方式"><a href="#3-使用yum重新安装软件包的方式" class="headerlink" title="3.使用yum重新安装软件包的方式"></a>3.使用yum重新安装软件包的方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.如果不小心删除vsftpd配置文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># rm -f /etc/vsftpd/vsftpd.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.可以对软件进行重新安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum reinstall vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.检查软件的配置文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># rpm -qc vsftpd</span></span><br><span class="line">/etc/logrotate.d/vsftpd</span><br><span class="line">/etc/pam.d/vsftpd</span><br><span class="line">/etc/vsftpd/ftpusers</span><br><span class="line">/etc/vsftpd/user_list</span><br><span class="line">/etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure><h3 id="4-使用yum更新软件包"><a href="#4-使用yum更新软件包" class="headerlink" title="4.使用yum更新软件包"></a>4.使用yum更新软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对比Linux已安装的软件和yum仓库中的软件, 有哪些需要升级</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum check-update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新acl软件</span></span><br><span class="line">[root@demo ~]<span class="comment">#  yum update acl -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如下的执行很危险，这代表更新整个系统所有的软件，包括内核</span></span><br><span class="line">[root@demo ~]<span class="comment">#  yum update -y</span></span><br></pre></td></tr></table></figure><h3 id="5-使用yum删除软件包"><a href="#5-使用yum删除软件包" class="headerlink" title="5.使用yum删除软件包"></a>5.使用yum删除软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># yum install samba -y</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum erase samba -y</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum remove samba -y</span></span><br></pre></td></tr></table></figure><h3 id="6-与yum仓库相关指令-扩展了解"><a href="#6-与yum仓库相关指令-扩展了解" class="headerlink" title="6.与yum仓库相关指令(扩展了解)"></a>6.与yum仓库相关指令(扩展了解)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出yum源可用的软件仓库</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum repolist</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出全部yum源可用和禁用的仓库</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum repolist all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找某个命令或文件属于那个软件包(生产常用)</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum provides /etc/my.cnf</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum provides cd</span></span><br></pre></td></tr></table></figure><h3 id="7-与yum缓存相关指令-扩展了解"><a href="#7-与yum缓存相关指令-扩展了解" class="headerlink" title="7.与yum缓存相关指令(扩展了解)"></a>7.与yum缓存相关指令(扩展了解)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.缓存rpm包方式一、修改yum全局配置文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># vim /etc/yum.conf</span></span><br><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum/<span class="variable">$basearch</span>/<span class="variable">$releasever</span></span><br><span class="line">keepcache=1     <span class="comment">#启动缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.缓存rpm包方式二，只下载不安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install -y yum-plugin-downloadonly #插件</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install httpd -y --downloadonly --downloaddir=/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.清除所有yum缓存的软件包以及元数据</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.只清除缓存的软件包</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum clean packages</span></span><br></pre></td></tr></table></figure><h3 id="8-组包相关指令，-扩展了解"><a href="#8-组包相关指令，-扩展了解" class="headerlink" title="8.组包相关指令，(扩展了解)"></a>8.组包相关指令，(扩展了解)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># yum groups list</span></span><br><span class="line"><span class="comment">#安装一整个组的软件</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum groups install Development tools \</span></span><br><span class="line">Compatibility libraries \</span><br><span class="line">Base Debugging Tools</span><br><span class="line"></span><br><span class="line"><span class="comment">#yum删除包组</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum groups remove  -y Base</span></span><br></pre></td></tr></table></figure><h3 id="9-历史记录指令-扩展了解"><a href="#9-历史记录指令-扩展了解" class="headerlink" title="9.历史记录指令,(扩展了解)"></a>9.历史记录指令,(扩展了解)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看历史执行yum命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum history</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查询历史执行yum命令ID详细信息</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum history info N</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.撤销历史执行过的yum命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum history undo N</span></span><br></pre></td></tr></table></figure><h3 id="10-YUM软件包额外扩展"><a href="#10-YUM软件包额外扩展" class="headerlink" title="10.YUM软件包额外扩展"></a>10.YUM软件包额外扩展</h3><h4 id="1-YUM配置文件"><a href="#1-YUM配置文件" class="headerlink" title="1.YUM配置文件"></a>1.YUM配置文件</h4><blockquote><p>yum的配置一般有两种方式： 一种是直接配置/etc目录下的yum.conf文件， 另外一种是在/etc/yum.repos.d目录下增加.repo文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># vim /etc/yum.conf</span></span><br><span class="line">cachedir=/var/cache/yum/<span class="variable">$basearch</span>/<span class="variable">$releasever</span>   <span class="comment">#缓存目录</span></span><br><span class="line">keepcache=0     <span class="comment">#缓存软件包，1启动 0 关闭</span></span><br><span class="line">debuglevel=2    <span class="comment">#调试级别</span></span><br><span class="line">logfile=/var/<span class="built_in">log</span>/yum.log    <span class="comment">#日志记录位置</span></span><br><span class="line">exactarch=1     <span class="comment">#检查平台是否兼容</span></span><br><span class="line">obsoletes=1     <span class="comment">#检查包是否废弃</span></span><br><span class="line">gpgcheck=1      <span class="comment">#检查来源是否合法,需要有制作者的公钥信息</span></span><br><span class="line">plugins=1</span><br><span class="line">installonly_limit=5</span><br><span class="line">bugtracker_url</span><br><span class="line"><span class="comment"># metadata_expire=90m   #每小时手动检查元数据</span></span><br><span class="line"><span class="comment"># in /etc/yum.repos.d   #包含repos.d目录中的.repo文件</span></span><br></pre></td></tr></table></figure><h4 id="2-YUM签名检查"><a href="#2-YUM签名检查" class="headerlink" title="2.YUM签名检查"></a>2.YUM签名检查</h4><blockquote><p>redhat在构建rpm包时，使用私钥<code>private key</code>对 <code>rpm</code>包进行签名，客户端在使用<code>rpm</code>为验证其合法性，可以使用<code>redhat</code>提供的公钥<code>public key</code>进行签名检查。</p></blockquote><blockquote><ul><li>方式1: 指定公钥的位置</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># vim /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base </span><br><span class="line">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><blockquote><ul><li>方式2: 提前导入公钥</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span></span><br><span class="line">[root@demo ~]<span class="comment"># vim /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base </span><br><span class="line">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure><blockquote><ul><li>方式3: 不进行签名验证</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不验证软件包的合法性</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install httpd --nogpgcheck</span></span><br></pre></td></tr></table></figure><h2 id="5-搭建本地仓库"><a href="#5-搭建本地仓库" class="headerlink" title="5.搭建本地仓库"></a>5.搭建本地仓库</h2><h3 id="1-有时在生产环境，Linux不允许连接外网，那我们就可以利用linux系统光盘制作一个yum源。具体步骤如下："><a href="#1-有时在生产环境，Linux不允许连接外网，那我们就可以利用linux系统光盘制作一个yum源。具体步骤如下：" class="headerlink" title="1.有时在生产环境，Linux不允许连接外网，那我们就可以利用linux系统光盘制作一个yum源。具体步骤如下："></a>1.有时在生产环境，Linux不允许连接外网，那我们就可以利用linux系统光盘制作一个yum源。具体步骤如下：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.挂载镜像</span></span><br><span class="line">[root@demo ~]<span class="comment"># mount /dev/cdrom /mnt   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.备份原有仓库</span></span><br><span class="line">[root@demo ~]<span class="comment"># gzip /etc/yum.repos.d/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.使用yum-config-manager命令添加本地仓库</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum-config-manager --add-repo=&quot;file:///mnt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.或者使用手动添加repo文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># vim /etc/yum.repos.d/cdrom.repo  </span></span><br><span class="line">[cdrom]      </span><br><span class="line">name=This is <span class="built_in">local</span> cdrom</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[]          <span class="comment">#仓库名称</span></span><br><span class="line">name        3仓库描述信息</span><br><span class="line">baseurl     <span class="comment">#YUM源url地址 ,可以是file:// ftp:// http://</span></span><br><span class="line">enabled     <span class="comment">#是否使用该YUM源(0代表禁用, 1代表激活)</span></span><br><span class="line">gpgcheck    <span class="comment">#是否验证软件签名(0代表禁用, 1代表激活)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.生成缓存</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum makecache</span></span><br></pre></td></tr></table></figure><h3 id="2-很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗-当然可以，但如果软件出现了更新怎么办"><a href="#2-很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗-当然可以，但如果软件出现了更新怎么办" class="headerlink" title="2.很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗? 当然可以，但如果软件出现了更新怎么办?"></a>2.很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗? 当然可以，但如果软件出现了更新怎么办?</h3><blockquote><p>我们可以用这样的方案来解决这个问题：</p><ul><li>1.本地光盘提供基础软件包: Base</li><li>2.yum缓存提供常用软件包: nginx, zabbix, docker</li></ul></blockquote><h3 id="3-案例演示"><a href="#3-案例演示" class="headerlink" title="3.案例演示"></a>3.案例演示</h3><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h4><table><thead><tr><th align="left">系统</th><th align="left">IP</th><th align="left">角色</th></tr></thead><tbody><tr><td align="left">centos7</td><td align="left">10.0.0.99</td><td align="left">yum仓库服务端</td></tr><tr><td align="left">centos7</td><td align="left">10.0.0.98</td><td align="left">yum仓库客户端</td></tr></tbody></table><h4 id="2-服务端进行yum仓库的搭建准备工作"><a href="#2-服务端进行yum仓库的搭建准备工作" class="headerlink" title="2.服务端进行yum仓库的搭建准备工作"></a>2.服务端进行yum仓库的搭建准备工作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.关闭防火墙、与selinux</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># setenforce 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.安装ftp服务,启动并加入开机启动</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># yum -y install vsftpd </span></span><br><span class="line">[root@yum_server ~]<span class="comment"># systemctl start vsftpd </span></span><br><span class="line">[root@yum_server ~]<span class="comment"># systemctl enable vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.开启yum缓存功能</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># vim /etc/yum.conf</span></span><br><span class="line">[main] cachedir=/var/cache/yum/<span class="variable">$basearch</span>/<span class="variable">$releasever</span> </span><br><span class="line">keepcache=1</span><br><span class="line">[root@yum_server ~]<span class="comment"># yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.提供基础base软件包</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># mkdir /var/ftp/centos7</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># cp -rp  /mnt/Packages/*.rpm /var/ftp/centos7/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.提供第三方源</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># mkdir /var/ftp/ops</span></span><br><span class="line">[root@yum_server ~]<span class="comment"># yum -y install nginx docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.复制已缓存的 Nginx docker 及依赖包 到自定义 YUM 仓库目录中</span></span><br><span class="line">[root@yum_server_69_112 ~]<span class="comment"># find /var/cache/yum/x86_64/7/ \</span></span><br><span class="line">-iname <span class="string">&quot;*.rpm&quot;</span> -<span class="built_in">exec</span> cp -rf &#123;&#125; /var/ftp/ops \;</span><br><span class="line"></span><br><span class="line"><span class="comment">#7.安装createrepo并创建 reopdata仓库</span></span><br><span class="line">[root@yum_server_ ~]<span class="comment"># yum -y install createrepo</span></span><br><span class="line">[root@yum_server_ ~]<span class="comment"># createrepo /var/ftp/ops</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意: 如果此仓库每次新增软件则需要重新生成一次</span></span><br></pre></td></tr></table></figure><h4 id="3-客户端配置yum源指向服务端"><a href="#3-客户端配置yum源指向服务端" class="headerlink" title="3.客户端配置yum源指向服务端"></a>3.客户端配置yum源指向服务端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.客户端配置并使用 base 基础源</span></span><br><span class="line">[root@yum_client ~]<span class="comment"># gzip /etc/yum.repos.d/*</span></span><br><span class="line">[root@yum_client ~]<span class="comment"># vim /etc/yum.repos.d/centos7.repo </span></span><br><span class="line">[centos7]</span><br><span class="line">name=centos7_base</span><br><span class="line">baseurl=ftp://10.0.0.99/centos7</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.客户端配置并使用 ops 源</span></span><br><span class="line">[root@yum_client ~]<span class="comment"># vim /etc/yum.repos.d/ops.repo </span></span><br><span class="line">[ops]</span><br><span class="line">name=<span class="built_in">local</span> ftpserver</span><br><span class="line">baseurl=ftp://10.0.0.99/ops</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure><h2 id="6-源码包管理实践"><a href="#6-源码包管理实践" class="headerlink" title="6.源码包管理实践"></a>6.源码包管理实践</h2><h3 id="1-源码包是什么"><a href="#1-源码包是什么" class="headerlink" title="1.源码包是什么"></a>1.源码包是什么</h3><blockquote><p>源码包指的是开发编写好的程序源代码，但并没有将其编译为一个能正常使用的工具。</p></blockquote><h3 id="2-为什么要学习源码包"><a href="#2-为什么要学习源码包" class="headerlink" title="2.为什么要学习源码包"></a>2.为什么要学习源码包</h3><blockquote><p>1、部分软件官网仅提供源码包，需要自行编译并安装。<br>2、部分软件在新版本有一些特性还没来得及制作成rpm包时，可以自行编译软件使用其新特性。</p></blockquote><h3 id="3-源码包的优缺点"><a href="#3-源码包的优缺点" class="headerlink" title="3.源码包的优缺点"></a>3.源码包的优缺点</h3><blockquote><ol><li>可以自行修改源代码</li><li>可以定制需要的相关功能</li><li>新版软件优先更新源码</li><li>缺点是: 1) 相对yum安装软件会复杂很多。2) 标准化实施困难，自动化就无法落地。</li></ol></blockquote><h3 id="4-源码包如何获取"><a href="#4-源码包如何获取" class="headerlink" title="4.源码包如何获取"></a>4.源码包如何获取</h3><blockquote><p>常见的软件包都可以在官网获取源码包，比如 apache、nginx、mysql等等</p></blockquote><h3 id="5-将源码包编译为二进制可执行文件步骤如下，简称安装三步曲"><a href="#5-将源码包编译为二进制可执行文件步骤如下，简称安装三步曲" class="headerlink" title="5.将源码包编译为二进制可执行文件步骤如下，简称安装三步曲"></a>5.将源码包编译为二进制可执行文件步骤如下，简称安装三步曲</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/11/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/1.jpg" alt="1"></p><div class="note danger">            <p>此方法不是百分百通用于所有源码包，建议拿到源码包解压后，进入到目录找相关的README帮助文档</p>          </div><h3 id="6-源码编译示例"><a href="#6-源码编译示例" class="headerlink" title="6.源码编译示例"></a>6.源码编译示例</h3><blockquote><p>下面通过编译Nginx来深入了解下源码包编译的过程。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.基础环境准备</span></span><br><span class="line">[root@node1 ~]<span class="comment"># yum install -y gcc make wget </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.下载源码包</span></span><br><span class="line">[root@node1 ~]<span class="comment"># wget http://nginx.org/download/nginx-1.15.12.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.解压源码包, 并进入相应目录</span></span><br><span class="line">[root@node1 ~]<span class="comment"># tar xf nginx-1.15.12.tar.gz</span></span><br><span class="line">[root@node1 ~]<span class="comment"># cd nginx-1.15.12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.配置相关的选项，并生成Makefile</span></span><br><span class="line">[root@node1 nginx-1.15.12]<span class="comment"># ./configure --prefix=/soft/nginx-1.12.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.将Makefile文件编译可执行二进制程序</span></span><br><span class="line">[root@node1 nginx-1.15.12]<span class="comment"># make</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.将二进制文件拷贝至对应的目录中</span></span><br><span class="line">[root@node1 nginx-1.15.12]<span class="comment"># make install</span></span><br></pre></td></tr></table></figure><blockquote><p>源码编译报错信息处理</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">checking <span class="keyword">for</span> C compiler ... not found ./configure: error: C compiler cc is not found </span><br><span class="line"><span class="comment"># yum -y install gcc gcc-c++ make</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either <span class="built_in">disable</span> the module by using --without-http_rewrite_module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the <span class="built_in">source</span> with nginx by using --with-pcre=&lt;path&gt; option.</span><br><span class="line"><span class="comment"># yum install -y pcre-devel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either <span class="built_in">disable</span> the module by using --without-</span><br><span class="line">http_gzip_module option, or install the zlib library into the</span><br><span class="line">system, or build the zlib library statically from the <span class="built_in">source</span> with</span><br><span class="line">nginx by using --with-zlib=&lt;path&gt; option. </span><br><span class="line"><span class="comment"># yum -y install zlib-devel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure: error: SSL modules require the OpenSSL library.</span><br><span class="line">You can either <span class="keyword">do</span> not <span class="built_in">enable</span> the modules, or install the OpenSSL </span><br><span class="line">library into the system, or build the OpenSSL library statically</span><br><span class="line">from the <span class="built_in">source</span> with nginx by using --with-openssl=&lt;path&gt; option.</span><br><span class="line"><span class="comment"># yum -y install openssl-devel</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 软件管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 软件管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 压缩打包</title>
    <link href="https://www.demon-w.com/2018/01/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/"/>
    <id>https://www.demon-w.com/2018/01/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/</id>
    <published>2018-01-09T17:45:01.000Z</published>
    <updated>2020-08-24T07:35:33.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-文件打包与压缩"><a href="#1-文件打包与压缩" class="headerlink" title="1.文件打包与压缩"></a>1.文件打包与压缩</h2><h3 id="1-什么是文件压缩"><a href="#1-什么是文件压缩" class="headerlink" title="1.什么是文件压缩?"></a>1.什么是文件压缩?</h3><blockquote><p>将多个文件或目录合并成为一个特殊的文件。</p></blockquote><h3 id="2-为什么要对文件进行压缩？"><a href="#2-为什么要对文件进行压缩？" class="headerlink" title="2.为什么要对文件进行压缩？"></a>2.为什么要对文件进行压缩？</h3><blockquote><p>当我们在传输大量的文件时，通常都会选择将该文件进行压缩，然后在进行传输。<br>首先：压缩后的文件会比压缩前的文件小。一个28G的文件夹压缩后能达到6G<br>其次：多个文件传输很慢，但单个文件传输会很快，同时还能节省网络的消耗。</p></blockquote><h3 id="2-Windows的压缩包与Linux的压缩包能否通用？"><a href="#2-Windows的压缩包与Linux的压缩包能否通用？" class="headerlink" title="2.Windows的压缩包与Linux的压缩包能否通用？"></a>2.Windows的压缩包与Linux的压缩包能否通用？</h3><blockquote><p>在windows系统下，我们接触最多的压缩格式是 rar 或 zip ，但在Linux上使用最多的压缩格式是 zip 和 tar.gz 。当然不用担心，Linux上的压缩格式放在windows系统下都是可以正常打开的。</p></blockquote><div class="note warning">            <p>Linux不支持 Windows下的 RAR 格式的压缩文件。Windows和Linux互通通常选择 zip</p>          </div><h3 id="3-Linux下压缩包有哪些常见的类型"><a href="#3-Linux下压缩包有哪些常见的类型" class="headerlink" title="3.Linux下压缩包有哪些常见的类型"></a>3.Linux下压缩包有哪些常见的类型</h3><table><thead><tr><th align="left">格式</th><th align="left">压缩工具</th></tr></thead><tbody><tr><td align="left">.zip</td><td align="left">zip压缩工具</td></tr><tr><td align="left">.gz</td><td align="left">gzip压缩工具，只能压缩文件，会删除原文件(通常配合tar使用)</td></tr><tr><td align="left">.bz2</td><td align="left">bzip2压缩工具，只能压缩文件，会删除原文件(通常配合tar使用)</td></tr><tr><td align="left">.tar.gz</td><td align="left">先使用tar命令归档打包，然后使用gzip压缩</td></tr><tr><td align="left">.tar.bz2</td><td align="left">先使用tar命令归档打包，然后使用bzip压缩</td></tr></tbody></table><h2 id="2-gzip-打包与压缩"><a href="#2-gzip-打包与压缩" class="headerlink" title="2.gzip 打包与压缩"></a>2.gzip 打包与压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># yum install gzip -y</span></span><br><span class="line">[root@demo ~]<span class="comment"># gzip file       #对文件进行压缩</span></span><br><span class="line">[root@demo ~]<span class="comment"># zcat file.gz    #查看gz压缩后的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># gzip -d file.gz #解压gzip的压缩包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用场景:当需要让某个文件不生效时</span></span><br><span class="line">[root@demo ~]<span class="comment"># gzip CentOS-Vault.repo --&gt; CentOS-Vault.repo.gz</span></span><br><span class="line">[root@demo ~]<span class="comment"># zcat CentOS-Vault.repo.gz   --&gt; 查看不想解压的压缩包文件内容</span></span><br></pre></td></tr></table></figure><h2 id="3-zip-打包与压缩"><a href="#3-zip-打包与压缩" class="headerlink" title="3.zip 打包与压缩"></a>3.zip 打包与压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下没有zip和unzip工具，需要进行安装</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install zip unzip -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.压缩文件为zip包</span></span><br><span class="line">[root@demo ~]<span class="comment"># zip  filename.zip  filename </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.压缩目录为zip包  </span></span><br><span class="line">[root@demo ~]<span class="comment"># zip -r  dir.zip dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查看zip压缩包是否是完整的         </span></span><br><span class="line">[root@demo ~]<span class="comment"># zip -T  filename.zip</span></span><br><span class="line"><span class="built_in">test</span> of filename.zip OK</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.不解压压缩查看压缩包中的内容</span></span><br><span class="line">[root@demo ~]<span class="comment"># unzip -l  filename.zip</span></span><br><span class="line">[root@demo ~]<span class="comment"># unzip -t  filename.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解压zip文件包, 默认解压至当前目录          </span></span><br><span class="line">[root@demo ~]<span class="comment"># unzip  filename.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.解压zip内容至/opt目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># unzip filename.zip  -d /opt/</span></span><br></pre></td></tr></table></figure><h2 id="4-tar-打包与压缩"><a href="#4-tar-打包与压缩" class="headerlink" title="4.tar 打包与压缩"></a>4.tar 打包与压缩</h2><blockquote><p><strong>tar是linux下最常用的压缩与解压缩, 支持文件和目录的压缩归档</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：tar [-zjxcvfpP] filename </span></span><br><span class="line">c   <span class="comment">#创建新的归档文件</span></span><br><span class="line">x   <span class="comment">#对归档文件解包</span></span><br><span class="line">t   <span class="comment">#列出归档文件里的文件列表</span></span><br><span class="line">v   <span class="comment">#输出命令的归档或解包的过程</span></span><br><span class="line">f   <span class="comment">#指定包文件名，多参数f写最后</span></span><br><span class="line"></span><br><span class="line">z   <span class="comment">#使用gzip压缩归档后的文件(.tar.gz)</span></span><br><span class="line">j   <span class="comment">#使用bzip2压缩归档后的文件(.tar.bz2)</span></span><br><span class="line">J   <span class="comment">#使用xz压缩归档后的文件(tar.xz)</span></span><br><span class="line">C   <span class="comment">#指定解压目录位置</span></span><br><span class="line">X   <span class="comment">#排除多个文件(写入需要排除的文件名称)</span></span><br><span class="line">h   <span class="comment">#打包软链接</span></span><br><span class="line">--hard-dereference  <span class="comment">#打包硬链接</span></span><br><span class="line">--exclude   <span class="comment">#在打包的时候写入需要排除文件或目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#常用打包与压缩组合</span></span><br><span class="line">czf     <span class="comment">#打包tar.gz格式</span></span><br><span class="line">cjf     <span class="comment">#打包tar.bz格式</span></span><br><span class="line">cJf     <span class="comment">#打包tar.xz格式</span></span><br><span class="line"></span><br><span class="line">zxf     <span class="comment">#解压tar.gz格式</span></span><br><span class="line">jxf     <span class="comment">#解压tar.bz格式</span></span><br><span class="line">xf      <span class="comment">#自动选择解压模式</span></span><br><span class="line">tf      <span class="comment">#查看压缩包内容</span></span><br></pre></td></tr></table></figure><h3 id="1-将文件或目录进行打包压缩"><a href="#1-将文件或目录进行打包压缩" class="headerlink" title="1.将文件或目录进行打包压缩"></a>1.将文件或目录进行打包压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.以gzip归档方式打包并压缩</span></span><br><span class="line">tar czf  test.tar.gz  <span class="built_in">test</span>/ test2/</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.以bz2方式压缩 </span></span><br><span class="line">tar cjf  test.tar.bz2 dir.txt dir/</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.打包链接文件,打包链接文件的真实文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /</span></span><br><span class="line">[root@demo /]<span class="comment"># tar czfh local.tar.gz  etc/rc.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.打包/tmp下所有文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /</span></span><br><span class="line">[root@demo /]<span class="comment"># find tmp/ -type f | xargs tar czf tmp.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.打包/tmp下所有文件</span></span><br><span class="line">[root@demo /]<span class="comment"># tar czf tmp.tar.gz $(find /tmp/ -type f)</span></span><br></pre></td></tr></table></figure><h3 id="2-排除文件-并打包压缩"><a href="#2-排除文件-并打包压缩" class="headerlink" title="2.排除文件, 并打包压缩"></a>2.排除文件, 并打包压缩</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.排除单个文件</span></span><br><span class="line">[root@demo /]<span class="comment">#  tar czf etc.tar.gz --exclude=etc/services etc/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.排除多个文件</span></span><br><span class="line">[root@demo /]<span class="comment"># tar czf etc.tar.gz --exclude=etc/services --exclude=etc/rc.local etc/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.将需要排除的文件写入文件中</span></span><br><span class="line">[root@demo /]<span class="comment"># cat paichu.list</span></span><br><span class="line">etc/services</span><br><span class="line">etc/rc.local</span><br><span class="line">etc/rc.d/rc.local</span><br><span class="line"><span class="comment">#指定需要排除的文件列表, 最后进行打包压缩</span></span><br><span class="line">[root@demo /]<span class="comment"># tar czfX etc.tar.gz paichu.list etc/</span></span><br></pre></td></tr></table></figure><h3 id="3-查看压缩文件"><a href="#3-查看压缩文件" class="headerlink" title="3.查看压缩文件"></a>3.查看压缩文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看压缩包内容和解压</span></span><br><span class="line">[root@demo /]<span class="comment"># tar tf  test.tar.gz</span></span><br></pre></td></tr></table></figure><h3 id="4-解压缩文件"><a href="#4-解压缩文件" class="headerlink" title="4.解压缩文件"></a>4.解压缩文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.解压至当前目录</span></span><br><span class="line">[root@demo /]<span class="comment"># tar xf  test.tar.gz      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.将解压内容存储至指定的/tmp目录</span></span><br><span class="line">[root@student ~]<span class="comment"># tar xf /etc/local.tar.gz  -C /tmp</span></span><br></pre></td></tr></table></figure><h3 id="tar命令练习"><a href="#tar命令练习" class="headerlink" title="tar命令练习"></a>tar命令练习</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.环境准备</span></span><br><span class="line">[root@demo ~]<span class="comment"># yum install mariadb-server</span></span><br><span class="line">[root@demo ~]<span class="comment"># systemctl start mariadb</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir /backup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#案例1.mysql备份及恢复</span></span><br><span class="line">[root@demo ~]<span class="comment"># tar cJf /backup/mysql.tar.xz /var/lib/mysql</span></span><br><span class="line">[root@demo ~]<span class="comment"># tar xf /backup/mysql.tar.xz -C /</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#案例2 mysql备份及恢复</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /var/lib/mysql</span></span><br><span class="line">[root@demo mysql]<span class="comment"># tar cJf /backup/mysql.tar.xz *</span></span><br><span class="line">[root@demo mysql]<span class="comment"># tar tf /backup/mysql.tar.xz</span></span><br><span class="line">[root@demo mysql]<span class="comment"># tar xf /backup/mysql.tar.xz -C /var/lib/mysql</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 压缩打包</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 压缩打包" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件查找</title>
    <link href="https://www.demon-w.com/2018/01/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.demon-w.com/2018/01/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</id>
    <published>2018-01-08T16:45:01.000Z</published>
    <updated>2020-08-24T07:07:03.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-find-查找概述"><a href="#1-find-查找概述" class="headerlink" title="1.find 查找概述"></a>1.find 查找概述</h2><blockquote><p>有时候我们可能会忘了某个文件所在的位置，此时就需要通过find来查找。<br>find命令可以根据不同的条件来进行查找文件，例如：<code>文件名称</code>、<code>文件大小</code>、<code>文件修改时间</code>、<code>属主属组</code>、<code>权限</code>、等等方式，同时find命令是Linux下必须掌握的。</p></blockquote><h3 id="find-命令的基本语法如下"><a href="#find-命令的基本语法如下" class="headerlink" title="find 命令的基本语法如下"></a>find 命令的基本语法如下</h3><table><thead><tr><th align="left">命令</th><th align="left">路径</th><th align="left">选项</th><th align="left">表达式</th><th align="left">动作</th></tr></thead><tbody><tr><td align="left">find</td><td align="left">[path…]</td><td align="left">[options]</td><td align="left">[expression]</td><td align="left">[action]</td></tr></tbody></table><h2 id="2-find查找示例"><a href="#2-find查找示例" class="headerlink" title="2.find查找示例"></a>2.find查找示例</h2><h3 id="1-find常用选项"><a href="#1-find常用选项" class="headerlink" title="1.find常用选项"></a>1.find常用选项</h3><h4 id="1-find名称查找"><a href="#1-find名称查找" class="headerlink" title="1.find名称查找"></a>1.find名称查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.创建文件</span></span><br><span class="line">touch /etc/sysconfig/network-scripts/&#123;ifcfg-eth1,IFCFG-ETH1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查找/etc目录下包含ifcfg-eth0名称的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg-eth1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.-i 忽略大小写</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -iname &quot;ifcfg-eth1&quot;</span></span><br><span class="line"><span class="comment">#查找/etc目录下包含ifcfg-eth名称所有文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc/ -name &quot;ifcfg-eth*&quot;</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -iname &quot;ifcfg-eth*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-find大小查找"><a href="#2-find大小查找" class="headerlink" title="2.find大小查找"></a>2.find大小查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查找大于5M的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -size +5M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查找等于5M的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -size 5M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查找小于5M的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -size -5M </span></span><br></pre></td></tr></table></figure><h4 id="3-find类型查找"><a href="#3-find类型查找" class="headerlink" title="3.find类型查找"></a>3.find类型查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f 文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type f</span></span><br><span class="line"><span class="comment"># d 目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type d</span></span><br><span class="line"><span class="comment"># l 链接</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type l</span></span><br><span class="line"><span class="comment"># b 块设备</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type b</span></span><br><span class="line"><span class="comment"># c 字符设备</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type c</span></span><br><span class="line"><span class="comment"># s 套接字</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type s</span></span><br><span class="line"><span class="comment"># p 管道文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /dev -type p</span></span><br></pre></td></tr></table></figure><h4 id="4-find时间查找"><a href="#4-find时间查找" class="headerlink" title="4.find时间查找"></a>4.find时间查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.创建测试文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># for i in &#123;01..28&#125;;do date -s  201904$i &amp;&amp; touch file-$i;done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查找7天以前的文件(不会打印当天的文件)</span></span><br><span class="line">[root@demo ~]<span class="comment"># find ./ -iname &quot;file-*&quot; -mtime +7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查找最近7天的文件，不建议使用(会打印当天的文件)</span></span><br><span class="line">[root@demo ~]<span class="comment"># find ./ -iname &quot;file-*&quot; -mtime -7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.查找第7天文件(不会打印当天的文件)</span></span><br><span class="line">[root@demo ~]<span class="comment"># find ./ -iname &quot;file-*&quot; -mtime 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.本地文件保留最近7天的备份文件, 备份服务器保留3个月的备份文件(实际使用方案)</span></span><br><span class="line">find /backup/ -iname <span class="string">&quot;*.bak&quot;</span> -mtime +7 -delete</span><br><span class="line">find /backup/ -iname <span class="string">&quot;*.bak&quot;</span> -mtime +90 -delete</span><br></pre></td></tr></table></figure><h4 id="5-find用户查找"><a href="#5-find用户查找" class="headerlink" title="5.find用户查找"></a>5.find用户查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找属主是jack</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -user jack</span></span><br><span class="line"><span class="comment">#查找属组是admin</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -group admin</span></span><br><span class="line"><span class="comment">#查找属主是jack, 属组是admin</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -user jack -group admin</span></span><br><span class="line"><span class="comment">#查找属主是jack, 并且属组是admin</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -user jack -a -group admin</span></span><br><span class="line"><span class="comment">#查找属主是jack, 或者属组是admin</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -user jack -o -group admin</span></span><br><span class="line"><span class="comment">#查找没有属主</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -nouser</span></span><br><span class="line"><span class="comment">#查找没有属组</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -nogroup</span></span><br><span class="line"><span class="comment">#查找没有属主或属组</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /home -nouser -o -nogroup</span></span><br></pre></td></tr></table></figure><h4 id="6-find权限查找"><a href="#6-find权限查找" class="headerlink" title="6.find权限查找"></a>6.find权限查找</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#精切匹配644权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -perm 644 -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含444权限即可</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -perm -444  -ls</span></span><br><span class="line"><span class="comment">#查找全局可写(每位权限必须包含w)</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -perm -222 -ls</span></span><br><span class="line"><span class="comment">#包含set uid</span></span><br><span class="line">[root@demo ~]<span class="comment"># find  /usr/sbin -perm -4000 -ls</span></span><br><span class="line"><span class="comment">#包含set gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># find  /usr/sbin -perm -2000 -ls</span></span><br><span class="line"><span class="comment">#包含sticky</span></span><br><span class="line">[root@demo ~]<span class="comment"># find  /usr/sbin -perm -1000 -ls</span></span><br></pre></td></tr></table></figure><h3 id="2-find动作处理，比如查找到一个文件后，需要对文件进行如何处理-find的默认动作是-print"><a href="#2-find动作处理，比如查找到一个文件后，需要对文件进行如何处理-find的默认动作是-print" class="headerlink" title="2.find动作处理，比如查找到一个文件后，需要对文件进行如何处理, find的默认动作是 -print"></a>2.find动作处理，比如查找到一个文件后，需要对文件进行如何处理, find的默认动作是 -print</h3><table><thead><tr><th align="left">动作</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-print</td><td align="left">打印查找到的内容(默认)</td></tr><tr><td align="left">-ls</td><td align="left">以长格式显示的方式打印查找到的内容</td></tr><tr><td align="left">-delete</td><td align="left">删除查找到的文件(仅能删除空目录)</td></tr><tr><td align="left">-ok</td><td align="left">后面跟自定义 shell 命令(会提示是否操作)</td></tr><tr><td align="left">-exec</td><td align="left">后面跟自定义 shell 命令(标准写法 -exec ;)</td></tr></tbody></table><h4 id="1-find查找后的动作命令示例"><a href="#1-find查找后的动作命令示例" class="headerlink" title="1.find查找后的动作命令示例"></a>1.find查找后的动作命令示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用-print打印查找到的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot;</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot; -print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用-ls打印查找到的文件，以长格式显示</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot; -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.使用-delete删除文件，但仅能删除空目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot; -delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用-ok实现文件拷贝，但会提示是否拷贝</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot; -ok cp -rvf &#123;&#125; /tmp \;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.使用-exec实现文件拷贝和文件删除。</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot; -exec cp -rvf &#123;&#125; /tmp \;</span></span><br><span class="line">[root@demo ~]<span class="comment"># find /etc -name &quot;ifcfg*&quot; -exec rm -f &#123;&#125; \;</span></span><br></pre></td></tr></table></figure><h4 id="2-使用find命令结合xargs"><a href="#2-使用find命令结合xargs" class="headerlink" title="2.使用find命令结合xargs"></a>2.使用find命令结合xargs</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#xargs将前者命令查找到的文件作为一个整体传递后者命令的输入</span></span><br><span class="line">[root@demo ~]<span class="comment"># touch file.txt</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -name &quot;file.txt&quot; |xargs rm -f</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -name &quot;file.txt&quot; |xargs -I &#123;&#125; cp -rvf &#123;&#125; /var/tmp</span></span><br></pre></td></tr></table></figure><h4 id="3-find逻辑运算符"><a href="#3-find逻辑运算符" class="headerlink" title="3.find逻辑运算符"></a>3.find逻辑运算符</h4><table><thead><tr><th align="left">符号</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">与</td></tr><tr><td align="left">-o</td><td align="left">或</td></tr><tr><td align="left">-not|!</td><td align="left">非</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查找当前目录下，属主不是hdfs的所有文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -not -user hdfs </span></span><br><span class="line">[root@demo ~]<span class="comment"># find . ! -user hdfs</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#2.查找当前目录下，属主属于hdfs，且大小大于300字节的文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -type f -a -user hdfs -a -size +300c</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">#3.查找当前目录下的属主为hdfs或者以xml结尾的普通文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># find . -type f -a \( -user hdfs -o -name &#x27;*.xml&#x27; \)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 文件查找</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 文件查找" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 输入/输出重定向</title>
    <link href="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2018-01-08T15:10:01.000Z</published>
    <updated>2020-08-24T06:30:32.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重定向概述"><a href="#1-重定向概述" class="headerlink" title="1.重定向概述"></a>1.重定向概述</h2><h3 id="1-什么是重定向"><a href="#1-什么是重定向" class="headerlink" title="1.什么是重定向"></a>1.什么是重定向</h3><blockquote><p>将原本要输出到屏幕的数据信息，重新定向到某个指定的文件中。比如：每天凌晨定时备份数据，希望将备份数据的结果保存到某个文件中，这样第二天通过查看文件的内容就知道昨天备份的数据是成功还是失败。</p></blockquote><h3 id="2-为何要使用重定向"><a href="#2-为何要使用重定向" class="headerlink" title="2.为何要使用重定向"></a>2.为何要使用重定向</h3><blockquote><ul><li>1.当屏幕输出的信息很重要，而且希望保存重要的信息时；</li><li>2.后台执行中的程序，不希望干扰屏幕正常的输出结果时；</li><li>3.系统的例行命令, 例如定时任务的执行结果，希望可以存下来时；</li><li>4.一些执行命令，我们已经知道他可能出现错误信息, 想将他直接丢弃时;</li><li>5.错误日志与正确日志需要分别输出至不同的文件保存时;</li></ul></blockquote><h3 id="3-学习重定向的预备知识，标准输入与输出"><a href="#3-学习重定向的预备知识，标准输入与输出" class="headerlink" title="3.学习重定向的预备知识，标准输入与输出"></a>3.学习重定向的预备知识，标准输入与输出</h3><blockquote><ul><li>当运行一个程序时通常会自动打开三个<code>标准文件</code>，分别是<code>标准输入</code>、<code>标准输出</code>、<code>错误输出</code></li></ul></blockquote><table><thead><tr><th align="left">名称</th><th align="left">文件描述符</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">标准输入（STDIN）</td><td align="left">0</td><td align="left">默认是键盘，也可以是文件或其他命令的输出。</td></tr><tr><td align="left">标准输出（STDOUT）</td><td align="left">1</td><td align="left">默认输出到屏幕。</td></tr><tr><td align="left">错误输出（STDERR）</td><td align="left">2</td><td align="left">默认输出到屏幕。</td></tr><tr><td align="left">文件名称（filename）</td><td align="left">3+</td><td align="left"></td></tr></tbody></table><div class="note info">            <p>进程将从标准输入中得到数据，将正常输出打印至屏幕终端，将错误的输出信息也打印至屏幕终端。</p>          </div><div class="note warning">            <p>【注意】：进程是使用文件描述符(file descriptors)来管理打开的文件</p>          </div><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/1.jpg" alt="1"></p><h4 id="1-案例演示"><a href="#1-案例演示" class="headerlink" title="1.案例演示"></a>1.案例演示</h4><blockquote><ul><li>以 cat 命令为例, cat 命令的功能是从命令行给出的文件中读取数据，并将这些数据直接送到标准输出。若使用如下命令：</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#会把文件/etc/passwd的内容输出显示到屏幕上</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/passwd</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>但如果 使用 cat 命令没有跟上输入的文件名，那么cat命令则会通过命令行标准输入中读取数据, 并将其送到标准输出。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># cat</span></span><br><span class="line">hello   <span class="comment">#标准输入</span></span><br><span class="line">hello   <span class="comment">#标准输出</span></span><br><span class="line">^C</span><br><span class="line"><span class="comment">#用户输入的每一行都立刻被cat命令输出到屏幕上。</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>下面了解一下标准输入输出过程</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#持续追踪查看文件内容</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -f /etc/passwd</span></span><br><span class="line">ctrl+z 将进程转到后台</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看运行的进程</span></span><br><span class="line">[root@demo ~]<span class="comment"># ps</span></span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">5848 pts/1    00:00:00 bash</span><br><span class="line">6885 pts/1    00:00:00 tail</span><br><span class="line">6888 pts/1    00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看tail命令的pid，6885进程下的文件描述符</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls -l /proc/6885/fd</span></span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 root root 64 Dec  3 06:57 0 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 root root 64 Dec  3 06:57 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 root root 64 Dec  3 06:56 2 -&gt; /dev/pts/1</span><br><span class="line">lr-x------ 1 root root 64 Dec  3 06:57 3 -&gt; /etc/passwd</span><br><span class="line">lr-x------ 1 root root 64 Dec  3 06:57 4 -&gt; inotify</span><br><span class="line"></span><br><span class="line"><span class="comment">#Linux查看标准输入输出设备</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls -l /dev/std*</span></span><br><span class="line">lrwxrwxrwx 1 root root 15 Dec  2 22:30 /dev/stderr -&gt; /proc/self/fd/2</span><br><span class="line">lrwxrwxrwx 1 root root 15 Dec  2 22:30 /dev/stdin -&gt; /proc/self/fd/0</span><br><span class="line">lrwxrwxrwx 1 root root 15 Dec  2 22:30 /dev/stdout -&gt; /proc/self/fd/1</span><br></pre></td></tr></table></figure><h2 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a>2.输出重定向</h2><blockquote><ul><li>输出重定向，改变输出内容的位置。输出重定向有如下几种方式，如表格所示</li></ul></blockquote><table><thead><tr><th align="left">类型</th><th align="left">操作符</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">标准覆盖输出重定向</td><td align="left">&gt;</td><td align="left">将程序输出的正确结果输出到指定的文件中,会覆盖文件原有的内容</td></tr><tr><td align="left">标准追加输出重定向</td><td align="left">&gt;&gt;</td><td align="left">将程序输出的正确结果以追加的方式输出到指定文件，不会覆盖原有文件</td></tr><tr><td align="left">错误覆盖输出重定向</td><td align="left">2&gt;</td><td align="left">将程序的错误结果输出到执行的文件中，会覆盖文件原有的内容</td></tr><tr><td align="left">错误追加输出重定向</td><td align="left">2&gt;&gt;</td><td align="left">将程序输出的错误结果以追加的方式输出到指定文件，不会覆盖原有文件</td></tr><tr><td align="left">标准输入重定向</td><td align="left">&lt;&lt;</td><td align="left">将命令中接收输入的途径由默认的键盘更改为指定的文件或命令</td></tr></tbody></table><h3 id="案例1-标准输出重定向-每次都会覆盖文件"><a href="#案例1-标准输出重定向-每次都会覆盖文件" class="headerlink" title="案例1: 标准输出重定向(每次都会覆盖文件)"></a>案例1: 标准输出重定向(每次都会覆盖文件)</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/2.jpg" alt="2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标准输出重定向, 先清空,后写入, 如果文件不存在则创建</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig eth0 &gt; abc</span></span><br></pre></td></tr></table></figure><h3 id="案例2-标准输出重定向-会往文件的尾部在添加内容"><a href="#案例2-标准输出重定向-会往文件的尾部在添加内容" class="headerlink" title="案例2: 标准输出重定向(会往文件的尾部在添加内容)"></a>案例2: 标准输出重定向(会往文件的尾部在添加内容)</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/3.jpg" alt="3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标准追加输出重定向, 向配置文件末尾追加内容</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;This is network conf&quot; &gt;&gt; if </span></span><br></pre></td></tr></table></figure><h3 id="案例3-错误输出重定向"><a href="#案例3-错误输出重定向" class="headerlink" title="案例3: 错误输出重定向"></a>案例3: 错误输出重定向</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/4.jpg" alt="4"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正确输出以及错误输出重定向至一个文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd jac</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - jac</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将标准输出和标准错误输出重定向到不同文件</span></span><br><span class="line">[jac@demo ~]$ find /etc -name <span class="string">&quot;*.conf&quot;</span> 1&gt;a 2&gt;b</span><br></pre></td></tr></table></figure><h3 id="案例4-正确和错误都输入到相同位置"><a href="#案例4-正确和错误都输入到相同位置" class="headerlink" title="案例4: 正确和错误都输入到相同位置"></a>案例4: 正确和错误都输入到相同位置</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/5.jpg" alt="5"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将标准输出和标准错误输出重定向到同一个文件, 混合输出</span></span><br><span class="line">[jac@demo ~]$ find /etc -name <span class="string">&quot;*.conf&quot;</span> &amp;&gt;ab</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并两个文件内容至一个文件</span></span><br><span class="line">[jac@demo ~]$ cat a b &gt; c</span><br></pre></td></tr></table></figure><h3 id="案例5-正确和错误都输入到相同位置"><a href="#案例5-正确和错误都输入到相同位置" class="headerlink" title="案例5: 正确和错误都输入到相同位置"></a>案例5: 正确和错误都输入到相同位置</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/6.jpg" alt="6"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重定向到相同的位置</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls /root /error &gt;ab  2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><h3 id="案例6-重定向到空设备-dev-null"><a href="#案例6-重定向到空设备-dev-null" class="headerlink" title="案例6: 重定向到空设备/dev/null"></a>案例6: 重定向到空设备/dev/null</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/7.jpg" alt="7"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将产生的任何数据放入黑洞设备，则视为丢弃。</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls /root /error &gt;ab 2&gt;/dev/null</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls /root /error &gt;ab &amp;&gt;/dev/null</span></span><br></pre></td></tr></table></figure><h3 id="案例7-脚本中使用重定向-了解即可"><a href="#案例7-脚本中使用重定向-了解即可" class="headerlink" title="案例7: 脚本中使用重定向 (了解即可)"></a>案例7: 脚本中使用重定向 (了解即可)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># vim ping.sh </span></span><br><span class="line">ping -c1 10.0.0.1</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;10.0.0.1 is up.&quot;</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;10.0.0.1 is down.&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod +x ping.sh </span></span><br><span class="line">[root@demo ~]<span class="comment"># ./ping.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#改进后版</span></span><br><span class="line">[root@demo ~]<span class="comment"># vim ping.sh</span></span><br><span class="line">ping -c1 10.0.0.1 &amp;&gt;/dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;10.0.0.1 is up.&quot;</span> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;10.0.0.1 is down.&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="案例8-脚本中使用重定向-了解即可"><a href="#案例8-脚本中使用重定向-了解即可" class="headerlink" title="案例8: 脚本中使用重定向 (了解即可)"></a>案例8: 脚本中使用重定向 (了解即可)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># vim ping2.sh </span></span><br><span class="line">ping -c1 10.0.0.1 &amp;&gt;/dev/null </span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;10.0.0.1 is up.&quot;</span> &gt;&gt;up.txt </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;10.0.0.1 is down.&quot;</span> &gt;&gt;down.txt </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod +x ping2.sh </span></span><br><span class="line">[root@demo ~]<span class="comment"># ./ping2.sh</span></span><br></pre></td></tr></table></figure><h2 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3.输入重定向"></a>3.输入重定向</h2><blockquote><p>输入重定向，即原本从键盘等上获得的输入信息，重定向由命令的输出作为输入。&lt; 等价 0&lt;</p></blockquote><h3 id="案例1-从文件中读入输入的操作"><a href="#案例1-从文件中读入输入的操作" class="headerlink" title="案例1: 从文件中读入输入的操作"></a>案例1: 从文件中读入输入的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有改变输入的方向，默认键盘</span></span><br><span class="line">[root@demo ~]<span class="comment"># mail al</span></span><br><span class="line">Subject: hello</span><br><span class="line">1111 </span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">.   <span class="comment">#结束</span></span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否收到邮件</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - al</span></span><br><span class="line">[root@demo ~]<span class="comment"># mail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入重定向，来自于文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># mail -s &quot;test01&quot; al &lt; /etc/hosts</span></span><br></pre></td></tr></table></figure><h3 id="案例2-无法形容案例，请看实际操作"><a href="#案例2-无法形容案例，请看实际操作" class="headerlink" title="案例2: 无法形容案例，请看实际操作"></a>案例2: 无法形容案例，请看实际操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有改变输入的方向，默认键盘，此时等待输入</span></span><br><span class="line">[root@demo ~]<span class="comment"># grep &#x27;root&#x27; </span></span><br><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># grep &#x27;root&#x27; &lt; /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br></pre></td></tr></table></figure><h3 id="案例3-无法形容案例，请看实际操作"><a href="#案例3-无法形容案例，请看实际操作" class="headerlink" title="案例3: 无法形容案例，请看实际操作"></a>案例3: 无法形容案例，请看实际操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># dd if=/dev/zero of=/file1.txt bs=1M count=20</span></span><br><span class="line">[root@demo ~]<span class="comment"># dd &lt;/dev/zero &gt;/file2.txt bs=1M count=20</span></span><br></pre></td></tr></table></figure><h3 id="案例4-mysql如何恢复备份，了解即可，不用关注。"><a href="#案例4-mysql如何恢复备份，了解即可，不用关注。" class="headerlink" title="案例4: mysql如何恢复备份，了解即可，不用关注。"></a>案例4: mysql如何恢复备份，了解即可，不用关注。</h3><p><code>[root@demo ~]# mysql -uroot -p123 &lt; bbs.sql</code></p><h3 id="案例5-利用重定向建立多行数据的文件"><a href="#案例5-利用重定向建立多行数据的文件" class="headerlink" title="案例5: 利用重定向建立多行数据的文件"></a>案例5: 利用重定向建立多行数据的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动执行 shell 命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;111&quot; &gt; file1.txt </span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file1.txt</span></span><br><span class="line">111</span><br><span class="line">[root@demo ~]<span class="comment"># cat &gt;file2.txt</span></span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">^D</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># cat &gt;&gt;file3.txt</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">^D</span><br></pre></td></tr></table></figure><h3 id="案例6-脚本中打印菜单的一种使用方法。"><a href="#案例6-脚本中打印菜单的一种使用方法。" class="headerlink" title="案例6: 脚本中打印菜单的一种使用方法。"></a>案例6: 脚本中打印菜单的一种使用方法。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># vim vm.sh</span></span><br><span class="line">cat &lt;&lt;-EOF</span><br><span class="line">+------------------- --- ---- --- ---- --- --- ---- --- --+ ||</span><br><span class="line">| ====================== | </span><br><span class="line">| 虚拟机基本管理 v5.0 |</span><br><span class="line">| by xuliangwei |</span><br><span class="line">| ====================== | </span><br><span class="line">| 1. 安装 KVM |</span><br><span class="line">| 2. 安装或重置 CentOS-6.9 | </span><br><span class="line">| 3. 安装或重置 CentOS-7.4 | </span><br><span class="line">| 5. 安装或重置 Windows-7  | </span><br><span class="line">| 6. 删除所有虚拟机 |</span><br><span class="line">| q. 退出管理程序 |</span><br><span class="line">+------------------- --- ---- --- ---- --- --- ---- --- --+ </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="案例7-两条命令同时重定向"><a href="#案例7-两条命令同时重定向" class="headerlink" title="案例7: 两条命令同时重定向"></a>案例7: 两条命令同时重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ls; date &amp;&gt;/dev/null</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls &amp;&gt;/dev/null; date &amp;&gt;/dev/null</span></span><br><span class="line">[root@demo ~]<span class="comment"># (ls; date) &amp;&gt;/dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后台执行</span></span><br><span class="line">[root@demo ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;</span></span><br><span class="line">[1] 6378</span><br><span class="line">[root@demo ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;&gt;date.txt &amp;</span></span><br><span class="line">[root@demo ~]<span class="comment"># jobs</span></span><br><span class="line">[1]+ 运行中 ( <span class="keyword">while</span> :; <span class="keyword">do</span> date; sleep 2;</span><br><span class="line"><span class="keyword">done</span> ) &amp;&gt;/date.txt &amp;</span><br></pre></td></tr></table></figure><h3 id="扩展点-subshell-了解即可"><a href="#扩展点-subshell-了解即可" class="headerlink" title="扩展点: subshell 了解即可"></a>扩展点: subshell 了解即可</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># cd /boot; ls</span></span><br><span class="line"></span><br><span class="line">//subshell 中执行</span><br><span class="line">[root@demo ~]<span class="comment"># (cd /boot; ls)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不希望某些命令的执行对当前 shell 环境产生影响，请在subshell中执行</span></span><br></pre></td></tr></table></figure><h2 id="4-进程管道技术"><a href="#4-进程管道技术" class="headerlink" title="4.进程管道技术"></a>4.进程管道技术</h2><h3 id="1-什么是管道"><a href="#1-什么是管道" class="headerlink" title="1.什么是管道"></a>1.什么是管道</h3><blockquote><p>管道操作符号 “|” ，主要用来连接左右两个命令, 将左侧的命令的标准输出, 交给右侧命令的标准输入<br><mark>【注意】: 无法传递标准错误输出至后者命令</mark></p></blockquote><h3 id="2-管道流程示意图"><a href="#2-管道流程示意图" class="headerlink" title="2.管道流程示意图"></a>2.管道流程示意图</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/8.jpg" alt="8"></p><blockquote><p><strong>格式: cmd1 | cmd2 […|cmdn]</strong></p></blockquote><h3 id="3-管道使用案例"><a href="#3-管道使用案例" class="headerlink" title="3.管道使用案例"></a>3.管道使用案例</h3><h4 id="案例1-将-etc-passwd-中的用户按-UID-大小排序"><a href="#案例1-将-etc-passwd-中的用户按-UID-大小排序" class="headerlink" title="案例1: 将/etc/passwd 中的用户按 UID 大小排序"></a>案例1: 将/etc/passwd 中的用户按 UID 大小排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># sort -t&quot;:&quot; -k3 -n /etc/passwd</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort -t&quot;:&quot; -k3 -n /etc/passwd -r</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort -t&quot;:&quot; -k3 -n /etc/passwd |head</span></span><br></pre></td></tr></table></figure><h4 id="案例2-统计当前-etc-passwd-中用户使用的-shell-类型"><a href="#案例2-统计当前-etc-passwd-中用户使用的-shell-类型" class="headerlink" title="案例2: 统计当前/etc/passwd 中用户使用的 shell 类型"></a>案例2: 统计当前/etc/passwd 中用户使用的 shell 类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#思路:取出第七列(shell) | 排序(把相同归类)| 去重</span></span><br><span class="line">[root@demo ~]<span class="comment"># awk -F: &#x27;&#123;print $7&#125;&#x27; /etc/passwd</span></span><br><span class="line">[root@demo ~]<span class="comment"># awk -F: &#x27;&#123;print $7&#125;&#x27; /etc/passwd |sort</span></span><br><span class="line">[root@demo ~]<span class="comment"># awk -F: &#x27;&#123;print $7&#125;&#x27; /etc/passwd |sort |uniq</span></span><br><span class="line">[root@demo ~]<span class="comment"># awk -F: &#x27;&#123;print $7&#125;&#x27; /etc/passwd |sort |uniq -c</span></span><br></pre></td></tr></table></figure><h4 id="案例3-统计网站的访问情况-top-20"><a href="#案例3-统计网站的访问情况-top-20" class="headerlink" title="案例3: 统计网站的访问情况 top 20"></a>案例3: 统计网站的访问情况 top 20</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#思路: 打印所有访问的连接 | 过滤访问网站的连接 | 打印用户的 IP | 排序 | 去重</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># yum -y install httpd</span></span><br><span class="line">[root@demo ~]<span class="comment"># systemctl start httpd</span></span><br><span class="line">[root@demo ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># ss -an |grep :80 |awk -F&quot;:&quot; &#x27;&#123;print $8&#125;&#x27; |sort |uniq -c</span></span><br><span class="line">[root@demo ~]<span class="comment"># ss -an |grep :80 |awk -F&quot;:&quot; &#x27;&#123;print $8&#125;&#x27; |sort |uniq -c |sort -k1 -rn |head -n 20</span></span><br></pre></td></tr></table></figure><h4 id="案例4-打印当前所有-IP"><a href="#案例4-打印当前所有-IP" class="headerlink" title="案例4: 打印当前所有 IP"></a>案例4: 打印当前所有 IP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ip addr |grep &#x27;inet &#x27; |awk &#x27;&#123;print $2&#125;&#x27; |awk -F&quot;/&quot; &#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">127.0.0.1</span><br><span class="line">192.168.69.112</span><br></pre></td></tr></table></figure><h4 id="案例5-打印根分区已用空间的百分比-仅打印数字"><a href="#案例5-打印根分区已用空间的百分比-仅打印数字" class="headerlink" title="案例5: 打印根分区已用空间的百分比(仅打印数字)"></a>案例5: 打印根分区已用空间的百分比(仅打印数字)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># df |grep &#x27;/$&#x27; |awk &#x27;&#123;print $5&#125;&#x27; |awk -F&quot;%&quot; &#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><div class="note success">            <p>【注意】: 管道命令符能让大家能进一步掌握命令之间的搭配使用方法，进一步提高命令输出值的处理效率。</p>          </div><h3 id="4-管道中的tee技术"><a href="#4-管道中的tee技术" class="headerlink" title="4.管道中的tee技术"></a>4.管道中的tee技术</h3><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/08/Linux%E5%9F%BA%E7%A1%80/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/9.jpg" alt="9"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项: -a追加</span></span><br><span class="line">[root@demo ~]<span class="comment"># ip addr |grep &#x27;inet &#x27; |tee ip.txt |awk -F&quot;/&quot; &#x27;&#123;print $1&#125;&#x27; |awk &#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">127.0.0.1</span><br><span class="line">10.0.0.100</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># cat ip.txt</span></span><br><span class="line">inet 127.0.0.1/8 scope host lo</span><br><span class="line">inet 10.0.0.100/24 brd 192.168.69.255 scope global ens32</span><br></pre></td></tr></table></figure><blockquote><ul><li>重定向与 tee 有他们在使用过程中有什么区别？</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># date &gt; date.txt    #直接将内容写入date.txt文件中</span></span><br><span class="line">[root@demo ~]<span class="comment"># date |tee date.txt #命令执行会输出至屏幕，但会同时保存一份至date.txt文件中</span></span><br></pre></td></tr></table></figure><h3 id="5-xargs参数传递，主要让一些不支持管道的命令可以使用管道技术"><a href="#5-xargs参数传递，主要让一些不支持管道的命令可以使用管道技术" class="headerlink" title="5.xargs参数传递，主要让一些不支持管道的命令可以使用管道技术"></a>5.xargs参数传递，主要让一些不支持管道的命令可以使用管道技术</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which cat|xargs ls- l</span></span><br><span class="line"><span class="comment"># ls |xargs rm -fv</span></span><br><span class="line"><span class="comment"># ls |xargs cp -rvt /tmp/ -或-&gt; ls | xargs -I &#123;&#125; cp -rv &#123;&#125; /tmp/</span></span><br><span class="line"><span class="comment"># ls |xargs mv -t /tmp/   -或-&gt; ls | xargs -I &#123;&#125;  mv &#123;&#125; /tmp</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 输入/输出重定向</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 输入/输出重定向" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux ACL控制</title>
    <link href="https://www.demon-w.com/2018/01/07/Linux%E5%9F%BA%E7%A1%80/LinuxACL%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.demon-w.com/2018/01/07/Linux%E5%9F%BA%E7%A1%80/LinuxACL%E6%8E%A7%E5%88%B6/</id>
    <published>2018-01-07T15:10:01.000Z</published>
    <updated>2020-08-23T14:13:42.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ACL访问控制概述"><a href="#1-ACL访问控制概述" class="headerlink" title="1.ACL访问控制概述"></a>1.ACL访问控制概述</h2><blockquote><p>在我们之前了解的Linux基本权限、以及Linux特殊权限中，控制仅可以对所属用户、所属组、其他用户进行的权限控制，而不能精确地控制每个用户的权限。ACL规则就是用来解决这个问题的。使用ACL规则，我们可以针对单一账户设置文件及目录的访问权限。<br><strong>ACL可以设置的基本权限： r、w、x</strong><br><strong>设定acl只能是root管理员用户. 相关命令: getfacl , setfacl</strong></p></blockquote><h3 id="1-acl基本使用方式"><a href="#1-acl基本使用方式" class="headerlink" title="1.acl基本使用方式"></a>1.acl基本使用方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># cp /etc/passwd /root/passwd</span></span><br><span class="line">//文件在没有设定acl, 看到的和传统权限是一样</span><br><span class="line">[root@demo ~]<span class="comment"># ll passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 1110 Aug 23 21:41 passwd</span><br><span class="line"></span><br><span class="line">//使用getacl查看权限</span><br><span class="line">[root@demo ~]<span class="comment"># getfacl passwd </span></span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-   //文件owner权限</span><br><span class="line">group::r--  //文件拥有组权限</span><br><span class="line">other::r--  //其他人权限</span><br></pre></td></tr></table></figure><h3 id="2-设定acl权限方式如下"><a href="#2-设定acl权限方式如下" class="headerlink" title="2.设定acl权限方式如下"></a>2.设定acl权限方式如下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 1110 Aug 23 21:41 passwd</span><br><span class="line"></span><br><span class="line">al  拥有读写权限     rw</span><br><span class="line"><span class="built_in">bg</span>  没有任何权限     -</span><br><span class="line">jac 组拥有读权限     r</span><br><span class="line">匿名用户拥有读写权限  rw</span><br><span class="line"></span><br><span class="line">//建立相关用户</span><br><span class="line">[root@demo ~]<span class="comment"># useradd al</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd bg</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd jac</span></span><br><span class="line"></span><br><span class="line">//增加用户 al 权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m u:al:rw passwd</span></span><br><span class="line"></span><br><span class="line">//增加用户 <span class="built_in">bg</span> 权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m u:bg:- passwd</span></span><br><span class="line"></span><br><span class="line">//增加匿名用户权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m o::rw passwd</span></span><br><span class="line"></span><br><span class="line">//增加组权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m g:jac:r passwd</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>注意: 如果用户同时属于不同的两个组，并且两个组设定了acl访问控制<br>1.根据acl访问控制优先级进行匹配规则<br>2.如有用户拥有多个组的权限不同的权限，优先使用最高权限（模糊匹配）</p>          </div><h3 id="3-查看acl权限"><a href="#3-查看acl权限" class="headerlink" title="3.查看acl权限"></a>3.查看acl权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll passwd</span></span><br><span class="line">-rw-rw-rw-+ 1 root root 1531 Jan 26 07:52 passwd</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># getfacl passwd</span></span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:<span class="built_in">bg</span>:---</span><br><span class="line">user:al:rw-</span><br><span class="line">group::r--</span><br><span class="line">group:jac:r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::rw-</span><br></pre></td></tr></table></figure><h3 id="4-移除acl权限"><a href="#4-移除acl权限" class="headerlink" title="4.移除acl权限"></a>4.移除acl权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//移除jac组的acl权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -x g:jac passwd</span></span><br><span class="line"></span><br><span class="line">//移除bgx用户的acl权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -x u:bg passwd</span></span><br><span class="line"></span><br><span class="line">//移除文件和目录所有acl权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -b passwd</span></span><br><span class="line"></span><br><span class="line">//移除默认的acl</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -k dir</span></span><br></pre></td></tr></table></figure><h3 id="5-查看acl帮助"><a href="#5-查看acl帮助" class="headerlink" title="5.查看acl帮助"></a>5.查看acl帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//EXAMPLES 示例文档</span><br><span class="line">[root@demo ~]<span class="comment"># man setfacl</span></span><br><span class="line"></span><br><span class="line">//复制 file1 的 ACL 权限给 file2</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m u:al:rw,u:bg:r,g:jac:rw file1</span></span><br><span class="line">[root@demo ~]<span class="comment"># getfacl file1 |setfacl --set-file=- file2</span></span><br></pre></td></tr></table></figure><h2 id="2-ACL高级特性MASK"><a href="#2-ACL高级特性MASK" class="headerlink" title="2.ACL高级特性MASK"></a>2.ACL高级特性MASK</h2><blockquote><ul><li>1.mask用于临时降低用户或组的权限，但不包括文件的所有者和其他人。</li><li>2.mask最主要的作用是用来决定用户的最高权限。</li></ul></blockquote><div class="note info">            <p>mask默认不会对匿名用户降低权限，所以为了便于管理文件的访问控制，建议匿名用户的权限置为空</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//临时降低用户或组权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m mask::rw filename</span></span><br></pre></td></tr></table></figure><h3 id="mask小结"><a href="#mask小结" class="headerlink" title="mask小结"></a>mask小结</h3><blockquote><ul><li>1.mask会影响哪些用户，除了所有者和其他人。</li><li>2.mask权限决定了用户访问文件时的最高权限。(如何影响)</li><li>3.mask用于临时降低用户访问文件的权限。(mask做什么)</li><li>4.任何重新设置acl访问控制会清理mask所设定的权限。</li></ul></blockquote><h2 id="3-ACL高级特性Default"><a href="#3-ACL高级特性Default" class="headerlink" title="3.ACL高级特性Default"></a>3.ACL高级特性Default</h2><blockquote><p><strong>default: 继承(默认)</strong></p><ul><li>案例演示：al能够对/opt目录以及以后在/opt目录下新建的文件有读、写、执行权限</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//赋予 al 对/opt 读写执行权限 </span><br><span class="line">[root@demo ~]<span class="comment">## setfacl -R -m u:al:rwX /opt</span></span><br><span class="line">//赋予 al 对以后在/opt 下新建的文件有读写执行权限(使 al 的权限继承) </span><br><span class="line">[root@demo ~]<span class="comment">## setfacl -m d:u:al:rwX /opt</span></span><br><span class="line"></span><br><span class="line">//检查对应的权限</span><br><span class="line">[root@demo ~]<span class="comment"># getfacl /opt/</span></span><br><span class="line">getfacl: Removing leading <span class="string">&#x27;/&#x27;</span> from absolute path names</span><br><span class="line"><span class="comment"># file: opt/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: bg</span></span><br><span class="line">user::rwx</span><br><span class="line">user:al:rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::rwx</span><br><span class="line">default:user::rwx</span><br><span class="line">default:user:al:rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::rwx</span><br></pre></td></tr></table></figure><h2 id="4-ACL访问控制实践案例"><a href="#4-ACL访问控制实践案例" class="headerlink" title="4.ACL访问控制实践案例"></a>4.ACL访问控制实践案例</h2><h3 id="案例1-将新建文件的属性修改tom-admin-权限默认为644"><a href="#案例1-将新建文件的属性修改tom-admin-权限默认为644" class="headerlink" title="案例1: 将新建文件的属性修改tom:admin, 权限默认为644"></a>案例1: 将新建文件的属性修改tom:admin, 权限默认为644</h3><blockquote><ul><li>要求: tom对该文件有所有的权限, mary可以读写该文件, admin组可以读写执行该文件, jack只读该文件, 其他人一律不能访问该文件</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//实验前, 建立几个普通用户</span><br><span class="line">[root@demo ~]<span class="comment"># useradd tom</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd bean</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd mary</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd jack</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd sutdent</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd admin</span></span><br><span class="line">[root@demo ~]<span class="comment"># gpasswd -a mary admin</span></span><br><span class="line">[root@demo ~]<span class="comment"># gpasswd -a bean admin</span></span><br><span class="line"></span><br><span class="line">//检查用户属性</span><br><span class="line">[root@demo ~]<span class="comment"># id tom</span></span><br><span class="line">uid=1004(tom) gid=1004(tom) groups=1004(tom)</span><br><span class="line">[root@demo ~]<span class="comment"># id mary</span></span><br><span class="line">uid=1006(mary) gid=1006(mary) groups=1006(mary),1007(admin)</span><br><span class="line">[root@demo ~]<span class="comment"># id bean</span></span><br><span class="line">uid=1005(bean) gid=1005(bean) groups=1005(bean),1007(admin)</span><br><span class="line">[root@demo ~]<span class="comment"># id jack</span></span><br><span class="line">uid=1002(jack) gid=1002(jack) groups=1002(jack)</span><br><span class="line">[root@demo ~]<span class="comment"># id sutdent</span></span><br><span class="line">uid=1007(sutdent) gid=1008(sutdent) groups=1008(sutdent)</span><br><span class="line"></span><br><span class="line">//准备相关文件</span><br><span class="line">[root@demo ~]<span class="comment"># cp /etc/passwd /root/</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown tom:admin passwd</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 644 passwd</span></span><br><span class="line"></span><br><span class="line">//检查设定前的acl列表</span><br><span class="line">[root@demo ~]<span class="comment"># getfacl passwd</span></span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: tom</span></span><br><span class="line"><span class="comment"># group: admin</span></span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line">//设定acl权限</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -m u::rwx,u:mary:rw,u:jack:r,g:admin:rwx,o::- passwd</span></span><br><span class="line"></span><br><span class="line">//检查acl权限</span><br><span class="line">[root@demo ~]<span class="comment"># getfacl passwd</span></span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: tom</span></span><br><span class="line"><span class="comment"># group: admin</span></span><br><span class="line">user::rwx</span><br><span class="line">user:jack:r--</span><br><span class="line">user:mary:rw-</span><br><span class="line">group::r--</span><br><span class="line">group:admin:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><blockquote><p><strong>acl的控制规则是从上往下匹配</strong></p><ul><li><strong>1.tom由于是文件的拥有者，所以直接按照user::rwx指定的权限去操作</strong></li><li><strong>2.mary用户从上往下寻找匹配规则，发现user:mary:rw-能够精确匹配mary用户，尽管mary属于admin组，同时admin组有rwx的权限，但是由于mary用户的规则在前面，所有优先生效。</strong></li><li><strong>3.bean由于找不到精确匹配的规则，而bean是属于admin组，根据文件的定义，该文件是属于admin组，所以bean的权限是按照group:admin:rwx的权限去操作。</strong></li><li><strong>4.jack用户从上往下寻找匹配规则，发现user:jack:r–能够精确匹配jack用户。</strong></li><li><strong>5.student用户找不到精确匹配的user定义规则, 也找不到相关组的定义规则，最后属于other。</strong></li></ul></blockquote><h3 id="案例2-lab-acl-setup"><a href="#案例2-lab-acl-setup" class="headerlink" title="案例2: lab acl setup"></a>案例2: lab acl setup</h3><blockquote><ul><li>要求：</li></ul><p>controller组成员有:student<br>sodor组成员有:thomas,james</p><p>目录: /shares/steamies<br>文件: /shares/steamies/file<br>脚本: /shares/steamies/test.sh</p><p>controller属于该目录的所属组, 新建文件必须属于controller组<br>sodor组的成员对该目录拥有rwx权限<br>sodor组成员james对该目录及子目录(包括以后新建立的文件)没有任何权限</p></blockquote><blockquote><ul><li><strong>实际操作</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//准备用户</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd controller</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd sodor</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd student -G controller</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd thomas -G sodor</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd james -G sodor</span></span><br><span class="line"></span><br><span class="line">//准备目录</span><br><span class="line">[root@demo ~]<span class="comment"># mkdir /shares/steamies -p</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;file&quot; &gt;&gt; /shares/steamies/file</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;echo 123&quot; &gt;&gt; /shares/steamies/test.sh</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 755 /shares/steamies/test.sh</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown -R  :controller /shares/steamies/</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod g+s /shares/steamies/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设定权限(X表示,如果原本有执行权限就保留,如果没有则不添加)</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -R -m g:sodor:rwX,u:james:- /shares/steamies/</span></span><br><span class="line"></span><br><span class="line">//设定继承规则</span><br><span class="line">[root@demo ~]<span class="comment"># setfacl -R -m d:g:sodor:rwX,d:u:james:- /shares/steamies/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@demo steamies]<span class="comment"># getfacl /shares/steamies/</span></span><br><span class="line">getfacl: Removing leading <span class="string">&#x27;/&#x27;</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">user:james:---</span><br><span class="line">group::r-x</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::r-x</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::r-x</span><br><span class="line">default:group:sodor:rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::r-x</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux ACL控制</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux ACL控制" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-ACL%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 特殊权限</title>
    <link href="https://www.demon-w.com/2018/01/06/Linux%E5%9F%BA%E7%A1%80/Linux%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/"/>
    <id>https://www.demon-w.com/2018/01/06/Linux%E5%9F%BA%E7%A1%80/Linux%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</id>
    <published>2018-01-06T15:10:00.000Z</published>
    <updated>2020-08-23T04:39:19.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-特殊权限概述"><a href="#1-特殊权限概述" class="headerlink" title="1.特殊权限概述"></a>1.特殊权限概述</h2><blockquote><p>前面我们已经了解过<code> r（读）</code>、<code>w（写）</code>、 <code>x（执行）</code>这三种普通权限，但是我们在査询系统文件权限时会发现出现了一些其他权限字母，比如：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll /usr/bin/passwd</span></span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2017 /usr/bin/passwd</span><br></pre></td></tr></table></figure><blockquote><p>在属主本来应该是<code> x（执行）</code>权限的位置出现了一个小写<code>s</code>，这是什么权限？我们把这种权限称作 <code>SetUID 权限</code>，也叫作<code> SUID</code> 的特殊权限。这种权限有什么作用呢？</p></blockquote><h2 id="2-特殊权限SUID"><a href="#2-特殊权限SUID" class="headerlink" title="2.特殊权限SUID"></a>2.特殊权限SUID</h2><h3 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1.发现问题"></a>1.发现问题</h3><blockquote><p>在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是，普通用户的信息保存在 /etc/passwd 文件中，用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己的密码时修改了 /etc/shadow 文件中的加密密码，但是文件权限显示，普通用户对这两个文件其实都是没有写权限的，那为什么普通用户可以修改自己的权限呢？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll /etc/passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 6209 Apr 13 03:26 /etc/passwd</span><br><span class="line">[root@demo ~]<span class="comment"># ll /etc/shadow</span></span><br><span class="line">---------- 1 root root 11409 Apr 13 03:26 /etc/shadow</span><br></pre></td></tr></table></figure><h3 id="2-解决问题"><a href="#2-解决问题" class="headerlink" title="2.解决问题"></a>2.解决问题</h3><blockquote><p>其实，普通用户可以修改自己的密码在于 passwd 命令。该命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。</p></blockquote><div class="note info">            <p>【注意】：当普通用户使用 passwd 命令更改自己的密码时，实际上是在用 passwd 命令所有者 root 的身份在执行 passwd 命令，root 当然可以将密码写入 /etc/shadow 文件，所以普通用户也可以修改 /etc/shadow 文件，命令执行完成后，该身份也随之消失。</p>          </div><h3 id="3-案例演示"><a href="#3-案例演示" class="headerlink" title="3.案例演示"></a>3.案例演示</h3><blockquote><p>举个例子，有一个用户 lamp，她可以修改自己的权限，因为 passwd 命令拥有 SetUID 权限；但是她不能査看 /etc/shadow 文件的内容，因为査看文件的命令（如 cat）没有 SetUID 权限。命令如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自己可以修改自己的密码，从而改变/etc/shadow中的数据</span></span><br><span class="line">[lamp@demo ~]$ passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#但无法使用cat命令查看/etc/shadow</span></span><br><span class="line">[lamp@demo ~]$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></table></figure><blockquote><p><strong>我们通过示意图来理解上述过程：</strong><br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/06/Linux%E5%9F%BA%E7%A1%80/Linux%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/1.jpg" alt="1"></p></blockquote><h3 id="4-案例解释"><a href="#4-案例解释" class="headerlink" title="4.案例解释"></a>4.案例解释</h3><blockquote><p>1.passwd 是系统命令，可以执行，所以可以赋予 SetUID 权限。<br>2.lamp 用户对 passwd 命令拥有 x（执行）权限。<br>3.lamp 用户在执行 passwd 命令的过程中，会暂时切换为 root 身份，所以可以修改 /etc/shadow 文件。<br>4.命令结束，lamp 用户切换回自己的身份。<br>5.cat命令没有 SetUID权限，所以使用 lamp 用户身份去访问 /etc/shadow 文件，当然没有相应权限了。</p></blockquote><h3 id="5-suid授权方法4000，权限字符s-S-，用户位置上的x位上设置"><a href="#5-suid授权方法4000，权限字符s-S-，用户位置上的x位上设置" class="headerlink" title="5.suid授权方法4000，权限字符s(S)，用户位置上的x位上设置"></a>5.suid授权方法4000，权限字符s(S)，用户位置上的x位上设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 4755 passwd</span></span><br><span class="line"><span class="comment"># chmod  u+s  passwd</span></span><br></pre></td></tr></table></figure><h3 id="6-suid的作用"><a href="#6-suid的作用" class="headerlink" title="6.suid的作用"></a>6.suid的作用</h3><blockquote><ul><li>1.让普通用户对可执行的二进制文件，临时拥有二进制文件的所属主权限。</li><li>2.如果设置的二进制文件没有执行权限,那么suid的权限显示就是大S。</li><li>3.特殊权限suid仅对二进制可执行程序有效，其他文件或目录则无效。</li></ul></blockquote><div class="note danger">            <p>注意: suid极度危险，不信可以尝试对vim或rm进行设定SetUID。</p>          </div><h2 id="3-特殊权限SGID"><a href="#3-特殊权限SGID" class="headerlink" title="3.特殊权限SGID"></a>3.特殊权限SGID</h2><blockquote><p>将目录设置为sgid后，如果在该目录下创建文件，都将与该目录的所属组保持一致，演示如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.建立测试目录</span><br><span class="line">[root@demo ~]<span class="comment"># cd /tmp/ &amp;&amp; mkdir dtest</span></span><br><span class="line"></span><br><span class="line">2.给测试目录赋予SetGID权限，检查SetGID是否生效</span><br><span class="line">[root@demo tmp]<span class="comment"># chmod g+s dtest/ &amp;&amp; ll -d dtest/</span></span><br><span class="line">drwxr-sr-x 2 root root 6 Apr 13 05:21 dtest/</span><br><span class="line"></span><br><span class="line">3.给测试目录赋予777权限，让普通用户可以写</span><br><span class="line">[root@demo tmp]<span class="comment"># chmod 777 dtest/</span></span><br><span class="line"></span><br><span class="line">4.切换成普通用户lamp，并进入该目录</span><br><span class="line">[root@demo tmp]<span class="comment"># su - lamp</span></span><br><span class="line">[lamp@demo ~]$ <span class="built_in">cd</span> /tmp/dtest/</span><br><span class="line"></span><br><span class="line">5.普通用户创建测试文件，检查文件的信息</span><br><span class="line">[lamp@demo dtest]$ touch lamp_test</span><br><span class="line">[lamp@demo dtest]$ ll</span><br><span class="line">-rw-rw-r-- 1 lamp root 0 Apr 13 05:21 lamp_test</span><br></pre></td></tr></table></figure><h3 id="1-sgid授权方法-2000权限字符s-S-，取决于属组位置上的x"><a href="#1-sgid授权方法-2000权限字符s-S-，取决于属组位置上的x" class="headerlink" title="1.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x"></a>1.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 2755  directory </span></span><br><span class="line"><span class="comment"># chmod  g+s  directory</span></span><br></pre></td></tr></table></figure><h3 id="2-sgid作用"><a href="#2-sgid作用" class="headerlink" title="2. sgid作用"></a>2. sgid作用</h3><blockquote><ul><li>1.针对用户组权限位修改，用户创建的目录或文件所属组和该目录的所属组一致。</li><li>2.当某个目录设置了sgid后，在该目录中新建的文件不再是创建该文件的默认所属组</li><li>3.使用sgid可以使得多个用户之间共享一个目录的所有文件变得简单。</li></ul></blockquote><h2 id="4-特殊权限SBIT"><a href="#4-特殊权限SBIT" class="headerlink" title="4.特殊权限SBIT"></a>4.特殊权限SBIT</h2><blockquote><p>Sticky(SI TI KI)粘滞位目前只对目录有效，作用如下：<br>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。如果没有粘滞位，那么普通用户拥有 w 权限，就可以删除此目录下的所有文件，包括其他用户建立的文件。但是一旦被赋予了粘滞位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，而不能删除其他用户建立的文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo tmp]<span class="comment"># ll -d /tmp/</span></span><br><span class="line">drwxrwxrwt. 12 root root 4096 Apr 13 05:32 /tmp/</span><br></pre></td></tr></table></figure><h3 id="1-sticky授权方法，1000-权限字符t-T-，其他用户位的x位上设置。"><a href="#1-sticky授权方法，1000-权限字符t-T-，其他用户位的x位上设置。" class="headerlink" title="1.sticky授权方法，1000 权限字符t(T)，其他用户位的x位上设置。"></a>1.sticky授权方法，1000 权限字符t(T)，其他用户位的x位上设置。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 1755  /tmp</span></span><br><span class="line"><span class="comment"># chmod o+t /tmp</span></span><br></pre></td></tr></table></figure><h3 id="2-sticky作用"><a href="#2-sticky作用" class="headerlink" title="2.sticky作用"></a>2.sticky作用</h3><blockquote><ul><li>1.让多个用户都具有写权限的目录，并让每个用户只能删自己的文件。</li><li>2.特殊sticky目录表现在others的x位，用小t表示，如果没有执行权限是T</li><li>3.一个目录即使它的权限为”777”如果是设置了粘滞位，除了目录的属主和”root”用户有权限删除，除此之外其他用户都不允许删除该目录。</li></ul></blockquote><h2 id="5-权限属性chattr"><a href="#5-权限属性chattr" class="headerlink" title="5.权限属性chattr"></a>5.权限属性chattr</h2><blockquote><p><strong>chatrr 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。</strong><br><strong>chatrr 命令格式：[root@demo ~]# chattr [+-=] [选项] 文件或目录名</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项: + 增加权限 -减少权限 =等于某个权限</span></span><br><span class="line"><span class="comment"># a：让文件或目录仅可追加内容</span></span><br><span class="line"><span class="comment"># i：不得任意更动文件或目录</span></span><br><span class="line"></span><br><span class="line">1.创建文件并设置属性</span><br><span class="line">[root@demo ~]<span class="comment"># touch file_a file_i</span></span><br><span class="line">[root@demo ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">---------------- file_a</span><br><span class="line">---------------- file_i</span><br><span class="line"></span><br><span class="line">2.使用chattr设置属性，lsattr查看权限限制</span><br><span class="line">[root@demo ~]<span class="comment"># chattr +a file_a</span></span><br><span class="line">[root@demo ~]<span class="comment"># chattr +i file_i</span></span><br><span class="line">[root@demo ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">-----a---------- file_a</span><br><span class="line">-----i---------- file_i</span><br><span class="line"></span><br><span class="line">3.a权限，无法写入和删除文件，但可以追加数据，适合/etc/passwd这样的文件</span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;aa&quot; &gt; file_a</span></span><br><span class="line">bash: file_a: Operation not permitted</span><br><span class="line">[root@demo ~]<span class="comment"># rm -f file_a</span></span><br><span class="line">rm: cannot remove ‘file_a’: Operation not permitted</span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;aa&quot; &gt;&gt; file_a</span></span><br><span class="line"></span><br><span class="line">4.i权限, 无法写入，无法删除，适合不需要更改的重要文件加锁</span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;i&quot; &gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;i&quot; &gt;&gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@demo ~]<span class="comment"># rm -f  file_i</span></span><br><span class="line">rm: cannot remove ‘file_i’: Operation not permitted</span><br><span class="line"></span><br><span class="line">5.解除限制</span><br><span class="line">[root@demo ~]<span class="comment"># chattr -a file100 </span></span><br><span class="line">[root@demo ~]<span class="comment"># chattr -i file200</span></span><br></pre></td></tr></table></figure><h2 id="6-权限掩码-umask"><a href="#6-权限掩码-umask" class="headerlink" title="6.权限掩码 umask"></a>6.权限掩码 umask</h2><h3 id="1-umask是什么"><a href="#1-umask是什么" class="headerlink" title="1.umask是什么?"></a>1.umask是什么?</h3><blockquote><p>当我们登录系统之后创建一个文件是有默认权限的，比如: 目录755、文件644、那么这个权限是怎么来的呢？这就是umask干的事情。umask设置了用户创建文件的默认权限。</p></blockquote><h3 id="2-umask是如何改变创建新文件的权限"><a href="#2-umask是如何改变创建新文件的权限" class="headerlink" title="2.umask是如何改变创建新文件的权限"></a>2.umask是如何改变创建新文件的权限</h3><blockquote><p>系统默认umask为022，那么当我们创建一个目录时，正常情况下目录的权限应该是777，但umask表示要减去的值，所以新目录文件的权限应该是777 - 022 =755。至于文件的权限也依次类推666 - 022 =644。</p></blockquote><h3 id="3-umask涉及哪些配置文件"><a href="#3-umask涉及哪些配置文件" class="headerlink" title="3.umask涉及哪些配置文件"></a>3.umask涉及哪些配置文件</h3><blockquote><ul><li><strong>1.umask涉及到的相关文件/etc/bashrc、/etc/profile、<del>/.bashrc、</del>/.bash_profile</strong></li><li><strong>2.shell (vim,touch) –umask–&gt; 会影响创建的新文件或目录权限</strong></li><li><strong>3.vsftpd服务如果修改–umask–&gt; 会影响ftp服务中新创建文件或创建目录权限</strong></li><li><strong>4.useradd如果修改umask–&gt; 会影响用户HOME家目录权限</strong></li></ul></blockquote><h3 id="4-umask演示示例"><a href="#4-umask演示示例" class="headerlink" title="4.umask演示示例"></a>4.umask演示示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.假设<span class="built_in">umask</span>值为：022（所有位为偶数）</span><br><span class="line"><span class="comment">#文件的起始权限值</span></span><br><span class="line">6 6 6  -  0 2 2  = 6 4 4 </span><br><span class="line"></span><br><span class="line">2.假设<span class="built_in">umask</span>值为：045（其他用户组位为奇数）</span><br><span class="line"><span class="comment">#计算出来的权限。由于umask的最后一位数字是5，所以，在其他用户组位再加1。</span></span><br><span class="line">6 6 6  -   0 4 5 = 6 2 1</span><br><span class="line"></span><br><span class="line">3.默认目录权限计算方法</span><br><span class="line">7 7 7  -  0 2 2 = 7 5 5</span><br><span class="line"> </span><br><span class="line"><span class="built_in">umask</span>所有位全为偶数时</span><br><span class="line"><span class="comment"># umask 044</span></span><br><span class="line"><span class="comment"># mkdir d044   目录权限为733</span></span><br><span class="line"><span class="comment"># touch f044   文件权限为622</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">umask</span>部分位为奇数时</span><br><span class="line"><span class="comment"># umask 023</span></span><br><span class="line"><span class="comment"># mkdir d023   目录权限为754</span></span><br><span class="line"><span class="comment"># touch f023   文件权限为644</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">umask</span>值的所有位为奇数时</span><br><span class="line"><span class="comment"># umask 035</span></span><br><span class="line"><span class="comment"># mkdir d035   目录权限为742</span></span><br><span class="line"><span class="comment"># touch f035   文件权限为642</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>示例1: 在 shell 进程中创建文件</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前用户的umask权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line">[root@demo ~]<span class="comment"># touch file0022</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir dir0022</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d file0022  dir0022/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Jan 24 09:02 dir0022/</span><br><span class="line">-rw-r--r-- 1 root root 0 Jan 24 09:02 file0022</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>示例2: 修改 shell umask 值(临时生效)</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># umask 000</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir dir000</span></span><br><span class="line">[root@demo ~]<span class="comment"># touch file000</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d dir000 file000</span></span><br><span class="line">drwxrwxrwx 2 root root 6 Jan 24 09:04 dir000</span><br><span class="line">-rw-rw-rw- 1 root root 0 Jan 24 09:04 file000</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>示例3: 通过 umask 决定新建用户 HOME 目录的权限</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 077</span><br><span class="line">[root@demo ~]<span class="comment"># useradd dba</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d /home/dba/</span></span><br><span class="line">drwx------. 4 dba dba 4096 3 月 11 19:50 /home/dba/</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 000</span><br><span class="line">[root@demo ~]<span class="comment"># useradd sa</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d /home/sa/</span></span><br><span class="line">drwxrwxrwx. 4 sa sa 4096 3 月 11 19:53 /home/sa/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 特殊权限</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 特殊权限" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 基本权限</title>
    <link href="https://www.demon-w.com/2018/01/05/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/"/>
    <id>https://www.demon-w.com/2018/01/05/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/</id>
    <published>2018-01-04T17:15:00.000Z</published>
    <updated>2020-08-23T03:05:49.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-权限基本概述"><a href="#1-权限基本概述" class="headerlink" title="1.权限基本概述"></a>1.权限基本概述</h2><h3 id="1-什么是权限？"><a href="#1-什么是权限？" class="headerlink" title="1.什么是权限？"></a>1.什么是权限？</h3><blockquote><p>我们可以把它理解为操作系统对用户能够执行的功能所设立的限制，主要用于约束用户能对系统所做的操作，以及内容访问的范围，或者说，权限是指某个特定的用户具有特定的系统资源使用权力。</p></blockquote><h3 id="2-为什么要有权限？"><a href="#2-为什么要有权限？" class="headerlink" title="2.为什么要有权限？"></a>2.为什么要有权限？</h3><blockquote><p>因为系统中不可能只存在一个 root 用户，一定会存在多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。</p></blockquote><h3 id="3-权限与用户之间的关系？"><a href="#3-权限与用户之间的关系？" class="headerlink" title="3.权限与用户之间的关系？"></a>3.权限与用户之间的关系？</h3><blockquote><p>在 Linux 系统中，针对文件定义了三种身份，分别是属主<code>(owner)</code>、<code>属组(group)</code>、其他人<code>(others)</code>，每一种身份又对应三种权限，分别是<code>可读(readable)</code>、<code>可写(writable)</code>、<code>可执行(excutable)</code>。</p></blockquote><h4 id="1-如何查看权限"><a href="#1-如何查看权限" class="headerlink" title="1.如何查看权限"></a>1.如何查看权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll test.txt </span></span><br><span class="line">-rwxr-xr-x 1 root root 744 Apr  2  2017 test.txt</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/05/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/1.jpg" alt="1"></p><blockquote><p>用户对文件资源，有三种角色，当一个用户访问文件流程如下:</p><ol><li>判断用户是否为文件所有者，如果是则按所有者的权限进行访问</li><li>判断用户是否为文件所有组成员，如果是则按组的权限进行访问</li><li>如果不是所有者，也不是该文件所属组，则按匿名权限进行访问</li></ol></blockquote><h4 id="2-权限中的-rwx-分别代表什么含义？"><a href="#2-权限中的-rwx-分别代表什么含义？" class="headerlink" title="2. 权限中的 rwx 分别代表什么含义？"></a>2. 权限中的 rwx 分别代表什么含义？</h4><blockquote><p>当我们使用 ls -l 查看一个文件的详细属性时，能看到每个文件都有一个 9 位基本权限位。<br>比如: rwxr-xr-x 其中每三位字符为一组，分别表示<code>属主权限位</code>，<code>属组权限位</code>，<code>匿名权限位</code>。<br>linux 中基本权限位则是使用这 9 位字符来表示，主要控制文件<code>属主 (User)</code>、<code>属组 (Group)</code>、<code>其他用户 (Other)</code></p></blockquote><table><thead><tr><th align="left">字母</th><th align="left">含义</th><th align="left">对应权限</th></tr></thead><tbody><tr><td align="left">r(read)</td><td align="left">读取权限</td><td align="left">4</td></tr><tr><td align="left">w(write)</td><td align="left">写入权限</td><td align="left">2</td></tr><tr><td align="left">x(execute)</td><td align="left">执行权限</td><td align="left">1</td></tr><tr><td align="left">-(没有权限)</td><td align="left">没有权限</td><td align="left">0</td></tr></tbody></table><div class="note danger">            <p>【注意】：如果权限位不可读、不可写、不可执行，则全部使用 - 作为占位符表示</p>          </div><h2 id="2-权限设置示例"><a href="#2-权限设置示例" class="headerlink" title="2.权限设置示例"></a>2.权限设置示例</h2><h3 id="1-使用-chmod-设定权限示例"><a href="#1-使用-chmod-设定权限示例" class="headerlink" title="1.使用 chmod 设定权限示例"></a>1.使用 chmod 设定权限示例</h3><h4 id="方式一-ugo"><a href="#方式一-ugo" class="headerlink" title="方式一: ugo"></a>方式一: ugo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># touch file                    #创建文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod a=rwx file              #给所有人添加读写执行权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod a=-rwx file             #取消所有的权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod u=rwx,g=rw,o=- file     #属主读写执行，属组读写，其他人无权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod ug=rwx,o=r file         #属主属组读写执行，其他人读权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll file</span></span><br><span class="line">-rwxrw-r-- 1 root root 0 Apr 13 03:29 file</span><br></pre></td></tr></table></figure><h4 id="方式二-number"><a href="#方式二-number" class="headerlink" title="方式二: number"></a>方式二: number</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项:  -R递归修改</span></span><br><span class="line">[root@demo ~]<span class="comment"># touch file</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 644 file</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 600 file</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll file</span></span><br><span class="line">-rw------- 1 root root 0 Apr 13 03:29 file</span><br><span class="line"></span><br><span class="line"><span class="comment">#针对目录设定权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir dir</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 777 dir/    #修改目录允许所有人访问</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod -R 755 dir/ #修改目录及子目录权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d dir/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Apr 13 03:34 dir/</span><br></pre></td></tr></table></figure><h3 id="2-权限设置案例"><a href="#2-权限设置案例" class="headerlink" title="2. 权限设置案例"></a>2. 权限设置案例</h3><blockquote><p>针对 hr 部门的访问目录 /home/hr 设置权限，要求如下:</p><ol><li>root 用户和 hr 组的员工可以读、写、执行</li><li>其他用户没有任何权限</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># groupadd hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd hr01 -G hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd hr02 -G hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir /home/hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># chgrp hr /home/hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 770 /home/hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d /home/hr</span></span><br><span class="line">drwxrwx--- 2 root hr 6 Apr 13 03:26 /home/hr</span><br></pre></td></tr></table></figure><h3 id="3-权限对文件及目录的影响"><a href="#3-权限对文件及目录的影响" class="headerlink" title="3.权限对文件及目录的影响"></a>3.权限对文件及目录的影响</h3><blockquote><p>在 Linux 中权限对文件和对目录的影响是有不同区别的。</p></blockquote><table><thead><tr><th align="left">权限</th><th align="left">对文件的影响</th><th align="left">对目录的影响</th></tr></thead><tbody><tr><td align="left">读取权限（r）</td><td align="left">具有读取 \ 阅读文件内容权限</td><td align="left">具有浏览目录及子目录</td></tr><tr><td align="left">写入权限（w）</td><td align="left">具有新增、修改文件内容的权限</td><td align="left">具有增加和删除目录内文件</td></tr><tr><td align="left">执行权限（x）</td><td align="left">具有执行文件的权限</td><td align="left">具有访问目录的内容 (取决于目录中文件权限)</td></tr></tbody></table><h4 id="1-总结-rwx-对文件的影响"><a href="#1-总结-rwx-对文件的影响" class="headerlink" title="1.总结 rwx 对文件的影响"></a>1.总结 rwx 对文件的影响</h4><blockquote><p>读取权限（r）具有读取 \ 阅读文件内容权限</p><ul><li>1.只能使用查看类命令 cat、head、tail、less、more</li></ul><p>写入权限（w）具有新增、修改文件内容的权限</p><ul><li>1.使用 vim 编辑会提示权限拒绝，但可强制保存，会覆盖文件的所有内容</li><li>2.使用 echo 命令重定向的方式可以往文件内写入数据，&gt;&gt; 可以进行追加</li><li>3.不能删除文件，因为删除文件看的不是文件的属性，需要看上级目录是否有 w 的权限</li></ul><p>执行权限（x）具有执行文件的权限</p><ul><li>1.执行权限什么用都没有</li><li>2.如果普通用户需要执行文件，需要配合 r 权限</li></ul></blockquote><h4 id="2-总结-rwx-对目录的影响"><a href="#2-总结-rwx-对目录的影响" class="headerlink" title="2.总结 rwx 对目录的影响"></a>2.总结 rwx 对目录的影响</h4><blockquote><p>读取权限（r），如果目录只有 r 权限：具有浏览目录及子目录权限</p><ul><li>1.可以使用 ls 命令浏览目录及子目录， 但同时也会提示权限拒绝</li><li>2.使用 ls -l 命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名<br><mark>总结：目录只有 r 权限，仅仅只能浏览内的文件名，无其他操作权限</mark></li></ul><p>写入权限（w），如果目录只有 w 权限：具有增加、删除或修改目录内文件名权限 (需要 x 权限配合)<br><mark>注意：如果目录有 w 权限，可以在目录内创建文件，删除文件 (跟文件本身权限无关)<br>不能进入目录、不能复制目录、不能删除目录、不能移动目录</mark></p><p>执行权限（x），如果目录只有 x 权限</p><ul><li>1.只能进入目录</li><li>2.不能浏览、复制、移动、删除</li></ul></blockquote><h2 id="4-属主属组设置"><a href="#4-属主属组设置" class="headerlink" title="4. 属主属组设置"></a>4. 属主属组设置</h2><blockquote><p>在 Linux 中如何变更一个文件或者一个资源的属主和属组呢，可以使用 chown、chgrp 命令实现。</p><p>chown 能设置属主和属组，chgrp 仅能设置属组，推荐使用 chown</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chown 更改属主以及属组 -R：递归修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备环境，创建文件和目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir dir/test1 &amp;&amp; touch dir/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例1: 修改所属主为bin</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown bin dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 修改所属组为adm</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown .adm dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3: 递归修改目录及目录下的所有文件属主和属组</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown -R root.root dir/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 基本权限</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 基本权限" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 用户管理</title>
    <link href="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-03T16:15:00.000Z</published>
    <updated>2020-08-23T03:03:53.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h2><h3 id="1-什么是用户？"><a href="#1-什么是用户？" class="headerlink" title="1.什么是用户？"></a>1.什么是用户？</h3><blockquote><p>用户，是指使用电脑或网络服务的人，通常拥有一个用户账号，并以用户名识别。<br>Windows 系统是一个单用户的操作系统，因为在同一时刻，只能在一个系统内登陆一个用户，开启多个进程，简称为单用户多任务。<br>Linux 系统，是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统，简言之，Linux 支持同一时刻多个用户同时登陆。</p></blockquote><h3 id="2-Linux-下的用户作用，或者说我们为什么要创建用户？"><a href="#2-Linux-下的用户作用，或者说我们为什么要创建用户？" class="headerlink" title="2. Linux 下的用户作用，或者说我们为什么要创建用户？"></a>2. Linux 下的用户作用，或者说我们为什么要创建用户？</h3><blockquote><ul><li>1.系统上的每一个进程 (运行的程序)，都需要一个特定的用户运行</li><li>2.通常在公司是使用普通用户管理服务器，因为 root 权限过大，容易造成故障。</li></ul></blockquote><h3 id="3-如何查看系统中所存在的用户"><a href="#3-如何查看系统中所存在的用户" class="headerlink" title="3. 如何查看系统中所存在的用户"></a>3. 如何查看系统中所存在的用户</h3><blockquote><ul><li><strong>1.查看当前登录的用户信息</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># id    #查看当前所登陆的用户信息</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@demo ~]<span class="comment"># id jack #查看其它用户的信息</span></span><br><span class="line">uid=1000(jack) gid=1000(jack) groups=1000(jack)</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>2.每一个进程都会由一个用户身份运行</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ps aux|less</span></span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker/u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker/0:2]</span><br></pre></td></tr></table></figure><h3 id="4-用户相关信息存储位置"><a href="#4-用户相关信息存储位置" class="headerlink" title="4. 用户相关信息存储位置"></a>4. 用户相关信息存储位置</h3><blockquote><p>Linux 系统会将用户的信息存放在两个文件中：</p><ul><li>1./etc/passwd，记录了用户的信息，但没有密码信息</li><li>2./etc/shadow，记录了用户密码</li></ul><p><mark>【注意：两个文件非常的重要，不要轻易删除与修改】</mark></p></blockquote><h4 id="1-etc-passwd-配置文件详解"><a href="#1-etc-passwd-配置文件详解" class="headerlink" title="1./etc/passwd 配置文件详解"></a>1./etc/passwd 配置文件详解</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/1.jpg" alt="1"></p><h4 id="2-etc-shadow-配置文件详解"><a href="#2-etc-shadow-配置文件详解" class="headerlink" title="2. /etc/shadow 配置文件详解"></a>2. /etc/shadow 配置文件详解</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/2.jpg" alt="2"></p><h3 id="5-用户的分类（约定、规范）"><a href="#5-用户的分类（约定、规范）" class="headerlink" title="5.用户的分类（约定、规范）"></a>5.用户的分类（约定、规范）</h3><table><thead><tr><th align="left">用户 UID</th><th align="left">系统含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">超级管理员，最高权限，有着极强的破坏能力</td></tr><tr><td align="left">1~200</td><td align="left">系统用户，用来运行系统自带的进程，默认已创建</td></tr><tr><td align="left">201~999</td><td align="left">系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td></tr><tr><td align="left">1000+</td><td align="left">普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td></tr></tbody></table><h2 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h2><h3 id="1-用户创建（useradd、adduser）"><a href="#1-用户创建（useradd、adduser）" class="headerlink" title="1.用户创建（useradd、adduser）"></a>1.用户创建（useradd、adduser）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    选项:</span><br><span class="line">    -u 指定用户的UID,不允许冲突</span><br><span class="line">    -g 指定用户所属的用户组</span><br><span class="line">    -G 指定用户所属的附加组,逗号隔开可添加多个附加组</span><br><span class="line">    -d 指定用户家目录</span><br><span class="line">    -s 指定用户的bash shell</span><br><span class="line">    -c 指定用户注释信息</span><br><span class="line">    -M 给创建的用户不创建家目录</span><br><span class="line">    -r 创建系统账户，默认无家目录</span><br><span class="line"></span><br><span class="line">1.创建<span class="built_in">test</span>用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd sa</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd students</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s /bin/bash test</span></span><br><span class="line"></span><br><span class="line">2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span><br><span class="line">[root@demo ~]<span class="comment"># useradd mysql -M -s /sbin/nologin</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd -r dba -s /sbin/nologin</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>【注意: adduser 命令软链接指向 useradd 命令】</p>          </div><h3 id="2-修改用户信息（usermod）"><a href="#2-修改用户信息（usermod）" class="headerlink" title="2. 修改用户信息（usermod）"></a>2. 修改用户信息（usermod）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    选项:</span><br><span class="line">    -u 指定要修改用户的UID</span><br><span class="line">    -g 指定要修改用户基本组</span><br><span class="line">    -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span><br><span class="line">    -d 指定要修改用户家目录</span><br><span class="line">    -s 指定要修改用户的bash shell</span><br><span class="line">    -c 指定要修改用户注释信息</span><br><span class="line">    -l 指定要修改用户的登陆名</span><br><span class="line">    -L 指定要锁定的用户</span><br><span class="line">    -U 指定要解锁的用户</span><br><span class="line"></span><br><span class="line">1.检查此前创建的用户信息</span><br><span class="line">[root@demo ~]<span class="comment"># grep &quot;test&quot; /etc/passwd</span></span><br><span class="line"><span class="built_in">test</span>:x:5001:503:2019 new student:/home/<span class="built_in">test</span>:/bin/bash</span><br><span class="line"></span><br><span class="line">2.修改<span class="built_in">test</span>用户uid、gid，附加组</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -g 5008 network_sa</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -g 5009 devops</span></span><br><span class="line">[root@demo ~]<span class="comment"># usermod -u 6001 -g5008 -a -G 5009 test</span></span><br><span class="line"></span><br><span class="line">3.修改<span class="built_in">test</span>用户的注释信息, 用户家目录, 登录shell, 登录名</span><br><span class="line">[root@demo ~]<span class="comment"># usermod -c &quot;2019 new student&quot; -md /abc -s /bin/sh -l abc test</span></span><br><span class="line"></span><br><span class="line">检查是否修改成功!!!</span><br><span class="line">[root@demo ~]<span class="comment"># grep &quot;abc&quot; /etc/passwd</span></span><br><span class="line">abc:x:6001:5008:2019 new student:/abc:/bin/sh</span><br><span class="line">[root@demo ~]<span class="comment"># id abc</span></span><br><span class="line">uid=6001(abc) gid=5008(network_sa) groups=5008(network_sa),1000(sa),5009(devops)</span><br><span class="line">[root@demo ~]<span class="comment"># ll -d /abc/</span></span><br><span class="line">drwx------ 2 abc network_sa 62 Aug 17 17:50 /abc/</span><br><span class="line"></span><br><span class="line">4.锁定用户[扩展]</span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;123&quot; |passwd --stdin abc</span></span><br><span class="line">[root@demo ~]<span class="comment"># usermod -L abc  #锁定后会无法登陆系统</span></span><br><span class="line"></span><br><span class="line">5.解锁用户[扩展]</span><br><span class="line">[root@demo ~]<span class="comment"># usermod -U abc</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>【注意：使用 who、whoami、w 检查用户登陆情况】</p>          </div><h3 id="3-删除账户-userdel"><a href="#3-删除账户-userdel" class="headerlink" title="3. 删除账户 (userdel)"></a>3. 删除账户 (userdel)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line">选项 -r 删除用户同时删除它的家目录</span><br><span class="line"></span><br><span class="line">1.删除user1用户，但不删除用户家目录和 mail spool</span><br><span class="line">[root@demo ~]<span class="comment"># userdel user1</span></span><br><span class="line"></span><br><span class="line">2.-r参数可以连同用户家目录一起删除(慎用)</span><br><span class="line">[root@demo ~]<span class="comment"># userdel -r user1</span></span><br></pre></td></tr></table></figure><h2 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h2><h3 id="1-用户创建流程"><a href="#1-用户创建流程" class="headerlink" title="1.用户创建流程"></a>1.用户创建流程</h3><blockquote><p>useradd 创建用户时，系统会以 /etc/login.defs、/etc/defaults/useradd 两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖 /etc/login.defs、/etc/defaults/useradd 文件默认配置，如未指定则使用默认。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/login.defs</span></span><br><span class="line">MAIL_DIR    /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_eHOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/default/useradd</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home      把用户的家目录建在/home中。</span><br><span class="line">INACTIVE=-1     是否启用账号过期停权,-1表示不启用。</span><br><span class="line">EXPIRE=         账号终止日期,不设置表示不启用。</span><br><span class="line">SHELL=/bin/bash 新用户默认所有的shell类型。</span><br><span class="line">SKEL=/etc/skel  配置新用户家目录的默认文件存放路径。</span><br><span class="line">CREATE_MAIL_SPOOL=yes   创建mail文件。</span><br></pre></td></tr></table></figure><h3 id="2-用户创建时的环境变量"><a href="#2-用户创建时的环境变量" class="headerlink" title="2.用户创建时的环境变量"></a>2.用户创建时的环境变量</h3><blockquote><p>当使用 useradd 创建用户时，创建的用户家目录下会存在 .bash_* 环境变量相关的文件，这些环境变量文件默认从 /etc/skel 目录中拷贝。这个默认拷贝环境变量位置是由 /etc/defaults/useradd 配置文件中定义的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span><br><span class="line"></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@demo ~]<span class="comment">#   重新连接即可恢复</span></span><br></pre></td></tr></table></figure><h3 id="3-用户密码设定与变更"><a href="#3-用户密码设定与变更" class="headerlink" title="3. 用户密码设定与变更"></a>3. 用户密码设定与变更</h3><blockquote><p>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用 passwd 命令。建议密码复杂度高一些、长度大于 10、出现各种特殊字符、无任何规律 (不要出现名字，电话，生日等)</p></blockquote><div class="note danger">            <p>【注意事项】</p><ul><li>1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须 8 位字符</li><li>2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</li></ul>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.使用passwd命令修改用户密码</span><br><span class="line"><span class="comment"># passwd        #给当前用户修改密码</span></span><br><span class="line"><span class="comment"># passwd root   #给root用户修改密码</span></span><br><span class="line"><span class="comment"># passwd jack #给oldboy用户修改密码，普通用户只能自己修改自己</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.验证如下几项指标</span><br><span class="line"><span class="comment"># passwd                #root管理员用户登陆，修改root用户密码</span></span><br><span class="line"><span class="comment"># passwd qwe            #root用户登陆，修改其他用户的密码</span></span><br><span class="line">$ passwd root           <span class="comment">#普通用户修改root管理员密码</span></span><br><span class="line"><span class="comment"># echo &quot;123&quot; | passwd --stdin qwe    #非交互式修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.系统内置变量生成随机字符串</span><br><span class="line">[root@demo ~]<span class="comment"># echo $RANDOM|md5sum|cut -c 1-10</span></span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@demo ~]<span class="comment"># echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin qwe</span></span><br><span class="line"></span><br><span class="line">4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span><br><span class="line">[root@demo ~]<span class="comment"># yum install -y expect   //需要安装扩展包</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span></span><br><span class="line">|K&amp;13bR)i/</span><br></pre></td></tr></table></figure><h2 id="4-用户组的管理"><a href="#4-用户组的管理" class="headerlink" title="4.用户组的管理"></a>4.用户组的管理</h2><h3 id="1-什么是用户组？"><a href="#1-什么是用户组？" class="headerlink" title="1.什么是用户组？"></a>1.什么是用户组？</h3><blockquote><p>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</p></blockquote><h3 id="2-组的类别"><a href="#2-组的类别" class="headerlink" title="2.组的类别"></a>2.组的类别</h3><blockquote><ul><li>基本组，用户只能有一个基本组，创建时可通过 - g 指定，如未指定则创建一个默认的组 (与用户同名)</li><li>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/3.jpg" alt="3"></li></ul></blockquote><h3 id="3-组相关文件"><a href="#3-组相关文件" class="headerlink" title="3.组相关文件"></a>3.组相关文件</h3><blockquote><p>组账户信息保存在 /etc/group 和 /etc/gshadow 两个文件中，重点关注 group</p></blockquote><h4 id="1-etc-group-配置文件解释如下图"><a href="#1-etc-group-配置文件解释如下图" class="headerlink" title="1./etc/group 配置文件解释如下图"></a>1./etc/group 配置文件解释如下图</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/4.jpg" alt="4"></p><h4 id="2-etc-gshadow-配置文件解释如下图"><a href="#2-etc-gshadow-配置文件解释如下图" class="headerlink" title="2./etc/gshadow 配置文件解释如下图"></a>2./etc/gshadow 配置文件解释如下图</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/5.jpg" alt="5"></p><h3 id="4-组相关命令"><a href="#4-组相关命令" class="headerlink" title="4.组相关命令"></a>4.组相关命令</h3><h4 id="1-使用-groupadd-命令新增组，groupadd-g-GID-groupname"><a href="#1-使用-groupadd-命令新增组，groupadd-g-GID-groupname" class="headerlink" title="1.使用 groupadd 命令新增组，groupadd [-g GID] groupname"></a>1.使用 groupadd 命令新增组，groupadd [-g GID] groupname</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建基本组, 不指定gid</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd no_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line">创建基本组, 指定gid为5555</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -g 5555 yes_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line">创建系统组，gid从201-999</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -r sys_group</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure><h4 id="2-使用-groupmod-命令新增组"><a href="#2-使用-groupmod-命令新增组" class="headerlink" title="2. 使用 groupmod 命令新增组"></a>2. 使用 groupmod 命令新增组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-g 修改组gid</span><br><span class="line">[root@demo ~]<span class="comment"># groupmod -g 1111 no_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line">-n 修改组名称</span><br><span class="line">[root@demo ~]<span class="comment"># groupmod -n active_group yes_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure><h4 id="3-groupdel-删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。"><a href="#3-groupdel-删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。" class="headerlink" title="3.groupdel 删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。"></a>3.groupdel 删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">删除组</span><br><span class="line">[root@demo ~]<span class="comment"># groupdel active_group</span></span><br><span class="line"></span><br><span class="line">删除用户附加组</span><br><span class="line">[root@demo ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei),5004(devops)</span><br><span class="line">[root@demo ~]<span class="comment"># groupdel devops</span></span><br><span class="line">[root@demo ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line">无法删除用户基本组</span><br><span class="line">[root@demo ~]<span class="comment"># groupdel network_sa</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">&#x27;bgx_xuliangwei&#x27;</span></span><br><span class="line">只有删除用户或者用户变更基本后,方可删除该组</span><br></pre></td></tr></table></figure><h4 id="4-使用-gpasswd-设置组密码-扩展，可以不会"><a href="#4-使用-gpasswd-设置组密码-扩展，可以不会" class="headerlink" title="4. 使用 gpasswd 设置组密码 [扩展，可以不会]"></a>4. 使用 gpasswd 设置组密码 [扩展，可以不会]</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># groupadd devops</span></span><br><span class="line">[root@demo ~]<span class="comment"># gpasswd devops</span></span><br><span class="line">Changing the password <span class="keyword">for</span> group devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br></pre></td></tr></table></figure><h4 id="5-使用-newgrp-命令切换基本组身份-扩展，可以不会"><a href="#5-使用-newgrp-命令切换基本组身份-扩展，可以不会" class="headerlink" title="5. 使用 newgrp 命令切换基本组身份 [扩展，可以不会]"></a>5. 使用 newgrp 命令切换基本组身份 [扩展，可以不会]</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.检查账户信息</span><br><span class="line">[root@demo ~]<span class="comment"># useradd test1</span></span><br><span class="line">[root@demo ~]<span class="comment"># id test1</span></span><br><span class="line">uid=1069(test1) gid=5005(test1) groups=5005(test1)</span><br><span class="line"></span><br><span class="line">2.切换普通用户</span><br><span class="line">[root@demo ~]<span class="comment"># su - test1</span></span><br><span class="line"></span><br><span class="line">3.创建新文件,查看文件的属主和属组</span><br><span class="line">[test1@demo ~]$ touch file_roots</span><br><span class="line">[test1@demo ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 test1 test1 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line">4.使用newgrp切换到devops组</span><br><span class="line">[test1@demo ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line">5.创建文件，检查属主和属组</span><br><span class="line">[test1@demo ~]$ touch file_test</span><br><span class="line">[test1@demo ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 test1 test1 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 test1 devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure><h2 id="5-用户如何提权"><a href="#5-用户如何提权" class="headerlink" title="5. 用户如何提权"></a>5. 用户如何提权</h2><blockquote><p>一般公司的服务器对外都是禁止 root 用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？当我们使用普通用户执行 /sbin 目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用 root 用户直接登录系统，同时又保证普通用户能完成日常工作？</p><p>可使用如下两种方式:</p><ul><li><strong>1.su 切换用户，使用普通用户登录，然后使用 su 命令切换到 root。</strong><ul><li><strong>优点：简单</strong></li><li><strong>缺点：需要知道 root 密码</strong></li></ul></li><li><strong>2.sudo 提权，当需要使用 root 权限时进行提权，而无需切换至 root 用户。</strong><ul><li><strong>优点：安全、方便</strong></li><li><strong>缺点：复杂</strong></li></ul></li></ul></blockquote><h3 id="1-su-身份切换"><a href="#1-su-身份切换" class="headerlink" title="1.su 身份切换"></a>1.su 身份切换</h3><blockquote><p>在使用 su 切换前，我们需要了解一些预备知识，比如 shell 分类、环境变量配置文件有哪些</p><ul><li><p>1.Linux Shell 主要分为如下几类</p><ul><li>交互式 shell，等待用户输入执行的命令 (终端操作，需要不断提示)</li><li>非交互式 shell，执行 shell 脚本，脚本执行结束后 shell 自动退出</li><li>登陆 shell，需要输入用户名和密码才能进入 Shell，日常接触的最多的一种</li><li>非登陆 shell，不需要输入用户和密码就能进入 Shell, 比如运行 bash 会开启一个新的会话窗口</li></ul></li><li><p>2.bash shell 配置文件介绍 (文件主要保存用户的工作环境)</p><ul><li>个人配置文件：~/.bash_profile ~/.bashrc</li><li>全局配置文件：/etc/profile/etc/profile.d/*.sh/etc/bashrc</li><li>profile 类文件，设定环境变量，登陆前运行的脚本和命令</li><li>bashrc 类文件，设定本地变量，定义命令别名<br><mark>【注意： 如果全局配置和个人配置产生冲突，以个人配置为准】</mark></li></ul></li><li><p>3.登陆系统后，环境变量配置文件的应用顺序是？</p><ul><li>登录式 shell 配置文件执行顺序：/etc/profile—&gt;/etc/profile.d/*.sh—&gt;~/.bash_profile—&gt;~/.bashrc–&gt;/etc/bashrc</li><li>非登陆式 shell 配置文件执行顺序: ~/.bashrc—&gt;/etc/bashrc—&gt;/etc/profile.d/*.sh<br><mark>【注意： 验证使用 echo 在每行添加一个输出即可】</mark></li></ul></li><li><p>4.su 命令切换用户</p><ul><li>su - username 属于登陆式 shell</li><li>su username 属于非登陆式 shell，区别在于加载的环境变量不一样。</li><li>普通用户 su - 可以直接切换至 root 用户，但需要输入 root 用户的密码。</li><li>超级管理员 root 用户，使用 su - username 切换普通用户不需要输入任何密码。</li></ul></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.普通用户使用su切换root</span></span><br><span class="line">[test1@demo ~]$ su</span><br><span class="line">密码：         <span class="comment">#输入root的密码</span></span><br><span class="line">[root@demo test1]<span class="comment"># pwd</span></span><br><span class="line">/home/test1</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.普通用户使用su -切换到root，会加载root的环境变量</span></span><br><span class="line">[test1@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - test1 -c &#x27;ifconfig&#x27;</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - test1 -c &#x27;ls ~&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-sudo-提权"><a href="#2-sudo-提权" class="headerlink" title="2.sudo 提权"></a>2.sudo 提权</h3><blockquote><p>su 命令在切换用户身份时，如果每个普通用户都能拿到 root 用户的密码，当其中某个用户不小心泄漏了 root 的密码，那系统会变得非常不安全，为了改进这个问题，从而产生了 sudo 这个命令。</p><p>其实 sudo 就相当于给某个普通用户埋下了浩克 (hulk) 的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。</p></blockquote><h4 id="1-如何快速埋下-hulk-的种子呢？"><a href="#1-如何快速埋下-hulk-的种子呢？" class="headerlink" title="1. 如何快速埋下 hulk 的种子呢？"></a>1. 如何快速埋下 hulk 的种子呢？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.快速配置sudo方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># usermod bgx -G wheel            #wheel组类似于一个管理员的组</span></span><br><span class="line">[root@demo ~]$ sudo tail -f /var/<span class="built_in">log</span>/secure    <span class="comment">#sudo审计日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.一般正常配置sudo方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># #visudo =&gt; vim /etc/sudoers</span></span><br><span class="line"><span class="comment">#1.用户名  2.主机名=(角色名)    4.命令名</span></span><br><span class="line">aaa       ALL=(ALL)          /usr/bin/yum,/usr/sbin/useradd   <span class="comment">#允许使用sudo执行命令</span></span><br><span class="line">bbb       ALL=(ALL)          NOPASSWD:/bin/cp, /bin/rm   <span class="comment">#NOPASSWD不需要使用密码</span></span><br></pre></td></tr></table></figure><h4 id="2-埋下了-hulk-种子后又如何提权使用呢？"><a href="#2-埋下了-hulk-种子后又如何提权使用呢？" class="headerlink" title="2. 埋下了 hulk 种子后又如何提权使用呢？"></a>2. 埋下了 hulk 种子后又如何提权使用呢？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.切换普通用户</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - aaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.检查普通用户能提权的命令</span></span><br><span class="line">[aaa@demo ~]$ sudo -l</span><br><span class="line">User aaa may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.普通用户正常情况下是无法删除opt目录的</span></span><br><span class="line">[aaa@demo ~]$ rm -rf /opt/</span><br><span class="line">rm: cannot remove `/opt: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用sudo提权，需要输入普通用户的密码。</span></span><br><span class="line">[aaa@demo ~]$ sudo rm -rf /opt</span><br></pre></td></tr></table></figure><h4 id="3-提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？"><a href="#3-提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？" class="headerlink" title="3. 提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？"></a>3. 提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</h4><blockquote><ul><li>第一种方式：使用 sudo 中自带的别名操作，将多个用户定义成一个组，这个组只有 sudo 认可</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># visudo    #也可以使用vi /etc/sudoers来配置</span></span><br><span class="line"><span class="comment"># 1.使用sudo定义分组,这个分组跟系统的group没什么关系!</span></span><br><span class="line">User_Alias OPS = aaa,alex</span><br><span class="line">User_Alias DEV = bbb,py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义可执行的命令组,便于后续调用</span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用sudo开始分配权限</span></span><br><span class="line">OPS  ALL=(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.登陆对应的用户使用 sudo -l 验证权限</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>第二种方式：使用 groupadd 添加组，然后给组分配 sudo 的权限，如果有新用户加入，直接将用户添加到该组</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.添加两个真实的系统组,  group_dev group_op</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd group_dev</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_a -G group_dev</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_b -G group_dev</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_c -G group_op</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_d -G group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.记得添加密码</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_a</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_b</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_c</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.在sudo中配置规则</span></span><br><span class="line">[root@demo ~]<span class="comment"># visudo</span></span><br><span class="line">    Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">    Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">    Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">    Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL=(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.检查sudo是否配置有错</span></span><br><span class="line">[root@demo ~]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.检查user_a,和user_d的sudo权限</span></span><br><span class="line">[user_a@demo ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on demo:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum</span><br><span class="line"></span><br><span class="line">[user_d@demo ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on demo:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum, /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br></pre></td></tr></table></figure><h4 id="3-sudo-命令的执行流程"><a href="#3-sudo-命令的执行流程" class="headerlink" title="3.sudo 命令的执行流程:"></a>3.sudo 命令的执行流程:</h4><blockquote><ol><li>普通用户执行 sudo 命令时，会检查 /var/db/sudo 是否存在时间戳缓存</li><li>如果存在则不需要输入密码，否则需要输入用户与密码</li><li>输入密码会检测该用户是否拥有该权限</li><li>如果有则执行，否则报错退出</li></ol></blockquote><h3 id="4-sudo-不支持系统内置命令"><a href="#4-sudo-不支持系统内置命令" class="headerlink" title="4.sudo 不支持系统内置命令"></a>4.sudo 不支持系统内置命令</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h4><blockquote><p>我想要 <code>cd</code> 到 <code>/etc/docker</code>，但是它给我一个权限不够的错误，然后，我想到使用 <code>sudo cd /etc/docker</code> 时，它告诉我 <code>sudo: cd：</code>找不到命令。</p><p>于是，就去上网找了下原因。</p></blockquote><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h4><blockquote><p>cd 不是一个应用程序而是 Linux 内建的命令，而 sudo 仅仅只对应用程序起作用。</p><p>sudo foo 只意味着以 root 权限运行 foo 程序</p><p>所以，sudo cd /etc/docker 会报 sudo: cd：找不到命令。</p><p>验证</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p>【注意】：关于 cd 是不是内建命令，OS X 10.8 中 cd 不是内建命令（可以参考 what-is-the-point-of-the-cd-external-command），具体其他的版本的 OS X 我就不清楚了，大部分的 Linux 系列（Ubuntu、CentOS 和 ArchLinux）中 cd 都是内建命令</p>          </div><h4 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h4><ul><li>使用 <code>sudo -i</code> 命令提升用户权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># sudo -i</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /etc/docker</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>sudo -s</code> 命令打开特殊 shell</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># sudo -s</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /etc/docker</span></span><br></pre></td></tr></table></figure><blockquote><p>上面都可以使用 exit 命令退出，也可以使用 Ctrl+D 快捷键退出！</p></blockquote>]]></content>
    
    
    <summary type="html">Linux 用户管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 用户管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件编辑</title>
    <link href="https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/"/>
    <id>https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/</id>
    <published>2018-01-02T17:30:00.000Z</published>
    <updated>2020-08-23T02:59:20.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Linux-vi-vim"><a href="#1-Linux-vi-vim" class="headerlink" title="1.Linux vi/vim"></a>1.Linux vi/vim</h2><blockquote><p>所有的 Unix Like (类 UNIX) 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。<br>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p></blockquote><h2 id="2-VIM-基本概述"><a href="#2-VIM-基本概述" class="headerlink" title="2.VIM 基本概述"></a>2.VIM 基本概述</h2><h3 id="1-什么是-vim？"><a href="#1-什么是-vim？" class="headerlink" title="1.什么是 vim？"></a>1.什么是 vim？</h3><blockquote><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。<br>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。<br>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><ul><li>vim键盘图</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/1.jpg" alt="1"></p></blockquote><h3 id="2-vi-vim-的使用"><a href="#2-vi-vim-的使用" class="headerlink" title="2.vi/vim 的使用"></a>2.vi/vim 的使用</h3><blockquote><p>基本上 vi/vim 共分为三种模式，分别是:</p><ul><li>1.命令模式（Command mode）</li><li>2.输入模式（Insert mode）</li><li>3.底线命令模式（Last line mode）</li></ul><p>这三种模式的作用分别是：<br><strong>1.命令模式：</strong><br>用户刚刚启动 vi/vim，便进入了命令模式。<br>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一&gt;个字符，i 被当作了一个命令。<br>以下是常用的几个命令：<br><strong>i 切换到输入模式，以输入字符。</strong><br><strong>x 删除当前光标所在处的字符。</strong><br><strong>：切换到底线命令模式，以在最底一行输入命令。</strong><br><strong>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</strong><br>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><p><strong>2.输入模式：</strong><br>在命令模式下按下 i 就进入了输入模式。<br>在输入模式中，可以使用以下按键：<br><strong>字符按键以及 Shift 组合，输入字符</strong><br><strong>ENTER，回车键，换行</strong><br><strong>BACK SPACE，退格键，删除光标前一个字符</strong><br><strong>DEL，删除键，删除光标后一个字符</strong><br><strong>方向键，在文本中移动光标</strong><br><strong>HOME/END，移动光标到行首 / 行尾</strong><br><strong>Page Up/Page Down，上 / 下翻页</strong><br><strong>Insert，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</strong><br><strong>ESC，退出输入模式，切换到命令模式</strong></p><p><strong>3.底线命令模式：</strong><br>在命令模式下按下:（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>在底线命令模式中，基本的命令有（已经省略了冒号）：<br><strong>q 退出程序</strong><br><strong>w 保存文件</strong><br><strong>按 ESC 键可随时退出底线命令模式。</strong></p><p>vim/vi 三种工作模式，如下图所示：<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/2.jpg" alt="2"></p></blockquote><h2 id="3-vi-vim-使用范例"><a href="#3-vi-vim-使用范例" class="headerlink" title="3.vi/vim 使用范例"></a>3.vi/vim 使用范例</h2><ul><li><strong>1.一般模式</strong></li></ul><table><thead><tr><th align="left">移动光标的方法</th><th align="left"></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键 (←)</td><td align="left">光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键 (↓)</td><td align="left">光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键 (↑)</td><td align="left">光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键 (→)</td><td align="left">光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数 (数字) 后，按下动作即可！</td><td align="left"></td></tr><tr><td align="left">[Ctrl] + [f]</td><td align="left">屏幕『向下』移动一页，相当于 [Page Down] 按键 <mark>(常用)</mark></td></tr><tr><td align="left">[Ctrl] + [b]</td><td align="left">屏幕『向上』移动一页，相当于 [Page Up] 按键 <mark>(常用)</mark></td></tr><tr><td align="left">[Ctrl] + [d]</td><td align="left">屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td align="left">屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td align="left">光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td align="left">光标移动到非空格符的上一行</td></tr><tr><td align="left">n</td><td align="left">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="left">0</td><td align="left">或功能键 [Home]    这是数字『 0 』：移动到这一行的最前面字符处 <mark>(常用)</mark></td></tr><tr><td align="left">$</td><td align="left">或功能键 [End]    移动到这一行的最后面字符处 <mark>(常用)</mark></td></tr><tr><td align="left">H</td><td align="left">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td align="left">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td align="left">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td align="left">移动到这个文档的最后一行 <mark>(常用)</mark></td></tr><tr><td align="left">nG</td><td align="left">n 为数字。移动到这个文档的第 n 行。例如 20G 则会移动到这个文档的第 20 行 (可配合 :set nu)</td></tr><tr><td align="left">gg</td><td align="left">移动到这个文档的第一行，相当于 1G 啊！ <mark>(常用)</mark></td></tr><tr><td align="left">n</td><td align="left">n 为数字。光标向下移动 n 行 <mark>(常用)</mark></td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th></th></tr></thead><tbody><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ <mark>(常用)</mark></td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行？vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td></tr><tr><td align="left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/</td></tr><tr><td align="left">:1,$s/word1/word2/g 或 :% s/word1/word2/g</td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！<mark>(常用)</mark></td></tr><tr><td align="left">:1,$s/word1/word2/gc 或 :% s/word1/word2/gc</td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！<mark>(常用)</mark></td></tr></tbody></table><table><thead><tr><th align="left">删除、复制、粘贴</th><th></th></tr></thead><tbody><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符 (相当于 [backspace] 亦即是退格键) <mark>(常用)</mark></td></tr><tr><td align="left">nx</td><td>n为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行 <mark>(常用)</mark></td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 <mark>(常用)</mark></td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行 <mark>(常用)</mark></td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行 <mark>(常用)</mark></td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 <mark>(常用)</mark></td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[10cj]</td></tr><tr><td align="left">u</td><td>复原前一个动作。<mark>(常用)</mark></td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。<mark>(常用)</mark></td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ <mark>(常用)</mark></td></tr></tbody></table><ul><li><strong>2.编辑模式</strong></li></ul><table><thead><tr><th align="left">进入编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式 (Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 <mark>(常用)</mark></td></tr><tr><td align="left">a, A</td><td>进入输入模式 (Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。<mark>(常用)</mark></td></tr><tr><td align="left">o, O</td><td>进入输入模式 (Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！<mark>(常用)</mark></td></tr><tr><td align="left">r, R</td><td>进入取代模式 (Replace mode)：r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；<mark>(常用)</mark></td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！</td><td></td></tr><tr><td align="left">特别注意的是，我们上面也提过了，你想要在文档里面输入字符时，一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中 <mark>(常用)</mark></td></tr></tbody></table><ul><li><strong>3.命令行模式</strong></li></ul><table><thead><tr><th align="left">指令行的存储、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘中 <mark>(常用)</mark></td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该文档。不过，到底能不能写入， 还是跟你对该文档的文档权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi <mark>(常用)</mark></td></tr><tr><td align="left">:q!</td><td>若曾修改过文档，又不想储存，使用！为强制离开不储存文档。注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 <mark>(常用)</mark></td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于 (保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 :q!。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个文档（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个文档的数据。亦即将 『filename』 这个文档内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个文档。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文档信息！</td></tr></tbody></table><ul><li><strong>4.视图模式</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">        1.插入:按<span class="built_in">shift</span>+i进入编辑模式,输入<span class="comment">#,结束按ESC键</span></span><br><span class="line">        2.删除:选中内容后，按x或者d键删除</span><br><span class="line">        3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="built_in">shift</span>+v 进入可视行模式，选中整行内容</span><br><span class="line">        1.复制:选中行内容后按y键及可复制。</span><br><span class="line">        2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-vim-扩展"><a href="#4-vim-扩展" class="headerlink" title="4.vim 扩展"></a>4.vim 扩展</h2><h3 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1. 环境变量临时生效"></a>1. 环境变量临时生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu             <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> ic             <span class="comment">#忽略大小写, 在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai             <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list           <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line">:<span class="built_in">set</span> no[nu|ic|ai…]  <span class="comment">#取消临时设定的变量</span></span><br></pre></td></tr></table></figure><h3 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量 (优先级高) /etc/vimrc 全局环境变量"></a>2.环境变量永久生效。~/.vimrc 个人环境变量 (优先级高) /etc/vimrc 全局环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim  ~/.vimrc #当下次再打开文件自动显示行号并忽略大小写</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span></span><br><span class="line"><span class="comment">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span></span><br></pre></td></tr></table></figure><h3 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3. 如何同时编辑多个文件"></a>3. 如何同时编辑多个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim -o file1 file2  <span class="comment">#水平分割</span></span><br><span class="line">vim -O file1 file2  <span class="comment">#垂直分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ctrl+ww 文件间切换</span></span><br></pre></td></tr></table></figure><h3 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4. 相同文件之间差异对比，通常用于对比修改前后差异"></a>4. 相同文件之间差异对比，通常用于对比修改前后差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># diff      #文件对比   </span></span><br><span class="line"><span class="comment"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span></span><br></pre></td></tr></table></figure><h3 id="5-如果-VIM-非正常退出-（ctrl-z）挂起或强制退出终端没关闭-VIM-后"><a href="#5-如果-VIM-非正常退出-（ctrl-z）挂起或强制退出终端没关闭-VIM-后" class="headerlink" title="5.如果 VIM 非正常退出 （ctrl+z）挂起或强制退出终端没关闭 VIM 后"></a>5.如果 VIM 非正常退出 （ctrl+z）挂起或强制退出终端没关闭 VIM 后</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span></span><br><span class="line"><span class="comment"># rm -f .filename.swp</span></span><br></pre></td></tr></table></figure><h3 id="6-vim-中批量添加注释"><a href="#6-vim-中批量添加注释" class="headerlink" title="6.vim 中批量添加注释"></a>6.vim 中批量添加注释</h3><blockquote><p>方法一 ：块选择模式<br>批量注释：<br>Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 // 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p><p>取消注释：<br>Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 // 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。</p><p>方法二：替换命令<br>批量注释。<br>使用下面命令在指定的行首添加注释。<br>使用名命令格式： : 起始行号，结束行号 s/^/ 注释符 /g（注意冒号）。</p><p>取消注释：<br>使用名命令格式： : 起始行号，结束行号 s/^ 注释符 //g（注意冒号）。</p><p>例子：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、在 10 - 20 行添加 // 注释</span><br><span class="line">:10,20s<span class="comment">#^#//#g</span></span><br><span class="line"></span><br><span class="line">2、在 10 - 20 行删除 // 注释</span><br><span class="line">:10,20s<span class="comment">#^//##g</span></span><br><span class="line"></span><br><span class="line">3、在 10 - 20 行添加 <span class="comment"># 注释</span></span><br><span class="line">:10,20s/^/<span class="comment">#/g</span></span><br><span class="line"></span><br><span class="line">4、在 10 - 20 行删除 <span class="comment"># 注释</span></span><br><span class="line">:10,20s/<span class="comment">#//g</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 文件编辑</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 文件编辑" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件管理</title>
    <link href="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-02T15:30:00.000Z</published>
    <updated>2020-08-23T02:55:25.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h2><blockquote><p>说到 Linux 文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等，例如：当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</p></blockquote><h2 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h2><blockquote><p>计算机操作系统都是使用目录结构组织文件，具体来说就是在一个目录中存放子目录和文件，而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支， 所以该结构又被称为” 目录树 “。Windows: 以多根的方式组织文件 C:\ D:\ ，Linux: 以单根的方式组织文件。如下图为 Centos7 的目录结构<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/1.jpg" alt="1"></p></blockquote><h3 id="1-存放命令相关的目录"><a href="#1-存放命令相关的目录" class="headerlink" title="1.存放命令相关的目录"></a>1.存放命令相关的目录</h3><blockquote><ol><li><strong>/bin： /usr/bin：普通用户可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等。</strong></li><li><strong>/sbin：/usr/sbin：/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能” 查看” 而不能设置和使用。</strong></li></ol></blockquote><h3 id="2-存放用户相关数据家目录"><a href="#2-存放用户相关数据家目录" class="headerlink" title="2.存放用户相关数据家目录"></a>2.存放用户相关数据家目录</h3><blockquote><ol><li><strong>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，默认为 /home/username。</strong></li><li><strong>/root：超级管理员 root 的家目录，普通用户无权操作</strong></li></ol></blockquote><h3 id="3-系统文件目录"><a href="#3-系统文件目录" class="headerlink" title="3.系统文件目录"></a>3.系统文件目录</h3><blockquote><ol><li><strong>/usr： 应用程序存放目录</strong></li><li><strong>/usr/local：存放软件升级包</strong></li><li><strong>/usr/bin：普通用户使用应用程序</strong></li><li><strong>/usr/sbin：超级用户使用应用程序</strong></li><li><strong>/usr/share： 存放共享数据</strong></li><li><strong>/usr/lib： 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</strong></li><li><strong>/usr/share/doc： 系统说明文件存放目录</strong></li><li><strong>/usr/share/man：程序说明文件存放目录，使用 man ls 时会查询</strong></li></ol></blockquote><h3 id="4-启动目录"><a href="#4-启动目录" class="headerlink" title="4.启动目录"></a>4.启动目录</h3><blockquote><ol><li><strong>/boot：存放的系统启动相关的文件，例如:kernel，grub (引导装载程序)</strong></li></ol></blockquote><h3 id="5-配置文件目录"><a href="#5-配置文件目录" class="headerlink" title="5.配置文件目录"></a>5.配置文件目录</h3><blockquote><ol><li><strong>/etc：极其重要，所有服务的配置都在这个目录中，不建议在此目录下存放可执行文件，重要的配置文件修改配置文件之前记得备份</strong></li><li><strong>/etc/sysconfig/network-script/ifcfg-：网络配置文件</strong></li><li><strong>/etc/hostname：系统主机名配置文件</strong></li><li><strong>/usr/sbin：超级用户使用应用程序</strong></li><li><strong>/etc/resolv.conf：dns 客户端配置文件</strong></li><li><strong>/etc/hosts：本地域名解析配置文件</strong></li></ol></blockquote><h3 id="6-可变的目录与临时目录"><a href="#6-可变的目录与临时目录" class="headerlink" title="6.可变的目录与临时目录"></a>6.可变的目录与临时目录</h3><blockquote><ol><li><strong>/var：存放一些变化文件，比如 /var/log/ 下的日志文件</strong></li><li><strong>/var/tmp：进程产生的临时文件</strong></li><li><strong>/tmp：系统临时目录</strong></li></ol></blockquote><h3 id="7-设备目录文件"><a href="#7-设备目录文件" class="headerlink" title="7.设备目录文件"></a>7.设备目录文件</h3><blockquote><ol><li><strong>/dev：存放设备文件，比如硬盘，硬盘分区，光驱，等等</strong></li><li><strong>/dev/null：黑洞设备，只进不出。类似于垃圾回收站</strong></li><li><strong>/dev/random：生成随机数的设备</strong></li><li><strong>/dev/zero：能远远不断的产生数据，类似于取款机，随时随地取钱</strong></li></ol></blockquote><h3 id="8-虚拟的文件系统-如对应的进程停止则-proc-下对应目录则会被删除"><a href="#8-虚拟的文件系统-如对应的进程停止则-proc-下对应目录则会被删除" class="headerlink" title="8.虚拟的文件系统 (如对应的进程停止则 /proc 下对应目录则会被删除)"></a>8.虚拟的文件系统 (如对应的进程停止则 /proc 下对应目录则会被删除)</h3><blockquote><ol><li><strong>/proc，反映系统当前进程的实时状态</strong><br><mark>【类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了】</mark></li></ol></blockquote><h3 id="9-在-Linux7-系统中-bin-sbin-lib-lib64-都以软链接的形式链接到-usr-目录下"><a href="#9-在-Linux7-系统中-bin-sbin-lib-lib64-都以软链接的形式链接到-usr-目录下" class="headerlink" title="9.在 Linux7 系统中 /bin, /sbin, /lib, /lib64 都以软链接的形式链接到 /usr/ 目录下"></a>9.在 Linux7 系统中 /bin, /sbin, /lib, /lib64 都以软链接的形式链接到 /usr/ 目录下</h3><blockquote><ol><li><strong>/bin –&gt; /usr/bin</strong></li><li><strong>/sbin –&gt; /usr/sbin</strong></li><li><strong>lib -&gt; usr/lib</strong></li><li><strong>lib64 -&gt; usr/lib64</strong></li></ol></blockquote><h2 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h2><blockquote><p>在开始操作文件前，首先需要对文件进行定位，比如：需要在什么地方创建什么文件？你要将文件复制到什么地方？或者你要删除的文件在什么地方？那什么是定位？比如 /etc/hostname，整个文件中包含文件名称以及文件所在的位置，这个就叫做路径，那么路径就是对文件进行定位的一种方式。</p></blockquote><h3 id="1-每个目录下都有一个-和-的目录是什么？"><a href="#1-每个目录下都有一个-和-的目录是什么？" class="headerlink" title="1.每个目录下都有一个 . 和 ..  的目录是什么？"></a>1.每个目录下都有一个 . 和 ..  的目录是什么？</h3><blockquote><p>一个点代表当的是当前目录，两个点代表的是当前目录的上层目录。假设当前目录在 /usr/ 下，那么它的上层 (/) 目录用../ 表示，而 /usr/ 的下层 (local) 目录则用./local 表示。</p></blockquote><h3 id="2-那什么是绝对路径，什么又是相对路径呢？"><a href="#2-那什么是绝对路径，什么又是相对路径呢？" class="headerlink" title="2.那什么是绝对路径，什么又是相对路径呢？"></a>2.那什么是绝对路径，什么又是相对路径呢？</h3><blockquote><ol><li><strong>绝对路径：只要从 / 开始的路径，比如 /home/alice/file</strong></li><li><strong>相对路径：相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3</strong></li><li><strong>小结：所谓的 (.) 和 (..) 目录实际上属于相对路径的一种表示形式</strong></li></ol></blockquote><h3 id="3-绝对路径与相对路径示例"><a href="#3-绝对路径与相对路径示例" class="headerlink" title="3.绝对路径与相对路径示例"></a>3.绝对路径与相对路径示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">[root@demo /]<span class="comment"># useradd alice</span></span><br><span class="line">[root@demo /]<span class="comment"># touch /home/alice/file1</span></span><br><span class="line">[root@demo /]<span class="comment"># touch ~/file2</span></span><br><span class="line">[root@demo /]<span class="comment"># touch ~alice/file3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对路径</span></span><br><span class="line">[root@demo /]<span class="comment"># mkdir abc</span></span><br><span class="line">[root@demo /]<span class="comment"># touch ../file3</span></span><br><span class="line">[root@demo /]<span class="comment"># touch file4</span></span><br><span class="line">[root@demo /]<span class="comment"># touch abc/file5</span></span><br></pre></td></tr></table></figure><h3 id="4-cd-改变目录，常见的使用方法"><a href="#4-cd-改变目录，常见的使用方法" class="headerlink" title="4.cd 改变目录，常见的使用方法"></a>4.cd 改变目录，常见的使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd 绝对路径 cd /etc/hostname</span></span><br><span class="line"><span class="comment"># cd 相对路径 cd test/abc cd . cd ..</span></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line"><span class="comment"># cd      #切换目录，例: cd /etc</span></span><br><span class="line"><span class="comment"># cd -    #切换回上一次所在的目录</span></span><br><span class="line"><span class="comment"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span></span><br><span class="line"><span class="comment"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp /etc/hostname ./</span></span><br><span class="line"><span class="comment"># cd ..   #切换回当前目录的上级目录</span></span><br></pre></td></tr></table></figure><h2 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><h4 id="1-文件创建命令-touch"><a href="#1-文件创建命令-touch" class="headerlink" title="1.文件创建命令 touch"></a>1.文件创建命令 touch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch file</span></span><br><span class="line"><span class="comment"># touch file2 file3</span></span><br><span class="line"><span class="comment"># touch /home/od/file4 file5</span></span><br><span class="line"><span class="comment"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch file&#123;a..z&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-目录创建命令-mkdir"><a href="#2-目录创建命令-mkdir" class="headerlink" title="2.目录创建命令 mkdir"></a>2.目录创建命令 mkdir</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选项：-v 显示详细信息  -p 递归创建目录</span></span><br><span class="line"><span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment"># mkdir /home/od/dir1 /home/od/dir2</span></span><br><span class="line"><span class="comment"># mkdir -v /home/od/&#123;dir3,dir4&#125; </span></span><br><span class="line"><span class="comment"># mkdir -pv /home/od/dir5/dir6</span></span><br><span class="line"><span class="comment"># mkdir -pv /home/&#123;od/&#123;diu,but&#125;,boy&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-以树状显示目录结构命令-tree"><a href="#3-以树状显示目录结构命令-tree" class="headerlink" title="3.以树状显示目录结构命令 tree"></a>3.以树状显示目录结构命令 tree</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选项: -L: 显示目录树的层级</span></span><br><span class="line"><span class="comment"># tree /home/od/    #显示当前目录下的结构</span></span><br><span class="line">/home/od/</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure><h3 id="2-cp-复制"><a href="#2-cp-复制" class="headerlink" title="2.cp 复制"></a>2.cp 复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp file /tmp/file_copy</span></span><br><span class="line"><span class="comment"># cp name /tmp/name         #不修改名称</span></span><br><span class="line"><span class="comment"># cp file /tmp/             #不修改名称</span></span><br><span class="line"><span class="comment"># cp -p file /tmp/file_p    #-p保持原文件或目录的属性</span></span><br><span class="line"><span class="comment"># cp -r  /etc/ /tmp/        #复制目录需要使用-r参数, 递归复制</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp  #拷贝多个文件至一个目录</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-mv-移动"><a href="#3-mv-移动" class="headerlink" title="3.mv 移动"></a>3.mv 移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mv file file1             #原地移动算改名</span></span><br><span class="line"><span class="comment"># mv file1 /tmp/            #移动文件至tmp目录</span></span><br><span class="line"><span class="comment"># mv /tmp/file1 ./          #移动tmp目录的文件至当前目录</span></span><br><span class="line"><span class="comment"># mv dir/ /tmp/             #移动目录至/tmp目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/    #移动多个文件或至同一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt     #移动多个目录至同一个目录</span></span><br></pre></td></tr></table></figure><h3 id="4-rm-删除"><a href="#4-rm-删除" class="headerlink" title="4.rm 删除"></a>4.rm 删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span></span><br><span class="line"><span class="comment"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span></span><br><span class="line"><span class="comment"># rm -f file.txt    #删除文件, 不提醒</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment"># rm -r dir/        #递归删除目录，会提示</span></span><br><span class="line"><span class="comment"># rm -rf dir/       #强制删除目录,不提醒(慎用)</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#1.rm删除示例</span></span><br><span class="line"><span class="comment"># mkdir /home/dir10</span></span><br><span class="line"><span class="comment"># touch /home/dir10/&#123;file2,file3,.file4&#125;</span></span><br><span class="line"><span class="comment"># rm -f /home/dir10/*  //不包括隐藏文件 </span></span><br><span class="line"><span class="comment"># ls /home/dir10/ -a</span></span><br><span class="line">. .. .file4</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#2.rm删除示例2</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch &#123;1..10&#125;.pdf</span></span><br><span class="line"><span class="comment"># rm -rf file* </span></span><br><span class="line"><span class="comment"># rm -rf *.pdf</span></span><br></pre></td></tr></table></figure><h3 id="5-查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#5-查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="5.查看文件内容 (cat tac less more head tail tailf grep …)"></a>5.查看文件内容 (cat tac less more head tail tailf grep …)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------cat</span></span><br><span class="line"><span class="comment"># cp /etc/passwd ./pass</span></span><br><span class="line"><span class="comment"># cat pass      #正常查看文件方式</span></span><br><span class="line"><span class="comment"># cat -n pass   #-n显示文件有多少行</span></span><br><span class="line"><span class="comment"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span></span><br><span class="line"><span class="comment"># tac pass      #倒序查看文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------less、more</span></span><br><span class="line"><span class="comment"># less /etc/services    #使用光标上下翻动，空格进行翻页，q退出</span></span><br><span class="line"><span class="comment"># more /etc/services    #使用回车上下翻动，空格进行翻页，q退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------head</span></span><br><span class="line"><span class="comment"># head pass     #查看头部内容，默认前十行</span></span><br><span class="line"><span class="comment"># head -n5 pass #查看头部5行，使用-n指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------tail</span></span><br><span class="line"><span class="comment"># tail pass</span></span><br><span class="line"><span class="comment"># tail -20 /var/log/secure</span></span><br><span class="line"><span class="comment"># tail -f /var/log/messages #-f查看文件尾部的变化</span></span><br><span class="line"><span class="comment"># tailf /var/log/messages   #查看文件尾部的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------grep过滤文件内容</span></span><br><span class="line"><span class="comment"># grep &quot;^root&quot; pass     #匹配以root开头的行</span></span><br><span class="line"><span class="comment"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span></span><br><span class="line"><span class="comment"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span></span><br><span class="line"><span class="comment"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span></span><br><span class="line"><span class="comment"># grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的下2行</span></span><br><span class="line"><span class="comment"># grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上2行</span></span><br><span class="line"><span class="comment"># grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上下2行</span></span><br></pre></td></tr></table></figure><h3 id="6-联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#6-联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="6.联网下载文件 (wget、curl)、文件上传与下载 (rz、sz)"></a>6.联网下载文件 (wget、curl)、文件上传与下载 (rz、sz)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项: -O: 指定下载地址</span></span><br><span class="line"><span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项: -o: 指定下载地址</span></span><br><span class="line"><span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yum install lrzsz -y  #不安装软件则无法执行该命令</span></span><br><span class="line"><span class="comment"># rz            #只能上传文件</span></span><br><span class="line"><span class="comment"># sz /path/file #只能下载文件</span></span><br></pre></td></tr></table></figure><h3 id="7-文件或命令查找-locate、which、whereis、find"><a href="#7-文件或命令查找-locate、which、whereis、find" class="headerlink" title="7.文件或命令查找 (locate、which、whereis、find)"></a>7.文件或命令查找 (locate、which、whereis、find)</h3><blockquote><p>1.文件查找</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># locate /etc/sh       #搜索etc目录下所有以sh开头的文件</span></span><br><span class="line"><span class="comment"># locate -i /etc/sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span></span><br></pre></td></tr></table></figure><blockquote><p>2.命令查找</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which ls  #查找ls命令的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis ls       #查找命令的路径、帮助手册、等</span></span><br><span class="line"><span class="comment"># whereis -b ls    #仅显示命令所在的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -a ls       #查看命令的绝对路径(包括别名)</span></span><br></pre></td></tr></table></figure><h3 id="8-字符处理命令-sort、uniq、cut、sed、awk、wc"><a href="#8-字符处理命令-sort、uniq、cut、sed、awk、wc" class="headerlink" title="8.字符处理命令 (sort、uniq、cut、sed、awk、wc)"></a>8.字符处理命令 (sort、uniq、cut、sed、awk、wc)</h3><blockquote><p>1.sort 排序</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"><span class="comment"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort file.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat ip.txt </span></span><br><span class="line">192.168.3.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.3.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.2.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.0.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.1.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.1.12 00:30:15:A2:3A:A1</span><br><span class="line">192.168.1.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.2.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.1.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.1.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.3.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.3.12 00:30:15:A2:3A:A1</span><br><span class="line"></span><br><span class="line">[答案]: sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span><br></pre></td></tr></table></figure><blockquote><p>2.uniq 去重</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line"><span class="comment">#选项：-c  计算重复的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建一个file.txt文件:</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"><span class="comment">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt |sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure><blockquote><p>3.cut 截取字段</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line"><span class="comment">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span></span><br><span class="line"><span class="comment">#echo &quot;Im demo, is QQ 123456&quot; &gt;file.txt   #过滤出文件里 demo以及123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>4.统计行号</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line"><span class="comment">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure><blockquote><p>练习：分析如下日志，统计每个域名被访问的次数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@student tmp]<span class="comment"># cat web.log </span></span><br><span class="line">http://www.demo.com/index.html</span><br><span class="line">http://www.demo.com/1.html</span><br><span class="line">http://post.demo.com/index.html</span><br><span class="line">http://mp3.demo.com/index.html</span><br><span class="line">http://www.demo.com/3.html</span><br><span class="line">http://post.demo.com/2.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># awk -F &#x27;/&#x27; &#x27;&#123;print $3&#125;&#x27; web.log|sort -rn|uniq –c</span></span><br><span class="line"><span class="comment"># cut -d / -f3 web.log|sort -rn|uniq –c</span></span><br></pre></td></tr></table></figure><h2 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ls anaconda-ks.cfg -l</span></span><br><span class="line">-rw-------. 1 root root 1523 Aug  6 00:37 anaconda-ks.cfg  <span class="comment">#文件属性，文件的属性分为十列</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">1523        ⑤:文件大小</span><br><span class="line">Aug6 00:37 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">anaconda-ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure><h2 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h2><blockquote><p>通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过 ls -l 以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll -d /etc/hosts /tmp /bin/ls  /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client</span></span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 /bin/ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 /dev/<span class="built_in">log</span></span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 /dev/sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 /dev/tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 /etc/grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 /etc/hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 /run/dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">-   <span class="comment">#普通文件(文本, 二进制, 压缩, 图片, 日志等) </span></span><br><span class="line">d   <span class="comment">#目录文件</span></span><br><span class="line">b   <span class="comment">#设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2</span></span><br><span class="line">c   <span class="comment">#设备文件(字符设备)，终端 /dev/tty1, /dev/zero</span></span><br><span class="line">s   <span class="comment">#套接字文件, 进程间通信(socket)</span></span><br><span class="line">p   <span class="comment">#管道文件</span></span><br><span class="line">l   <span class="comment">#链接文件</span></span><br></pre></td></tr></table></figure><blockquote><p>但有些情况下，我们无法通过 ls -l 文件的类型，比如：一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用 file 来更加精准的判断这个文件的类型。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># file /etc/hosts</span></span><br><span class="line">/etc/hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /dev/sda</span></span><br><span class="line">/dev/sda: block special</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /dev/tty1</span></span><br><span class="line">/dev/tty1: character special</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /etc/grub2.cfg</span></span><br><span class="line">/etc/grub2.cfg: broken symbolic link to `../boot/grub2/grub.cfg<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@demo ~]# file /home</span></span><br><span class="line"><span class="string">/home: directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@demo ~]# file /run/dmeventd-client</span></span><br><span class="line"><span class="string">/run/dmeventd-client: fifo (named pipe)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@demo ~]# ll but</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span></span><br><span class="line"><span class="string">[root@xuliangwei ~]# file but</span></span><br><span class="line"><span class="string">but: Zip archive data, at least v1.0 to extract</span></span><br></pre></td></tr></table></figure><h2 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h2><blockquote><p>文件有文件名与数据，在 Linux 中数据又分为两种：</p><p><strong>1.元数据，既属性数据：metadata</strong>，它包含文件的文件名 (filename)、大小 (size)、占用了多少&gt;个数据块 (block)、节点号 inode、链接 (links)、等等信息。。。<br><strong>2.数据本身：data</strong><br>在 Linux 中，inode 是文件元数据的一部分但其并不包含文件名，文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。下图展示了程序通过文件名获取文件内容的过程。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2.jpg" alt="2"></p><h3 id="1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link）"><a href="#1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link）" class="headerlink" title="1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）"></a>1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）</h3><blockquote><p>1.软链接，软链接相当于 Windows 的快捷方式，软链接文件会将 inode 指向源文件的 block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个 inode 指向同一个 block。当我们删除软链接文件时，其实只是删除了一个 inode 指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/3.jpg" alt="3"></p></blockquote><blockquote><p>2.硬链接，一个 inode 号对应多个文件名，换言之，硬链接就是同一个文件使用了多个别名，如下图 hard link 就是 file 的一个别名，他们有共同的 inode。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/4.jpg" alt="4"></p></blockquote><blockquote><p>3.软链接实践</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件软链接示例</span></span><br><span class="line">touch /root/file</span><br><span class="line">ln -s /root/file /tmp/file_bak    <span class="comment">#root下file链接到/tmp下并重命名为file_bak</span></span><br><span class="line">ll /tmp/file_bak      <span class="comment">#查看链接指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目录软链接示例</span></span><br><span class="line">mkdir /soft/nginx1.1 -p</span><br><span class="line">ln -s /soft/nginx1.1/ /soft/nginx    <span class="comment">#将/soft/下nginx1.1链接到/soft下并重命名为nginx</span></span><br><span class="line">ll /soft/nginx   <span class="comment">#查看链接指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#软链接使用场景</span></span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure><blockquote><p>4.硬链接实践</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件硬链接示例</span></span><br><span class="line">ln  /root/file /tmp/file_hard <span class="comment">#将/root/下file链接到/tmp/下并重命名为file_hard</span></span><br><span class="line">ll /tmp/file_hard    <span class="comment">#查看链接指向</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>【注意】：目录不能创建硬链接，硬链接文件可以用 rm 命令删除</p>          </div><blockquote><p>5.硬链接与软链接区别</p><ol><li>ln 命令创建硬链接，ln -s 命令创建软链接</li><li>目录不能创建硬链接，并且硬链接不可以跨越分区系统</li><li>目录软链接特别常用，并且软链接支持跨越分区系统</li><li>硬链接文件与源文件的 inode 相同，软链接文件与源文件 inode 不同</li><li>删除软链接文件，对源文件及硬链接文件无任何影响</li><li>删除文件的硬链接文件，对源文件及链接文件无任何影响</li><li>删除链接文件的源文件，对硬链接无影响，会导致软链接失效</li><li>删除源文件及其硬链接文件，整个文件会被真正的删除</li></ol></blockquote>]]></content>
    
    
    <summary type="html">Linux 文件管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 文件管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统命令行入门</title>
    <link href="https://www.demon-w.com/2018/01/01/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/"/>
    <id>https://www.demon-w.com/2018/01/01/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/</id>
    <published>2017-12-31T16:30:00.000Z</published>
    <updated>2020-08-23T02:48:54.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Bash-Shell-初步认识"><a href="#1-Bash-Shell-初步认识" class="headerlink" title="1.Bash Shell 初步认识"></a>1.Bash Shell 初步认识</h2><h3 id="1-什么是Bash-Shell？"><a href="#1-什么是Bash-Shell？" class="headerlink" title="1.什么是Bash Shell？"></a>1.什么是Bash Shell？</h3><blockquote><p>Shell 是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。当我们使用远程连接工具连接 Linux 服务，系统则会给打开一个默认的 shell，我们可在这个界面执行命令，比如：获取系统当前时间，创建一个用户等等。</p></blockquote><h3 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么?"></a>2.Bash Shell能干什么?</h3><blockquote><p>使用 Shell 实现对 Linux 系统的大部分管理</p><ul><li>1.文件管理</li><li>2.权限管理</li><li>3.用户管理</li><li>4.磁盘管理</li><li>5.网络管理</li><li>6.软件管理</li><li>7.等等。。。</li></ul></blockquote><h3 id="3-平时我们如何使用-Shell-呢？"><a href="#3-平时我们如何使用-Shell-呢？" class="headerlink" title="3.平时我们如何使用 Shell 呢？"></a>3.平时我们如何使用 Shell 呢？</h3><blockquote><ul><li>1.输入命令 –&gt; 效率低 –&gt; 适合少量的工作</li><li>2.Shell Script –&gt; 效率高–&gt; 适合复杂重复性的工作，例如：创建 100 个用户，单纯输入命令需要执行 100 次，而 Shell 脚本只需要几行命令即可完成 100 个用户的创建</li></ul></blockquote><h3 id="4-Shell-提示符"><a href="#4-Shell-提示符" class="headerlink" title="4.Shell 提示符"></a>4.Shell 提示符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># whoami   #代表root用户(超级管理员)</span></span><br><span class="line">root</span><br><span class="line">[root@demo ~]$ whoami   $代表普通用户</span><br><span class="line">jack</span><br></pre></td></tr></table></figure><h3 id="5-Shell-基础语法"><a href="#5-Shell-基础语法" class="headerlink" title="5.Shell 基础语法"></a>5.Shell 基础语法</h3><blockquote><p>命令行 bash shell，为用户提供输入， 执行命令的界面</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [arguments]</span><br><span class="line"><span class="comment">#命令    选项        参数</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># ls             #命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls -a          #命令+选项</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls -a /home/   #命令+选项+参数</span></span><br><span class="line"></span><br><span class="line">命令: 整条shell命令的主体</span><br><span class="line">选项: 用于调节命令的具体功能</span><br><span class="line">   以 <span class="string">&quot;-&quot;</span> 引导短格式选项(单个字符)，例如 <span class="string">&quot;-a&quot;</span></span><br><span class="line">   以 <span class="string">&quot;--&quot;</span> 引导长格式选项(多个字符)，例如 <span class="string">&quot;--color&quot;</span></span><br><span class="line">   多个短格式选项可以写在一起，只用一个 <span class="string">&quot;-&quot;</span> 引导，例如 <span class="string">&quot;-al&quot;</span></span><br><span class="line">参数: 命令操作的对象，如文件、目录名等</span><br></pre></td></tr></table></figure><div class="note danger">            <p>命令必须写在前，选项和参数位置可以发生变化</p>          </div><h2 id="2-Bash-Shell-基本特性"><a href="#2-Bash-Shell-基本特性" class="headerlink" title="2.Bash Shell 基本特性"></a>2.Bash Shell 基本特性</h2><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a>1.命令补全</h3><blockquote><p>当使用 windows 查找一个目录层级特别多的文件时，打开的效率会非常的慢，但如果使用 linux 查找一个目录层级特别多的文件时，可以通过 tab 键快速的补全</p></blockquote><div class="note success">            <p>tab 键可以实现命令补全，路径补全，在实际生产中 tab 补全往往是我们使用的最多的，因为可以减少执行命令以及路径出错率。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看ip时忘记具体了命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifcon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按下tab键会自动补全</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按一下tab键没有反应, 按两下tab键列出所有if开头的命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># if</span></span><br><span class="line"><span class="keyword">if</span>         ifconfig   ifenslave  ifrename</span><br><span class="line">ifcfg      ifdown     ifnames    ifup</span><br><span class="line"></span><br><span class="line"><span class="comment">#linux目录较深，经常使用tab键进行补全, 如果路径出错是没有办法补全</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls /etc/sysconfig/network-scripts/</span></span><br></pre></td></tr></table></figure><h3 id="2-命令快捷键"><a href="#2-命令快捷键" class="headerlink" title="2.命令快捷键"></a>2.命令快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a    <span class="comment">#光标跳转至正在输入的命令行的首部</span></span><br><span class="line">Ctrl + e    <span class="comment">#光标跳转至正在输入的命令行的尾部</span></span><br><span class="line">Ctrl + c    <span class="comment">#终止前台运行的程序</span></span><br><span class="line">Ctrl + d    <span class="comment">#在shell中，ctrl-d表示推出当前shell。</span></span><br><span class="line">Ctrl + z    <span class="comment">#将任务暂停，挂至后台</span></span><br><span class="line">Ctrl + l    <span class="comment">#清屏，和clear命令等效。</span></span><br><span class="line">Ctrl + k    <span class="comment">#删除从光标到行末的所有字符</span></span><br><span class="line">Ctrl + u    <span class="comment">#删除从光标到行首的所有字符</span></span><br><span class="line">Ctrl + r    <span class="comment">#搜索历史命令, 利用关键字</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>在命令行前加面加 “#” 则该命令不会被执行</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># #ls</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-历史命令-History"><a href="#3-历史命令-History" class="headerlink" title="3.历史命令 History"></a>3.历史命令 History</h3><blockquote><p>用于显示历史记录和执行过的指令命令，history 命令读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。该命令单独使用时，仅显示历史命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line"><span class="built_in">history</span> (选项) (参数)</span><br><span class="line">-w 保存命令历史到历史文件</span><br><span class="line">-c 清空命令历史记录, 不会清空文件</span><br><span class="line">-d 删除命令历史的第 N 条行</span><br><span class="line"></span><br><span class="line">1.使用双 !! 可执行上一条执行过的命令</span><br><span class="line">[root@demo ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">[root@demo ~]<span class="comment"># !!</span></span><br><span class="line">ls</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line"></span><br><span class="line">2.输入!6, 执行<span class="built_in">history</span>命令历史中第 6 行命令</span><br><span class="line">[root@demo ~]<span class="comment"># !6</span></span><br><span class="line">touch 1.txt</span><br><span class="line"></span><br><span class="line">3.使用!cat, 调用<span class="built_in">history</span>命令历史最近一次执行过的cat命令</span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">[root@demo ~]<span class="comment"># !cat</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">4.小技巧:</span><br><span class="line">[root@demo ~]<span class="comment"># ls /etc/passwd</span></span><br><span class="line">调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 <span class="string">&quot;.&quot;</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line">第二种方式, 输入!$</span><br><span class="line">[root@demo ~]<span class="comment"># ls !$</span></span><br><span class="line">ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure><h4 id="历史命令生产实践"><a href="#历史命令生产实践" class="headerlink" title="历史命令生产实践"></a>历史命令生产实践</h4><blockquote><p>显示执行历史记录时间:<br>1、默认情况下，history 并不记录命令的执行时间，分析起来很困难。可以使用 HISTTIMEFORMAT 在历史中显示 TIMESTAMP。<br>2、将 export HISTTIMEFORMAT=”% F % T “ 变量加入到～/.bashrc 中即可在登录后自动开启 history 时间戳了。添加完成后，执行 source ~/.bashrc 让其生效。仅针对当前账号有效。<br>3、其实 HISTTIMEFORMAT 的格式就是 strftime 函数的格式，比如上面的 “% F % T “，% F 表示显示出 Y-M-D 格式的日期，% T 表示显示出 H-M-S 这样格式的时间。<br>4、用 Ctrl+R 搜索历史命令；当执行了一串相当长的命令之后，用关键字搜索一下历史命令然后重新执行这条命令而不需要将整条命令再输一遍。方法是：按下 Ctrl+R 然后输入关键字。如搜索 ”date”，则显示历史的命令中含有 ”date” 的命令 date “+ 今天是:% F,% A, 时间是:% T. 准备吃饭去”。按回车，就可以重新执行这条命令了，而按左箭头键或右箭头键则可以直接修改，改完之后按回车执行，非常方便！<br><mark>【注：在命令行提示符下按下 Ctrl+R，终端将显示如下提示】</mark><br><code>[root@demo ~]#</code><br><code>(reverse-i-search)</code>‘: </p><p>#配置 HISTTIMEFORMAT 环境变量，给 history 记录添加上时间戳，效果是临时的<br><code>[root@demo ~]# export HISTTIMEFORMAT=&quot;%F %T &quot; #配置HISTTIMEFORMAT环境变量，给history记录添加上时间戳</code><br>#当我们再次执行 history 命令时，就会有时间戳<br><code>[root@demo ~]# export HISTTIMEFORMAT=&quot;%F %T &quot;</code><br><code>1 2020-08-14 00:15:39 ping baidu.com</code><br><code>2 2020-08-13 22:32:58 ls -al</code><br><code>3 2020-08-13 22:57:16 ls</code></p></blockquote><h3 id="3-命令别名"><a href="#3-命令别名" class="headerlink" title="3.命令别名"></a>3.命令别名</h3><blockquote><p>命令别名将用户经常使用的复杂命令简单化，可以用：”alias 别名名称 = 命令” 命令创建属于自己的命令别名，若要取消一个命令别名，则使用：”unalias 别名名称命令”</p><p>1.定义临时别名，wk 为查看 eth0 网卡别名<br><code>[root@demo ~]# alias wk=&#39;ifconfig&#39;</code><br><code>[root@demo ~]# wk</code></p><p>2.如果定义命令本身，会执行什么？<br><code>[root@demo ~]# alias ifconfig=&#39;ifconfig eth0&#39;</code><br>#会以绝对路径执行，调用命令本身<br><code>[root@demo ~]# /sbin/ifconfig</code><br>#通过 \ 转义字符，调用命令本身<br><code>[root@demo ~]# \ifconfig</code></p><p>3.取消别名<br><code>[root@demo ~]# unalias ifconfig</code></p><p>4.永久生效，/etc/bashrc<br><code>[root@demo ~]# echo &quot;alias ifconfig=&#39;ifconfig eth0&#39;&quot; &gt;&gt; /etc/bashrc</code></p></blockquote><h2 id="3-Bash-Shell-获取帮助"><a href="#3-Bash-Shell-获取帮助" class="headerlink" title="3.Bash Shell 获取帮助"></a>3.Bash Shell 获取帮助</h2><blockquote><p><strong>1.help 帮助</strong><br><strong>用法：命令 - -help</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ls --help</span></span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 常见选项</span></span><br><span class="line">-a  <span class="comment">#查看目录下的所有文件，包括隐藏文件</span></span><br><span class="line">-l  <span class="comment">#以长格式的方式显示文件的详细内容</span></span><br><span class="line">-h  <span class="comment">#以人性化的方式显示内容，配合-l使用</span></span><br><span class="line">-d  <span class="comment">#只列出目录名，不列出目录以下的内容</span></span><br><span class="line">-t  <span class="comment">#按修改时间进行排序</span></span><br><span class="line">-i  <span class="comment">#显示文件的inode(该文件在该分区的一个编号)</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># date --help</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@demo ~]<span class="comment"># date +%F   #查看日期</span></span><br><span class="line">2019-03-28</span><br><span class="line">[root@demo ~]<span class="comment"># date -s 12:00  #修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间不是用来查看，而是有其他的用途</span></span><br><span class="line">[root@demo ~]<span class="comment"># touch `date +%F`_file.txt</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls</span></span><br><span class="line">2018-01-01_file.txt</span><br></pre></td></tr></table></figure><blockquote><p><strong>2.man 手册</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># man ls    #查看ls命令的手册</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>3.通过百度寻找帮助</strong></p></blockquote><h2 id="4-Bash-Shell-命令流程"><a href="#4-Bash-Shell-命令流程" class="headerlink" title="4.Bash Shell 命令流程"></a>4.Bash Shell 命令流程</h2><blockquote><p>当我们执行一个命令，整个命令执行流程如下:</p><ol><li>判断命令是否通过绝对路径执行</li><li>判断命令是否存在 alias 别名</li><li>判断用户输入的是内部命令还是外部命</li><li>Bash 内部命令直接执行，外部命令检测是否存在缓存</li><li>通过 PATH 路径查找命令，有执行，无报错</li></ol></blockquote><h3 id="1-什么是内部命令，什么是外部命令"><a href="#1-什么是内部命令，什么是外部命令" class="headerlink" title="1.什么是内部命令，什么是外部命令"></a>1.什么是内部命令，什么是外部命令</h3><blockquote><p><strong>内部命令:  shell 程序自带的命令。</strong><br><strong>外部命令：在系统 PATH 变量的某个路径下的可执行程序。</strong></p></blockquote><h3 id="2-如何检查用户输入的命令是内部命令还是外部命令"><a href="#2-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="2.如何检查用户输入的命令是内部命令还是外部命令"></a>2.如何检查用户输入的命令是内部命令还是外部命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># type -a cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"><span class="comment">#cd命令属于shell内部命令</span></span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># type -a  ping</span></span><br><span class="line">ping is /bin/ping</span><br><span class="line"><span class="comment">#ping属于外部命令, 同时会打印当前命令路径</span></span><br></pre></td></tr></table></figure><h3 id="3-如果是外置命令，Bash-可以通过查找-PATH-变量，获取该命令的绝对路径。"><a href="#3-如果是外置命令，Bash-可以通过查找-PATH-变量，获取该命令的绝对路径。" class="headerlink" title="3.如果是外置命令，Bash 可以通过查找 PATH 变量，获取该命令的绝对路径。"></a>3.如果是外置命令，Bash 可以通过查找 PATH 变量，获取该命令的绝对路径。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印当前环境变量目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><p><mark>【PATH 由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到 Bash 解释器对 Linux 命令的查找】</mark></p><h3 id="4-如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索-PATH-路径。"><a href="#4-如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索-PATH-路径。" class="headerlink" title="4.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索 PATH 路径。"></a>4.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索 PATH 路径。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表缓存命令所在位置</span></span><br><span class="line">[root@demo ~]<span class="comment"># hash</span></span><br><span class="line">hits    <span class="built_in">command</span></span><br><span class="line">   1    /usr/bin/tty</span><br><span class="line">   3    /sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#已缓存命令,如果移动位置会导致无法找到该命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># mv /sbin/ifconfig /bin/</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig</span></span><br><span class="line">-bash: /sbin/ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除缓存过的ifconfig命令, 即可执行</span></span><br><span class="line">[root@demo ~]<span class="comment"># hash -d ifconfig</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然可以清空缓存表</span></span><br><span class="line">[root@demo ~]<span class="comment"># hash -r</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>注意：命令缓存 hash 需要注意如下情况:<br>1.只要执行外部命令 1 次就会对该命令进行缓存<br>2.如果将命令移动了位置，该如何执行:<br>a. 使用绝对路径执行<br>b. 删除 hash 表的缓存指令</p>          </div><h3 id="命令执行流程总结"><a href="#命令执行流程总结" class="headerlink" title="命令执行流程总结"></a>命令执行流程总结</h3><blockquote><p><strong>当我们执行了一个 ping 命令之后，整个命令执行的流程步骤如下:</strong></p><ol><li>检查执行的命令是否使用的是绝对路径执行的。</li><li>检查 ping 命令是否存在 alias 别名</li><li>检查 ping 命令是内部命令还是外部命令</li><li>如果是内部命令 Bash 直接执行，如果是外部命令，首先检查 Hash 缓存，存在则直接调取</li><li>如果该命令不存在 Hash 缓存，则通过 PATH 路径进行逐行查找该命令所在的位置</li><li>如果 PATH 路径没有查找到该命令所在的路径，则返回错误码：command not found</li></ol></blockquote>]]></content>
    
    
    <summary type="html">Linux 系统命令行入门</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 系统命令行入门" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
