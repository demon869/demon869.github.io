<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Demon</title>
  
  
  <link href="https://www.demon-w.com/atom.xml" rel="self"/>
  
  <link href="https://www.demon-w.com/"/>
  <updated>2020-08-23T03:05:49.272Z</updated>
  <id>https://www.demon-w.com/</id>
  
  <author>
    <name>Demon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 基本权限</title>
    <link href="https://www.demon-w.com/2018/01/05/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/"/>
    <id>https://www.demon-w.com/2018/01/05/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/</id>
    <published>2018-01-04T17:15:00.000Z</published>
    <updated>2020-08-23T03:05:49.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-权限基本概述"><a href="#1-权限基本概述" class="headerlink" title="1.权限基本概述"></a>1.权限基本概述</h2><h3 id="1-什么是权限？"><a href="#1-什么是权限？" class="headerlink" title="1.什么是权限？"></a>1.什么是权限？</h3><blockquote><p>我们可以把它理解为操作系统对用户能够执行的功能所设立的限制，主要用于约束用户能对系统所做的操作，以及内容访问的范围，或者说，权限是指某个特定的用户具有特定的系统资源使用权力。</p></blockquote><h3 id="2-为什么要有权限？"><a href="#2-为什么要有权限？" class="headerlink" title="2.为什么要有权限？"></a>2.为什么要有权限？</h3><blockquote><p>因为系统中不可能只存在一个 root 用户，一定会存在多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。</p></blockquote><h3 id="3-权限与用户之间的关系？"><a href="#3-权限与用户之间的关系？" class="headerlink" title="3.权限与用户之间的关系？"></a>3.权限与用户之间的关系？</h3><blockquote><p>在 Linux 系统中，针对文件定义了三种身份，分别是属主<code>(owner)</code>、<code>属组(group)</code>、其他人<code>(others)</code>，每一种身份又对应三种权限，分别是<code>可读(readable)</code>、<code>可写(writable)</code>、<code>可执行(excutable)</code>。</p></blockquote><h4 id="1-如何查看权限"><a href="#1-如何查看权限" class="headerlink" title="1.如何查看权限"></a>1.如何查看权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll test.txt </span></span><br><span class="line">-rwxr-xr-x 1 root root 744 Apr  2  2017 test.txt</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/05/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/1.jpg" alt="1"></p><blockquote><p>用户对文件资源，有三种角色，当一个用户访问文件流程如下:</p><ol><li>判断用户是否为文件所有者，如果是则按所有者的权限进行访问</li><li>判断用户是否为文件所有组成员，如果是则按组的权限进行访问</li><li>如果不是所有者，也不是该文件所属组，则按匿名权限进行访问</li></ol></blockquote><h4 id="2-权限中的-rwx-分别代表什么含义？"><a href="#2-权限中的-rwx-分别代表什么含义？" class="headerlink" title="2. 权限中的 rwx 分别代表什么含义？"></a>2. 权限中的 rwx 分别代表什么含义？</h4><blockquote><p>当我们使用 ls -l 查看一个文件的详细属性时，能看到每个文件都有一个 9 位基本权限位。<br>比如: rwxr-xr-x 其中每三位字符为一组，分别表示<code>属主权限位</code>，<code>属组权限位</code>，<code>匿名权限位</code>。<br>linux 中基本权限位则是使用这 9 位字符来表示，主要控制文件<code>属主 (User)</code>、<code>属组 (Group)</code>、<code>其他用户 (Other)</code></p></blockquote><table><thead><tr><th align="left">字母</th><th align="left">含义</th><th align="left">对应权限</th></tr></thead><tbody><tr><td align="left">r(read)</td><td align="left">读取权限</td><td align="left">4</td></tr><tr><td align="left">w(write)</td><td align="left">写入权限</td><td align="left">2</td></tr><tr><td align="left">x(execute)</td><td align="left">执行权限</td><td align="left">1</td></tr><tr><td align="left">-(没有权限)</td><td align="left">没有权限</td><td align="left">0</td></tr></tbody></table><div class="note danger">            <p>【注意】：如果权限位不可读、不可写、不可执行，则全部使用 - 作为占位符表示</p>          </div><h2 id="2-权限设置示例"><a href="#2-权限设置示例" class="headerlink" title="2.权限设置示例"></a>2.权限设置示例</h2><h3 id="1-使用-chmod-设定权限示例"><a href="#1-使用-chmod-设定权限示例" class="headerlink" title="1.使用 chmod 设定权限示例"></a>1.使用 chmod 设定权限示例</h3><h4 id="方式一-ugo"><a href="#方式一-ugo" class="headerlink" title="方式一: ugo"></a>方式一: ugo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># touch file                    #创建文件</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod a=rwx file              #给所有人添加读写执行权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod a=-rwx file             #取消所有的权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod u=rwx,g=rw,o=- file     #属主读写执行，属组读写，其他人无权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod ug=rwx,o=r file         #属主属组读写执行，其他人读权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll file</span></span><br><span class="line">-rwxrw-r-- 1 root root 0 Apr 13 03:29 file</span><br></pre></td></tr></table></figure><h4 id="方式二-number"><a href="#方式二-number" class="headerlink" title="方式二: number"></a>方式二: number</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项:  -R递归修改</span></span><br><span class="line">[root@demo ~]<span class="comment"># touch file</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 644 file</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 600 file</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll file</span></span><br><span class="line">-rw------- 1 root root 0 Apr 13 03:29 file</span><br><span class="line"></span><br><span class="line"><span class="comment">#针对目录设定权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir dir</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 777 dir/    #修改目录允许所有人访问</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod -R 755 dir/ #修改目录及子目录权限</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d dir/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Apr 13 03:34 dir/</span><br></pre></td></tr></table></figure><h3 id="2-权限设置案例"><a href="#2-权限设置案例" class="headerlink" title="2. 权限设置案例"></a>2. 权限设置案例</h3><blockquote><p>针对 hr 部门的访问目录 /home/hr 设置权限，要求如下:</p><ol><li>root 用户和 hr 组的员工可以读、写、执行</li><li>其他用户没有任何权限</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># groupadd hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd hr01 -G hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd hr02 -G hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir /home/hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># chgrp hr /home/hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># chmod 770 /home/hr</span></span><br><span class="line">[root@demo ~]<span class="comment"># ll -d /home/hr</span></span><br><span class="line">drwxrwx--- 2 root hr 6 Apr 13 03:26 /home/hr</span><br></pre></td></tr></table></figure><h3 id="3-权限对文件及目录的影响"><a href="#3-权限对文件及目录的影响" class="headerlink" title="3.权限对文件及目录的影响"></a>3.权限对文件及目录的影响</h3><blockquote><p>在 Linux 中权限对文件和对目录的影响是有不同区别的。</p></blockquote><table><thead><tr><th align="left">权限</th><th align="left">对文件的影响</th><th align="left">对目录的影响</th></tr></thead><tbody><tr><td align="left">读取权限（r）</td><td align="left">具有读取 \ 阅读文件内容权限</td><td align="left">具有浏览目录及子目录</td></tr><tr><td align="left">写入权限（w）</td><td align="left">具有新增、修改文件内容的权限</td><td align="left">具有增加和删除目录内文件</td></tr><tr><td align="left">执行权限（x）</td><td align="left">具有执行文件的权限</td><td align="left">具有访问目录的内容 (取决于目录中文件权限)</td></tr></tbody></table><h4 id="1-总结-rwx-对文件的影响"><a href="#1-总结-rwx-对文件的影响" class="headerlink" title="1.总结 rwx 对文件的影响"></a>1.总结 rwx 对文件的影响</h4><blockquote><p>读取权限（r）具有读取 \ 阅读文件内容权限</p><ul><li>1.只能使用查看类命令 cat、head、tail、less、more</li></ul><p>写入权限（w）具有新增、修改文件内容的权限</p><ul><li>1.使用 vim 编辑会提示权限拒绝，但可强制保存，会覆盖文件的所有内容</li><li>2.使用 echo 命令重定向的方式可以往文件内写入数据，&gt;&gt; 可以进行追加</li><li>3.不能删除文件，因为删除文件看的不是文件的属性，需要看上级目录是否有 w 的权限</li></ul><p>执行权限（x）具有执行文件的权限</p><ul><li>1.执行权限什么用都没有</li><li>2.如果普通用户需要执行文件，需要配合 r 权限</li></ul></blockquote><h4 id="2-总结-rwx-对目录的影响"><a href="#2-总结-rwx-对目录的影响" class="headerlink" title="2.总结 rwx 对目录的影响"></a>2.总结 rwx 对目录的影响</h4><blockquote><p>读取权限（r），如果目录只有 r 权限：具有浏览目录及子目录权限</p><ul><li>1.可以使用 ls 命令浏览目录及子目录， 但同时也会提示权限拒绝</li><li>2.使用 ls -l 命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名<br><mark>总结：目录只有 r 权限，仅仅只能浏览内的文件名，无其他操作权限</mark></li></ul><p>写入权限（w），如果目录只有 w 权限：具有增加、删除或修改目录内文件名权限 (需要 x 权限配合)<br><mark>注意：如果目录有 w 权限，可以在目录内创建文件，删除文件 (跟文件本身权限无关)<br>不能进入目录、不能复制目录、不能删除目录、不能移动目录</mark></p><p>执行权限（x），如果目录只有 x 权限</p><ul><li>1.只能进入目录</li><li>2.不能浏览、复制、移动、删除</li></ul></blockquote><h2 id="4-属主属组设置"><a href="#4-属主属组设置" class="headerlink" title="4. 属主属组设置"></a>4. 属主属组设置</h2><blockquote><p>在 Linux 中如何变更一个文件或者一个资源的属主和属组呢，可以使用 chown、chgrp 命令实现。</p><p>chown 能设置属主和属组，chgrp 仅能设置属组，推荐使用 chown</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chown 更改属主以及属组 -R：递归修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备环境，创建文件和目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkdir dir/test1 &amp;&amp; touch dir/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例1: 修改所属主为bin</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown bin dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 修改所属组为adm</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown .adm dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3: 递归修改目录及目录下的所有文件属主和属组</span></span><br><span class="line">[root@demo ~]<span class="comment"># chown -R root.root dir/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 基本权限</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 基本权限" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 用户管理</title>
    <link href="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-03T16:15:00.000Z</published>
    <updated>2020-08-23T03:03:53.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h2><h3 id="1-什么是用户？"><a href="#1-什么是用户？" class="headerlink" title="1.什么是用户？"></a>1.什么是用户？</h3><blockquote><p>用户，是指使用电脑或网络服务的人，通常拥有一个用户账号，并以用户名识别。<br>Windows 系统是一个单用户的操作系统，因为在同一时刻，只能在一个系统内登陆一个用户，开启多个进程，简称为单用户多任务。<br>Linux 系统，是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统，简言之，Linux 支持同一时刻多个用户同时登陆。</p></blockquote><h3 id="2-Linux-下的用户作用，或者说我们为什么要创建用户？"><a href="#2-Linux-下的用户作用，或者说我们为什么要创建用户？" class="headerlink" title="2. Linux 下的用户作用，或者说我们为什么要创建用户？"></a>2. Linux 下的用户作用，或者说我们为什么要创建用户？</h3><blockquote><ul><li>1.系统上的每一个进程 (运行的程序)，都需要一个特定的用户运行</li><li>2.通常在公司是使用普通用户管理服务器，因为 root 权限过大，容易造成故障。</li></ul></blockquote><h3 id="3-如何查看系统中所存在的用户"><a href="#3-如何查看系统中所存在的用户" class="headerlink" title="3. 如何查看系统中所存在的用户"></a>3. 如何查看系统中所存在的用户</h3><blockquote><ul><li><strong>1.查看当前登录的用户信息</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># id    #查看当前所登陆的用户信息</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@demo ~]<span class="comment"># id jack #查看其它用户的信息</span></span><br><span class="line">uid=1000(jack) gid=1000(jack) groups=1000(jack)</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>2.每一个进程都会由一个用户身份运行</strong></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ps aux|less</span></span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker/u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker/0:2]</span><br></pre></td></tr></table></figure><h3 id="4-用户相关信息存储位置"><a href="#4-用户相关信息存储位置" class="headerlink" title="4. 用户相关信息存储位置"></a>4. 用户相关信息存储位置</h3><blockquote><p>Linux 系统会将用户的信息存放在两个文件中：</p><ul><li>1./etc/passwd，记录了用户的信息，但没有密码信息</li><li>2./etc/shadow，记录了用户密码</li></ul><p><mark>【注意：两个文件非常的重要，不要轻易删除与修改】</mark></p></blockquote><h4 id="1-etc-passwd-配置文件详解"><a href="#1-etc-passwd-配置文件详解" class="headerlink" title="1./etc/passwd 配置文件详解"></a>1./etc/passwd 配置文件详解</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/1.jpg" alt="1"></p><h4 id="2-etc-shadow-配置文件详解"><a href="#2-etc-shadow-配置文件详解" class="headerlink" title="2. /etc/shadow 配置文件详解"></a>2. /etc/shadow 配置文件详解</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/2.jpg" alt="2"></p><h3 id="5-用户的分类（约定、规范）"><a href="#5-用户的分类（约定、规范）" class="headerlink" title="5.用户的分类（约定、规范）"></a>5.用户的分类（约定、规范）</h3><table><thead><tr><th align="left">用户 UID</th><th align="left">系统含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">超级管理员，最高权限，有着极强的破坏能力</td></tr><tr><td align="left">1~200</td><td align="left">系统用户，用来运行系统自带的进程，默认已创建</td></tr><tr><td align="left">201~999</td><td align="left">系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td></tr><tr><td align="left">1000+</td><td align="left">普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td></tr></tbody></table><h2 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h2><h3 id="1-用户创建（useradd、adduser）"><a href="#1-用户创建（useradd、adduser）" class="headerlink" title="1.用户创建（useradd、adduser）"></a>1.用户创建（useradd、adduser）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    选项:</span><br><span class="line">    -u 指定用户的UID,不允许冲突</span><br><span class="line">    -g 指定用户所属的用户组</span><br><span class="line">    -G 指定用户所属的附加组,逗号隔开可添加多个附加组</span><br><span class="line">    -d 指定用户家目录</span><br><span class="line">    -s 指定用户的bash shell</span><br><span class="line">    -c 指定用户注释信息</span><br><span class="line">    -M 给创建的用户不创建家目录</span><br><span class="line">    -r 创建系统账户，默认无家目录</span><br><span class="line"></span><br><span class="line">1.创建<span class="built_in">test</span>用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd sa</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd students</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s /bin/bash test</span></span><br><span class="line"></span><br><span class="line">2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span><br><span class="line">[root@demo ~]<span class="comment"># useradd mysql -M -s /sbin/nologin</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd -r dba -s /sbin/nologin</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>【注意: adduser 命令软链接指向 useradd 命令】</p>          </div><h3 id="2-修改用户信息（usermod）"><a href="#2-修改用户信息（usermod）" class="headerlink" title="2. 修改用户信息（usermod）"></a>2. 修改用户信息（usermod）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    选项:</span><br><span class="line">    -u 指定要修改用户的UID</span><br><span class="line">    -g 指定要修改用户基本组</span><br><span class="line">    -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span><br><span class="line">    -d 指定要修改用户家目录</span><br><span class="line">    -s 指定要修改用户的bash shell</span><br><span class="line">    -c 指定要修改用户注释信息</span><br><span class="line">    -l 指定要修改用户的登陆名</span><br><span class="line">    -L 指定要锁定的用户</span><br><span class="line">    -U 指定要解锁的用户</span><br><span class="line"></span><br><span class="line">1.检查此前创建的用户信息</span><br><span class="line">[root@demo ~]<span class="comment"># grep &quot;test&quot; /etc/passwd</span></span><br><span class="line"><span class="built_in">test</span>:x:5001:503:2019 new student:/home/<span class="built_in">test</span>:/bin/bash</span><br><span class="line"></span><br><span class="line">2.修改<span class="built_in">test</span>用户uid、gid，附加组</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -g 5008 network_sa</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -g 5009 devops</span></span><br><span class="line">[root@demo ~]<span class="comment"># usermod -u 6001 -g5008 -a -G 5009 test</span></span><br><span class="line"></span><br><span class="line">3.修改<span class="built_in">test</span>用户的注释信息, 用户家目录, 登录shell, 登录名</span><br><span class="line">[root@demo ~]<span class="comment"># usermod -c &quot;2019 new student&quot; -md /abc -s /bin/sh -l abc test</span></span><br><span class="line"></span><br><span class="line">检查是否修改成功!!!</span><br><span class="line">[root@demo ~]<span class="comment"># grep &quot;abc&quot; /etc/passwd</span></span><br><span class="line">abc:x:6001:5008:2019 new student:/abc:/bin/sh</span><br><span class="line">[root@demo ~]<span class="comment"># id abc</span></span><br><span class="line">uid=6001(abc) gid=5008(network_sa) groups=5008(network_sa),1000(sa),5009(devops)</span><br><span class="line">[root@demo ~]<span class="comment"># ll -d /abc/</span></span><br><span class="line">drwx------ 2 abc network_sa 62 Aug 17 17:50 /abc/</span><br><span class="line"></span><br><span class="line">4.锁定用户[扩展]</span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;123&quot; |passwd --stdin abc</span></span><br><span class="line">[root@demo ~]<span class="comment"># usermod -L abc  #锁定后会无法登陆系统</span></span><br><span class="line"></span><br><span class="line">5.解锁用户[扩展]</span><br><span class="line">[root@demo ~]<span class="comment"># usermod -U abc</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>【注意：使用 who、whoami、w 检查用户登陆情况】</p>          </div><h3 id="3-删除账户-userdel"><a href="#3-删除账户-userdel" class="headerlink" title="3. 删除账户 (userdel)"></a>3. 删除账户 (userdel)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line">选项 -r 删除用户同时删除它的家目录</span><br><span class="line"></span><br><span class="line">1.删除user1用户，但不删除用户家目录和 mail spool</span><br><span class="line">[root@demo ~]<span class="comment"># userdel user1</span></span><br><span class="line"></span><br><span class="line">2.-r参数可以连同用户家目录一起删除(慎用)</span><br><span class="line">[root@demo ~]<span class="comment"># userdel -r user1</span></span><br></pre></td></tr></table></figure><h2 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h2><h3 id="1-用户创建流程"><a href="#1-用户创建流程" class="headerlink" title="1.用户创建流程"></a>1.用户创建流程</h3><blockquote><p>useradd 创建用户时，系统会以 /etc/login.defs、/etc/defaults/useradd 两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖 /etc/login.defs、/etc/defaults/useradd 文件默认配置，如未指定则使用默认。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/login.defs</span></span><br><span class="line">MAIL_DIR    /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_eHOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/default/useradd</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home      把用户的家目录建在/home中。</span><br><span class="line">INACTIVE=-1     是否启用账号过期停权,-1表示不启用。</span><br><span class="line">EXPIRE=         账号终止日期,不设置表示不启用。</span><br><span class="line">SHELL=/bin/bash 新用户默认所有的shell类型。</span><br><span class="line">SKEL=/etc/skel  配置新用户家目录的默认文件存放路径。</span><br><span class="line">CREATE_MAIL_SPOOL=yes   创建mail文件。</span><br></pre></td></tr></table></figure><h3 id="2-用户创建时的环境变量"><a href="#2-用户创建时的环境变量" class="headerlink" title="2.用户创建时的环境变量"></a>2.用户创建时的环境变量</h3><blockquote><p>当使用 useradd 创建用户时，创建的用户家目录下会存在 .bash_* 环境变量相关的文件，这些环境变量文件默认从 /etc/skel 目录中拷贝。这个默认拷贝环境变量位置是由 /etc/defaults/useradd 配置文件中定义的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span><br><span class="line"></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@demo ~]<span class="comment">#   重新连接即可恢复</span></span><br></pre></td></tr></table></figure><h3 id="3-用户密码设定与变更"><a href="#3-用户密码设定与变更" class="headerlink" title="3. 用户密码设定与变更"></a>3. 用户密码设定与变更</h3><blockquote><p>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用 passwd 命令。建议密码复杂度高一些、长度大于 10、出现各种特殊字符、无任何规律 (不要出现名字，电话，生日等)</p></blockquote><div class="note danger">            <p>【注意事项】</p><ul><li>1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须 8 位字符</li><li>2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</li></ul>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.使用passwd命令修改用户密码</span><br><span class="line"><span class="comment"># passwd        #给当前用户修改密码</span></span><br><span class="line"><span class="comment"># passwd root   #给root用户修改密码</span></span><br><span class="line"><span class="comment"># passwd jack #给oldboy用户修改密码，普通用户只能自己修改自己</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.验证如下几项指标</span><br><span class="line"><span class="comment"># passwd                #root管理员用户登陆，修改root用户密码</span></span><br><span class="line"><span class="comment"># passwd qwe            #root用户登陆，修改其他用户的密码</span></span><br><span class="line">$ passwd root           <span class="comment">#普通用户修改root管理员密码</span></span><br><span class="line"><span class="comment"># echo &quot;123&quot; | passwd --stdin qwe    #非交互式修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.系统内置变量生成随机字符串</span><br><span class="line">[root@demo ~]<span class="comment"># echo $RANDOM|md5sum|cut -c 1-10</span></span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@demo ~]<span class="comment"># echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin qwe</span></span><br><span class="line"></span><br><span class="line">4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span><br><span class="line">[root@demo ~]<span class="comment"># yum install -y expect   //需要安装扩展包</span></span><br><span class="line">[root@demo ~]<span class="comment"># mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span></span><br><span class="line">|K&amp;13bR)i/</span><br></pre></td></tr></table></figure><h2 id="4-用户组的管理"><a href="#4-用户组的管理" class="headerlink" title="4.用户组的管理"></a>4.用户组的管理</h2><h3 id="1-什么是用户组？"><a href="#1-什么是用户组？" class="headerlink" title="1.什么是用户组？"></a>1.什么是用户组？</h3><blockquote><p>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</p></blockquote><h3 id="2-组的类别"><a href="#2-组的类别" class="headerlink" title="2.组的类别"></a>2.组的类别</h3><blockquote><ul><li>基本组，用户只能有一个基本组，创建时可通过 - g 指定，如未指定则创建一个默认的组 (与用户同名)</li><li>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/3.jpg" alt="3"></li></ul></blockquote><h3 id="3-组相关文件"><a href="#3-组相关文件" class="headerlink" title="3.组相关文件"></a>3.组相关文件</h3><blockquote><p>组账户信息保存在 /etc/group 和 /etc/gshadow 两个文件中，重点关注 group</p></blockquote><h4 id="1-etc-group-配置文件解释如下图"><a href="#1-etc-group-配置文件解释如下图" class="headerlink" title="1./etc/group 配置文件解释如下图"></a>1./etc/group 配置文件解释如下图</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/4.jpg" alt="4"></p><h4 id="2-etc-gshadow-配置文件解释如下图"><a href="#2-etc-gshadow-配置文件解释如下图" class="headerlink" title="2./etc/gshadow 配置文件解释如下图"></a>2./etc/gshadow 配置文件解释如下图</h4><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/04/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/5.jpg" alt="5"></p><h3 id="4-组相关命令"><a href="#4-组相关命令" class="headerlink" title="4.组相关命令"></a>4.组相关命令</h3><h4 id="1-使用-groupadd-命令新增组，groupadd-g-GID-groupname"><a href="#1-使用-groupadd-命令新增组，groupadd-g-GID-groupname" class="headerlink" title="1.使用 groupadd 命令新增组，groupadd [-g GID] groupname"></a>1.使用 groupadd 命令新增组，groupadd [-g GID] groupname</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建基本组, 不指定gid</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd no_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line">创建基本组, 指定gid为5555</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -g 5555 yes_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line">创建系统组，gid从201-999</span><br><span class="line">[root@demo ~]<span class="comment"># groupadd -r sys_group</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure><h4 id="2-使用-groupmod-命令新增组"><a href="#2-使用-groupmod-命令新增组" class="headerlink" title="2. 使用 groupmod 命令新增组"></a>2. 使用 groupmod 命令新增组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-g 修改组gid</span><br><span class="line">[root@demo ~]<span class="comment"># groupmod -g 1111 no_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line">-n 修改组名称</span><br><span class="line">[root@demo ~]<span class="comment"># groupmod -n active_group yes_gid</span></span><br><span class="line">[root@demo ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure><h4 id="3-groupdel-删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。"><a href="#3-groupdel-删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。" class="headerlink" title="3.groupdel 删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。"></a>3.groupdel 删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">删除组</span><br><span class="line">[root@demo ~]<span class="comment"># groupdel active_group</span></span><br><span class="line"></span><br><span class="line">删除用户附加组</span><br><span class="line">[root@demo ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei),5004(devops)</span><br><span class="line">[root@demo ~]<span class="comment"># groupdel devops</span></span><br><span class="line">[root@demo ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line">无法删除用户基本组</span><br><span class="line">[root@demo ~]<span class="comment"># groupdel network_sa</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">&#x27;bgx_xuliangwei&#x27;</span></span><br><span class="line">只有删除用户或者用户变更基本后,方可删除该组</span><br></pre></td></tr></table></figure><h4 id="4-使用-gpasswd-设置组密码-扩展，可以不会"><a href="#4-使用-gpasswd-设置组密码-扩展，可以不会" class="headerlink" title="4. 使用 gpasswd 设置组密码 [扩展，可以不会]"></a>4. 使用 gpasswd 设置组密码 [扩展，可以不会]</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># groupadd devops</span></span><br><span class="line">[root@demo ~]<span class="comment"># gpasswd devops</span></span><br><span class="line">Changing the password <span class="keyword">for</span> group devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br></pre></td></tr></table></figure><h4 id="5-使用-newgrp-命令切换基本组身份-扩展，可以不会"><a href="#5-使用-newgrp-命令切换基本组身份-扩展，可以不会" class="headerlink" title="5. 使用 newgrp 命令切换基本组身份 [扩展，可以不会]"></a>5. 使用 newgrp 命令切换基本组身份 [扩展，可以不会]</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.检查账户信息</span><br><span class="line">[root@demo ~]<span class="comment"># useradd test1</span></span><br><span class="line">[root@demo ~]<span class="comment"># id test1</span></span><br><span class="line">uid=1069(test1) gid=5005(test1) groups=5005(test1)</span><br><span class="line"></span><br><span class="line">2.切换普通用户</span><br><span class="line">[root@demo ~]<span class="comment"># su - test1</span></span><br><span class="line"></span><br><span class="line">3.创建新文件,查看文件的属主和属组</span><br><span class="line">[test1@demo ~]$ touch file_roots</span><br><span class="line">[test1@demo ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 test1 test1 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line">4.使用newgrp切换到devops组</span><br><span class="line">[test1@demo ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line">5.创建文件，检查属主和属组</span><br><span class="line">[test1@demo ~]$ touch file_test</span><br><span class="line">[test1@demo ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 test1 test1 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 test1 devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure><h2 id="5-用户如何提权"><a href="#5-用户如何提权" class="headerlink" title="5. 用户如何提权"></a>5. 用户如何提权</h2><blockquote><p>一般公司的服务器对外都是禁止 root 用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？当我们使用普通用户执行 /sbin 目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用 root 用户直接登录系统，同时又保证普通用户能完成日常工作？</p><p>可使用如下两种方式:</p><ul><li><strong>1.su 切换用户，使用普通用户登录，然后使用 su 命令切换到 root。</strong><ul><li><strong>优点：简单</strong></li><li><strong>缺点：需要知道 root 密码</strong></li></ul></li><li><strong>2.sudo 提权，当需要使用 root 权限时进行提权，而无需切换至 root 用户。</strong><ul><li><strong>优点：安全、方便</strong></li><li><strong>缺点：复杂</strong></li></ul></li></ul></blockquote><h3 id="1-su-身份切换"><a href="#1-su-身份切换" class="headerlink" title="1.su 身份切换"></a>1.su 身份切换</h3><blockquote><p>在使用 su 切换前，我们需要了解一些预备知识，比如 shell 分类、环境变量配置文件有哪些</p><ul><li><p>1.Linux Shell 主要分为如下几类</p><ul><li>交互式 shell，等待用户输入执行的命令 (终端操作，需要不断提示)</li><li>非交互式 shell，执行 shell 脚本，脚本执行结束后 shell 自动退出</li><li>登陆 shell，需要输入用户名和密码才能进入 Shell，日常接触的最多的一种</li><li>非登陆 shell，不需要输入用户和密码就能进入 Shell, 比如运行 bash 会开启一个新的会话窗口</li></ul></li><li><p>2.bash shell 配置文件介绍 (文件主要保存用户的工作环境)</p><ul><li>个人配置文件：~/.bash_profile ~/.bashrc</li><li>全局配置文件：/etc/profile/etc/profile.d/*.sh/etc/bashrc</li><li>profile 类文件，设定环境变量，登陆前运行的脚本和命令</li><li>bashrc 类文件，设定本地变量，定义命令别名<br><mark>【注意： 如果全局配置和个人配置产生冲突，以个人配置为准】</mark></li></ul></li><li><p>3.登陆系统后，环境变量配置文件的应用顺序是？</p><ul><li>登录式 shell 配置文件执行顺序：/etc/profile—&gt;/etc/profile.d/*.sh—&gt;~/.bash_profile—&gt;~/.bashrc–&gt;/etc/bashrc</li><li>非登陆式 shell 配置文件执行顺序: ~/.bashrc—&gt;/etc/bashrc—&gt;/etc/profile.d/*.sh<br><mark>【注意： 验证使用 echo 在每行添加一个输出即可】</mark></li></ul></li><li><p>4.su 命令切换用户</p><ul><li>su - username 属于登陆式 shell</li><li>su username 属于非登陆式 shell，区别在于加载的环境变量不一样。</li><li>普通用户 su - 可以直接切换至 root 用户，但需要输入 root 用户的密码。</li><li>超级管理员 root 用户，使用 su - username 切换普通用户不需要输入任何密码。</li></ul></li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.普通用户使用su切换root</span></span><br><span class="line">[test1@demo ~]$ su</span><br><span class="line">密码：         <span class="comment">#输入root的密码</span></span><br><span class="line">[root@demo test1]<span class="comment"># pwd</span></span><br><span class="line">/home/test1</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.普通用户使用su -切换到root，会加载root的环境变量</span></span><br><span class="line">[test1@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - test1 -c &#x27;ifconfig&#x27;</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - test1 -c &#x27;ls ~&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-sudo-提权"><a href="#2-sudo-提权" class="headerlink" title="2.sudo 提权"></a>2.sudo 提权</h3><blockquote><p>su 命令在切换用户身份时，如果每个普通用户都能拿到 root 用户的密码，当其中某个用户不小心泄漏了 root 的密码，那系统会变得非常不安全，为了改进这个问题，从而产生了 sudo 这个命令。</p><p>其实 sudo 就相当于给某个普通用户埋下了浩克 (hulk) 的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。</p></blockquote><h4 id="1-如何快速埋下-hulk-的种子呢？"><a href="#1-如何快速埋下-hulk-的种子呢？" class="headerlink" title="1. 如何快速埋下 hulk 的种子呢？"></a>1. 如何快速埋下 hulk 的种子呢？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.快速配置sudo方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># usermod bgx -G wheel            #wheel组类似于一个管理员的组</span></span><br><span class="line">[root@demo ~]$ sudo tail -f /var/<span class="built_in">log</span>/secure    <span class="comment">#sudo审计日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.一般正常配置sudo方式</span></span><br><span class="line">[root@demo ~]<span class="comment"># #visudo =&gt; vim /etc/sudoers</span></span><br><span class="line"><span class="comment">#1.用户名  2.主机名=(角色名)    4.命令名</span></span><br><span class="line">aaa       ALL=(ALL)          /usr/bin/yum,/usr/sbin/useradd   <span class="comment">#允许使用sudo执行命令</span></span><br><span class="line">bbb       ALL=(ALL)          NOPASSWD:/bin/cp, /bin/rm   <span class="comment">#NOPASSWD不需要使用密码</span></span><br></pre></td></tr></table></figure><h4 id="2-埋下了-hulk-种子后又如何提权使用呢？"><a href="#2-埋下了-hulk-种子后又如何提权使用呢？" class="headerlink" title="2. 埋下了 hulk 种子后又如何提权使用呢？"></a>2. 埋下了 hulk 种子后又如何提权使用呢？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.切换普通用户</span></span><br><span class="line">[root@demo ~]<span class="comment"># su - aaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.检查普通用户能提权的命令</span></span><br><span class="line">[aaa@demo ~]$ sudo -l</span><br><span class="line">User aaa may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.普通用户正常情况下是无法删除opt目录的</span></span><br><span class="line">[aaa@demo ~]$ rm -rf /opt/</span><br><span class="line">rm: cannot remove `/opt: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用sudo提权，需要输入普通用户的密码。</span></span><br><span class="line">[aaa@demo ~]$ sudo rm -rf /opt</span><br></pre></td></tr></table></figure><h4 id="3-提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？"><a href="#3-提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？" class="headerlink" title="3. 提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？"></a>3. 提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</h4><blockquote><ul><li>第一种方式：使用 sudo 中自带的别名操作，将多个用户定义成一个组，这个组只有 sudo 认可</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># visudo    #也可以使用vi /etc/sudoers来配置</span></span><br><span class="line"><span class="comment"># 1.使用sudo定义分组,这个分组跟系统的group没什么关系!</span></span><br><span class="line">User_Alias OPS = aaa,alex</span><br><span class="line">User_Alias DEV = bbb,py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义可执行的命令组,便于后续调用</span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用sudo开始分配权限</span></span><br><span class="line">OPS  ALL=(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.登陆对应的用户使用 sudo -l 验证权限</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>第二种方式：使用 groupadd 添加组，然后给组分配 sudo 的权限，如果有新用户加入，直接将用户添加到该组</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.添加两个真实的系统组,  group_dev group_op</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd group_dev</span></span><br><span class="line">[root@demo ~]<span class="comment"># groupadd group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_a -G group_dev</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_b -G group_dev</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_c -G group_op</span></span><br><span class="line">[root@demo ~]<span class="comment"># useradd user_d -G group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.记得添加密码</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_a</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_b</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_c</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.在sudo中配置规则</span></span><br><span class="line">[root@demo ~]<span class="comment"># visudo</span></span><br><span class="line">    Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">    Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">    Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">    Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL=(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.检查sudo是否配置有错</span></span><br><span class="line">[root@demo ~]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.检查user_a,和user_d的sudo权限</span></span><br><span class="line">[user_a@demo ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on demo:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum</span><br><span class="line"></span><br><span class="line">[user_d@demo ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on demo:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum, /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br></pre></td></tr></table></figure><h4 id="3-sudo-命令的执行流程"><a href="#3-sudo-命令的执行流程" class="headerlink" title="3.sudo 命令的执行流程:"></a>3.sudo 命令的执行流程:</h4><blockquote><ol><li>普通用户执行 sudo 命令时，会检查 /var/db/sudo 是否存在时间戳缓存</li><li>如果存在则不需要输入密码，否则需要输入用户与密码</li><li>输入密码会检测该用户是否拥有该权限</li><li>如果有则执行，否则报错退出</li></ol></blockquote><h3 id="4-sudo-不支持系统内置命令"><a href="#4-sudo-不支持系统内置命令" class="headerlink" title="4.sudo 不支持系统内置命令"></a>4.sudo 不支持系统内置命令</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h4><blockquote><p>我想要 <code>cd</code> 到 <code>/etc/docker</code>，但是它给我一个权限不够的错误，然后，我想到使用 <code>sudo cd /etc/docker</code> 时，它告诉我 <code>sudo: cd：</code>找不到命令。</p><p>于是，就去上网找了下原因。</p></blockquote><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h4><blockquote><p>cd 不是一个应用程序而是 Linux 内建的命令，而 sudo 仅仅只对应用程序起作用。</p><p>sudo foo 只意味着以 root 权限运行 foo 程序</p><p>所以，sudo cd /etc/docker 会报 sudo: cd：找不到命令。</p><p>验证</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p>【注意】：关于 cd 是不是内建命令，OS X 10.8 中 cd 不是内建命令（可以参考 what-is-the-point-of-the-cd-external-command），具体其他的版本的 OS X 我就不清楚了，大部分的 Linux 系列（Ubuntu、CentOS 和 ArchLinux）中 cd 都是内建命令</p>          </div><h4 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h4><ul><li>使用 <code>sudo -i</code> 命令提升用户权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># sudo -i</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /etc/docker</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>sudo -s</code> 命令打开特殊 shell</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># sudo -s</span></span><br><span class="line">[root@demo ~]<span class="comment"># cd /etc/docker</span></span><br></pre></td></tr></table></figure><blockquote><p>上面都可以使用 exit 命令退出，也可以使用 Ctrl+D 快捷键退出！</p></blockquote>]]></content>
    
    
    <summary type="html">Linux 用户管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 用户管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件编辑</title>
    <link href="https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/"/>
    <id>https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/</id>
    <published>2018-01-02T17:30:00.000Z</published>
    <updated>2020-08-23T02:59:20.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Linux-vi-vim"><a href="#1-Linux-vi-vim" class="headerlink" title="1.Linux vi/vim"></a>1.Linux vi/vim</h2><blockquote><p>所有的 Unix Like (类 UNIX) 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。<br>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p></blockquote><h2 id="2-VIM-基本概述"><a href="#2-VIM-基本概述" class="headerlink" title="2.VIM 基本概述"></a>2.VIM 基本概述</h2><h3 id="1-什么是-vim？"><a href="#1-什么是-vim？" class="headerlink" title="1.什么是 vim？"></a>1.什么是 vim？</h3><blockquote><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。<br>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。<br>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><ul><li>vim键盘图</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/1.jpg" alt="1"></p></blockquote><h3 id="2-vi-vim-的使用"><a href="#2-vi-vim-的使用" class="headerlink" title="2.vi/vim 的使用"></a>2.vi/vim 的使用</h3><blockquote><p>基本上 vi/vim 共分为三种模式，分别是:</p><ul><li>1.命令模式（Command mode）</li><li>2.输入模式（Insert mode）</li><li>3.底线命令模式（Last line mode）</li></ul><p>这三种模式的作用分别是：<br><strong>1.命令模式：</strong><br>用户刚刚启动 vi/vim，便进入了命令模式。<br>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一&gt;个字符，i 被当作了一个命令。<br>以下是常用的几个命令：<br><strong>i 切换到输入模式，以输入字符。</strong><br><strong>x 删除当前光标所在处的字符。</strong><br><strong>：切换到底线命令模式，以在最底一行输入命令。</strong><br><strong>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</strong><br>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><p><strong>2.输入模式：</strong><br>在命令模式下按下 i 就进入了输入模式。<br>在输入模式中，可以使用以下按键：<br><strong>字符按键以及 Shift 组合，输入字符</strong><br><strong>ENTER，回车键，换行</strong><br><strong>BACK SPACE，退格键，删除光标前一个字符</strong><br><strong>DEL，删除键，删除光标后一个字符</strong><br><strong>方向键，在文本中移动光标</strong><br><strong>HOME/END，移动光标到行首 / 行尾</strong><br><strong>Page Up/Page Down，上 / 下翻页</strong><br><strong>Insert，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</strong><br><strong>ESC，退出输入模式，切换到命令模式</strong></p><p><strong>3.底线命令模式：</strong><br>在命令模式下按下:（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>在底线命令模式中，基本的命令有（已经省略了冒号）：<br><strong>q 退出程序</strong><br><strong>w 保存文件</strong><br><strong>按 ESC 键可随时退出底线命令模式。</strong></p><p>vim/vi 三种工作模式，如下图所示：<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/03/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/2.jpg" alt="2"></p></blockquote><h2 id="3-vi-vim-使用范例"><a href="#3-vi-vim-使用范例" class="headerlink" title="3.vi/vim 使用范例"></a>3.vi/vim 使用范例</h2><ul><li><strong>1.一般模式</strong></li></ul><table><thead><tr><th align="left">移动光标的方法</th><th align="left"></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键 (←)</td><td align="left">光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键 (↓)</td><td align="left">光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键 (↑)</td><td align="left">光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键 (→)</td><td align="left">光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数 (数字) 后，按下动作即可！</td><td align="left"></td></tr><tr><td align="left">[Ctrl] + [f]</td><td align="left">屏幕『向下』移动一页，相当于 [Page Down] 按键 <mark>(常用)</mark></td></tr><tr><td align="left">[Ctrl] + [b]</td><td align="left">屏幕『向上』移动一页，相当于 [Page Up] 按键 <mark>(常用)</mark></td></tr><tr><td align="left">[Ctrl] + [d]</td><td align="left">屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td align="left">屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td align="left">光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td align="left">光标移动到非空格符的上一行</td></tr><tr><td align="left">n</td><td align="left">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="left">0</td><td align="left">或功能键 [Home]    这是数字『 0 』：移动到这一行的最前面字符处 <mark>(常用)</mark></td></tr><tr><td align="left">$</td><td align="left">或功能键 [End]    移动到这一行的最后面字符处 <mark>(常用)</mark></td></tr><tr><td align="left">H</td><td align="left">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td align="left">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td align="left">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td align="left">移动到这个文档的最后一行 <mark>(常用)</mark></td></tr><tr><td align="left">nG</td><td align="left">n 为数字。移动到这个文档的第 n 行。例如 20G 则会移动到这个文档的第 20 行 (可配合 :set nu)</td></tr><tr><td align="left">gg</td><td align="left">移动到这个文档的第一行，相当于 1G 啊！ <mark>(常用)</mark></td></tr><tr><td align="left">n</td><td align="left">n 为数字。光标向下移动 n 行 <mark>(常用)</mark></td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th></th></tr></thead><tbody><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ <mark>(常用)</mark></td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行？vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td></tr><tr><td align="left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/</td></tr><tr><td align="left">:1,$s/word1/word2/g 或 :% s/word1/word2/g</td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！<mark>(常用)</mark></td></tr><tr><td align="left">:1,$s/word1/word2/gc 或 :% s/word1/word2/gc</td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！<mark>(常用)</mark></td></tr></tbody></table><table><thead><tr><th align="left">删除、复制、粘贴</th><th></th></tr></thead><tbody><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符 (相当于 [backspace] 亦即是退格键) <mark>(常用)</mark></td></tr><tr><td align="left">nx</td><td>n为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行 <mark>(常用)</mark></td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 <mark>(常用)</mark></td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行 <mark>(常用)</mark></td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行 <mark>(常用)</mark></td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 <mark>(常用)</mark></td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[10cj]</td></tr><tr><td align="left">u</td><td>复原前一个动作。<mark>(常用)</mark></td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。<mark>(常用)</mark></td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ <mark>(常用)</mark></td></tr></tbody></table><ul><li><strong>2.编辑模式</strong></li></ul><table><thead><tr><th align="left">进入编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式 (Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 <mark>(常用)</mark></td></tr><tr><td align="left">a, A</td><td>进入输入模式 (Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。<mark>(常用)</mark></td></tr><tr><td align="left">o, O</td><td>进入输入模式 (Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！<mark>(常用)</mark></td></tr><tr><td align="left">r, R</td><td>进入取代模式 (Replace mode)：r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；<mark>(常用)</mark></td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！</td><td></td></tr><tr><td align="left">特别注意的是，我们上面也提过了，你想要在文档里面输入字符时，一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中 <mark>(常用)</mark></td></tr></tbody></table><ul><li><strong>3.命令行模式</strong></li></ul><table><thead><tr><th align="left">指令行的存储、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘中 <mark>(常用)</mark></td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该文档。不过，到底能不能写入， 还是跟你对该文档的文档权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi <mark>(常用)</mark></td></tr><tr><td align="left">:q!</td><td>若曾修改过文档，又不想储存，使用！为强制离开不储存文档。注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 <mark>(常用)</mark></td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于 (保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 :q!。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个文档（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个文档的数据。亦即将 『filename』 这个文档内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个文档。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文档信息！</td></tr></tbody></table><ul><li><strong>4.视图模式</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">        1.插入:按<span class="built_in">shift</span>+i进入编辑模式,输入<span class="comment">#,结束按ESC键</span></span><br><span class="line">        2.删除:选中内容后，按x或者d键删除</span><br><span class="line">        3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="built_in">shift</span>+v 进入可视行模式，选中整行内容</span><br><span class="line">        1.复制:选中行内容后按y键及可复制。</span><br><span class="line">        2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-vim-扩展"><a href="#4-vim-扩展" class="headerlink" title="4.vim 扩展"></a>4.vim 扩展</h2><h3 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1. 环境变量临时生效"></a>1. 环境变量临时生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu             <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> ic             <span class="comment">#忽略大小写, 在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai             <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list           <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line">:<span class="built_in">set</span> no[nu|ic|ai…]  <span class="comment">#取消临时设定的变量</span></span><br></pre></td></tr></table></figure><h3 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量 (优先级高) /etc/vimrc 全局环境变量"></a>2.环境变量永久生效。~/.vimrc 个人环境变量 (优先级高) /etc/vimrc 全局环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim  ~/.vimrc #当下次再打开文件自动显示行号并忽略大小写</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span></span><br><span class="line"><span class="comment">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span></span><br></pre></td></tr></table></figure><h3 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3. 如何同时编辑多个文件"></a>3. 如何同时编辑多个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim -o file1 file2  <span class="comment">#水平分割</span></span><br><span class="line">vim -O file1 file2  <span class="comment">#垂直分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ctrl+ww 文件间切换</span></span><br></pre></td></tr></table></figure><h3 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4. 相同文件之间差异对比，通常用于对比修改前后差异"></a>4. 相同文件之间差异对比，通常用于对比修改前后差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># diff      #文件对比   </span></span><br><span class="line"><span class="comment"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span></span><br></pre></td></tr></table></figure><h3 id="5-如果-VIM-非正常退出-（ctrl-z）挂起或强制退出终端没关闭-VIM-后"><a href="#5-如果-VIM-非正常退出-（ctrl-z）挂起或强制退出终端没关闭-VIM-后" class="headerlink" title="5.如果 VIM 非正常退出 （ctrl+z）挂起或强制退出终端没关闭 VIM 后"></a>5.如果 VIM 非正常退出 （ctrl+z）挂起或强制退出终端没关闭 VIM 后</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span></span><br><span class="line"><span class="comment"># rm -f .filename.swp</span></span><br></pre></td></tr></table></figure><h3 id="6-vim-中批量添加注释"><a href="#6-vim-中批量添加注释" class="headerlink" title="6.vim 中批量添加注释"></a>6.vim 中批量添加注释</h3><blockquote><p>方法一 ：块选择模式<br>批量注释：<br>Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 // 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p><p>取消注释：<br>Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 // 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。</p><p>方法二：替换命令<br>批量注释。<br>使用下面命令在指定的行首添加注释。<br>使用名命令格式： : 起始行号，结束行号 s/^/ 注释符 /g（注意冒号）。</p><p>取消注释：<br>使用名命令格式： : 起始行号，结束行号 s/^ 注释符 //g（注意冒号）。</p><p>例子：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、在 10 - 20 行添加 // 注释</span><br><span class="line">:10,20s<span class="comment">#^#//#g</span></span><br><span class="line"></span><br><span class="line">2、在 10 - 20 行删除 // 注释</span><br><span class="line">:10,20s<span class="comment">#^//##g</span></span><br><span class="line"></span><br><span class="line">3、在 10 - 20 行添加 <span class="comment"># 注释</span></span><br><span class="line">:10,20s/^/<span class="comment">#/g</span></span><br><span class="line"></span><br><span class="line">4、在 10 - 20 行删除 <span class="comment"># 注释</span></span><br><span class="line">:10,20s/<span class="comment">#//g</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 文件编辑</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 文件编辑" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件管理</title>
    <link href="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2018-01-02T15:30:00.000Z</published>
    <updated>2020-08-23T02:55:25.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h2><blockquote><p>说到 Linux 文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等，例如：当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</p></blockquote><h2 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h2><blockquote><p>计算机操作系统都是使用目录结构组织文件，具体来说就是在一个目录中存放子目录和文件，而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支， 所以该结构又被称为” 目录树 “。Windows: 以多根的方式组织文件 C:\ D:\ ，Linux: 以单根的方式组织文件。如下图为 Centos7 的目录结构<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/1.jpg" alt="1"></p></blockquote><h3 id="1-存放命令相关的目录"><a href="#1-存放命令相关的目录" class="headerlink" title="1.存放命令相关的目录"></a>1.存放命令相关的目录</h3><blockquote><ol><li><strong>/bin： /usr/bin：普通用户可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等。</strong></li><li><strong>/sbin：/usr/sbin：/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能” 查看” 而不能设置和使用。</strong></li></ol></blockquote><h3 id="2-存放用户相关数据家目录"><a href="#2-存放用户相关数据家目录" class="headerlink" title="2.存放用户相关数据家目录"></a>2.存放用户相关数据家目录</h3><blockquote><ol><li><strong>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，默认为 /home/username。</strong></li><li><strong>/root：超级管理员 root 的家目录，普通用户无权操作</strong></li></ol></blockquote><h3 id="3-系统文件目录"><a href="#3-系统文件目录" class="headerlink" title="3.系统文件目录"></a>3.系统文件目录</h3><blockquote><ol><li><strong>/usr： 应用程序存放目录</strong></li><li><strong>/usr/local：存放软件升级包</strong></li><li><strong>/usr/bin：普通用户使用应用程序</strong></li><li><strong>/usr/sbin：超级用户使用应用程序</strong></li><li><strong>/usr/share： 存放共享数据</strong></li><li><strong>/usr/lib： 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</strong></li><li><strong>/usr/share/doc： 系统说明文件存放目录</strong></li><li><strong>/usr/share/man：程序说明文件存放目录，使用 man ls 时会查询</strong></li></ol></blockquote><h3 id="4-启动目录"><a href="#4-启动目录" class="headerlink" title="4.启动目录"></a>4.启动目录</h3><blockquote><ol><li><strong>/boot：存放的系统启动相关的文件，例如:kernel，grub (引导装载程序)</strong></li></ol></blockquote><h3 id="5-配置文件目录"><a href="#5-配置文件目录" class="headerlink" title="5.配置文件目录"></a>5.配置文件目录</h3><blockquote><ol><li><strong>/etc：极其重要，所有服务的配置都在这个目录中，不建议在此目录下存放可执行文件，重要的配置文件修改配置文件之前记得备份</strong></li><li><strong>/etc/sysconfig/network-script/ifcfg-：网络配置文件</strong></li><li><strong>/etc/hostname：系统主机名配置文件</strong></li><li><strong>/usr/sbin：超级用户使用应用程序</strong></li><li><strong>/etc/resolv.conf：dns 客户端配置文件</strong></li><li><strong>/etc/hosts：本地域名解析配置文件</strong></li></ol></blockquote><h3 id="6-可变的目录与临时目录"><a href="#6-可变的目录与临时目录" class="headerlink" title="6.可变的目录与临时目录"></a>6.可变的目录与临时目录</h3><blockquote><ol><li><strong>/var：存放一些变化文件，比如 /var/log/ 下的日志文件</strong></li><li><strong>/var/tmp：进程产生的临时文件</strong></li><li><strong>/tmp：系统临时目录</strong></li></ol></blockquote><h3 id="7-设备目录文件"><a href="#7-设备目录文件" class="headerlink" title="7.设备目录文件"></a>7.设备目录文件</h3><blockquote><ol><li><strong>/dev：存放设备文件，比如硬盘，硬盘分区，光驱，等等</strong></li><li><strong>/dev/null：黑洞设备，只进不出。类似于垃圾回收站</strong></li><li><strong>/dev/random：生成随机数的设备</strong></li><li><strong>/dev/zero：能远远不断的产生数据，类似于取款机，随时随地取钱</strong></li></ol></blockquote><h3 id="8-虚拟的文件系统-如对应的进程停止则-proc-下对应目录则会被删除"><a href="#8-虚拟的文件系统-如对应的进程停止则-proc-下对应目录则会被删除" class="headerlink" title="8.虚拟的文件系统 (如对应的进程停止则 /proc 下对应目录则会被删除)"></a>8.虚拟的文件系统 (如对应的进程停止则 /proc 下对应目录则会被删除)</h3><blockquote><ol><li><strong>/proc，反映系统当前进程的实时状态</strong><br><mark>【类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了】</mark></li></ol></blockquote><h3 id="9-在-Linux7-系统中-bin-sbin-lib-lib64-都以软链接的形式链接到-usr-目录下"><a href="#9-在-Linux7-系统中-bin-sbin-lib-lib64-都以软链接的形式链接到-usr-目录下" class="headerlink" title="9.在 Linux7 系统中 /bin, /sbin, /lib, /lib64 都以软链接的形式链接到 /usr/ 目录下"></a>9.在 Linux7 系统中 /bin, /sbin, /lib, /lib64 都以软链接的形式链接到 /usr/ 目录下</h3><blockquote><ol><li><strong>/bin –&gt; /usr/bin</strong></li><li><strong>/sbin –&gt; /usr/sbin</strong></li><li><strong>lib -&gt; usr/lib</strong></li><li><strong>lib64 -&gt; usr/lib64</strong></li></ol></blockquote><h2 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h2><blockquote><p>在开始操作文件前，首先需要对文件进行定位，比如：需要在什么地方创建什么文件？你要将文件复制到什么地方？或者你要删除的文件在什么地方？那什么是定位？比如 /etc/hostname，整个文件中包含文件名称以及文件所在的位置，这个就叫做路径，那么路径就是对文件进行定位的一种方式。</p></blockquote><h3 id="1-每个目录下都有一个-和-的目录是什么？"><a href="#1-每个目录下都有一个-和-的目录是什么？" class="headerlink" title="1.每个目录下都有一个 . 和 ..  的目录是什么？"></a>1.每个目录下都有一个 . 和 ..  的目录是什么？</h3><blockquote><p>一个点代表当的是当前目录，两个点代表的是当前目录的上层目录。假设当前目录在 /usr/ 下，那么它的上层 (/) 目录用../ 表示，而 /usr/ 的下层 (local) 目录则用./local 表示。</p></blockquote><h3 id="2-那什么是绝对路径，什么又是相对路径呢？"><a href="#2-那什么是绝对路径，什么又是相对路径呢？" class="headerlink" title="2.那什么是绝对路径，什么又是相对路径呢？"></a>2.那什么是绝对路径，什么又是相对路径呢？</h3><blockquote><ol><li><strong>绝对路径：只要从 / 开始的路径，比如 /home/alice/file</strong></li><li><strong>相对路径：相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3</strong></li><li><strong>小结：所谓的 (.) 和 (..) 目录实际上属于相对路径的一种表示形式</strong></li></ol></blockquote><h3 id="3-绝对路径与相对路径示例"><a href="#3-绝对路径与相对路径示例" class="headerlink" title="3.绝对路径与相对路径示例"></a>3.绝对路径与相对路径示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">[root@demo /]<span class="comment"># useradd alice</span></span><br><span class="line">[root@demo /]<span class="comment"># touch /home/alice/file1</span></span><br><span class="line">[root@demo /]<span class="comment"># touch ~/file2</span></span><br><span class="line">[root@demo /]<span class="comment"># touch ~alice/file3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对路径</span></span><br><span class="line">[root@demo /]<span class="comment"># mkdir abc</span></span><br><span class="line">[root@demo /]<span class="comment"># touch ../file3</span></span><br><span class="line">[root@demo /]<span class="comment"># touch file4</span></span><br><span class="line">[root@demo /]<span class="comment"># touch abc/file5</span></span><br></pre></td></tr></table></figure><h3 id="4-cd-改变目录，常见的使用方法"><a href="#4-cd-改变目录，常见的使用方法" class="headerlink" title="4.cd 改变目录，常见的使用方法"></a>4.cd 改变目录，常见的使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd 绝对路径 cd /etc/hostname</span></span><br><span class="line"><span class="comment"># cd 相对路径 cd test/abc cd . cd ..</span></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line"><span class="comment"># cd      #切换目录，例: cd /etc</span></span><br><span class="line"><span class="comment"># cd -    #切换回上一次所在的目录</span></span><br><span class="line"><span class="comment"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span></span><br><span class="line"><span class="comment"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp /etc/hostname ./</span></span><br><span class="line"><span class="comment"># cd ..   #切换回当前目录的上级目录</span></span><br></pre></td></tr></table></figure><h2 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><h4 id="1-文件创建命令-touch"><a href="#1-文件创建命令-touch" class="headerlink" title="1.文件创建命令 touch"></a>1.文件创建命令 touch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch file</span></span><br><span class="line"><span class="comment"># touch file2 file3</span></span><br><span class="line"><span class="comment"># touch /home/od/file4 file5</span></span><br><span class="line"><span class="comment"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch file&#123;a..z&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-目录创建命令-mkdir"><a href="#2-目录创建命令-mkdir" class="headerlink" title="2.目录创建命令 mkdir"></a>2.目录创建命令 mkdir</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选项：-v 显示详细信息  -p 递归创建目录</span></span><br><span class="line"><span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment"># mkdir /home/od/dir1 /home/od/dir2</span></span><br><span class="line"><span class="comment"># mkdir -v /home/od/&#123;dir3,dir4&#125; </span></span><br><span class="line"><span class="comment"># mkdir -pv /home/od/dir5/dir6</span></span><br><span class="line"><span class="comment"># mkdir -pv /home/&#123;od/&#123;diu,but&#125;,boy&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-以树状显示目录结构命令-tree"><a href="#3-以树状显示目录结构命令-tree" class="headerlink" title="3.以树状显示目录结构命令 tree"></a>3.以树状显示目录结构命令 tree</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选项: -L: 显示目录树的层级</span></span><br><span class="line"><span class="comment"># tree /home/od/    #显示当前目录下的结构</span></span><br><span class="line">/home/od/</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure><h3 id="2-cp-复制"><a href="#2-cp-复制" class="headerlink" title="2.cp 复制"></a>2.cp 复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp file /tmp/file_copy</span></span><br><span class="line"><span class="comment"># cp name /tmp/name         #不修改名称</span></span><br><span class="line"><span class="comment"># cp file /tmp/             #不修改名称</span></span><br><span class="line"><span class="comment"># cp -p file /tmp/file_p    #-p保持原文件或目录的属性</span></span><br><span class="line"><span class="comment"># cp -r  /etc/ /tmp/        #复制目录需要使用-r参数, 递归复制</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp  #拷贝多个文件至一个目录</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-mv-移动"><a href="#3-mv-移动" class="headerlink" title="3.mv 移动"></a>3.mv 移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mv file file1             #原地移动算改名</span></span><br><span class="line"><span class="comment"># mv file1 /tmp/            #移动文件至tmp目录</span></span><br><span class="line"><span class="comment"># mv /tmp/file1 ./          #移动tmp目录的文件至当前目录</span></span><br><span class="line"><span class="comment"># mv dir/ /tmp/             #移动目录至/tmp目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/    #移动多个文件或至同一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt     #移动多个目录至同一个目录</span></span><br></pre></td></tr></table></figure><h3 id="4-rm-删除"><a href="#4-rm-删除" class="headerlink" title="4.rm 删除"></a>4.rm 删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span></span><br><span class="line"><span class="comment"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span></span><br><span class="line"><span class="comment"># rm -f file.txt    #删除文件, 不提醒</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment"># rm -r dir/        #递归删除目录，会提示</span></span><br><span class="line"><span class="comment"># rm -rf dir/       #强制删除目录,不提醒(慎用)</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#1.rm删除示例</span></span><br><span class="line"><span class="comment"># mkdir /home/dir10</span></span><br><span class="line"><span class="comment"># touch /home/dir10/&#123;file2,file3,.file4&#125;</span></span><br><span class="line"><span class="comment"># rm -f /home/dir10/*  //不包括隐藏文件 </span></span><br><span class="line"><span class="comment"># ls /home/dir10/ -a</span></span><br><span class="line">. .. .file4</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#2.rm删除示例2</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch &#123;1..10&#125;.pdf</span></span><br><span class="line"><span class="comment"># rm -rf file* </span></span><br><span class="line"><span class="comment"># rm -rf *.pdf</span></span><br></pre></td></tr></table></figure><h3 id="5-查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#5-查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="5.查看文件内容 (cat tac less more head tail tailf grep …)"></a>5.查看文件内容 (cat tac less more head tail tailf grep …)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------cat</span></span><br><span class="line"><span class="comment"># cp /etc/passwd ./pass</span></span><br><span class="line"><span class="comment"># cat pass      #正常查看文件方式</span></span><br><span class="line"><span class="comment"># cat -n pass   #-n显示文件有多少行</span></span><br><span class="line"><span class="comment"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span></span><br><span class="line"><span class="comment"># tac pass      #倒序查看文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------less、more</span></span><br><span class="line"><span class="comment"># less /etc/services    #使用光标上下翻动，空格进行翻页，q退出</span></span><br><span class="line"><span class="comment"># more /etc/services    #使用回车上下翻动，空格进行翻页，q退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------head</span></span><br><span class="line"><span class="comment"># head pass     #查看头部内容，默认前十行</span></span><br><span class="line"><span class="comment"># head -n5 pass #查看头部5行，使用-n指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------tail</span></span><br><span class="line"><span class="comment"># tail pass</span></span><br><span class="line"><span class="comment"># tail -20 /var/log/secure</span></span><br><span class="line"><span class="comment"># tail -f /var/log/messages #-f查看文件尾部的变化</span></span><br><span class="line"><span class="comment"># tailf /var/log/messages   #查看文件尾部的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------grep过滤文件内容</span></span><br><span class="line"><span class="comment"># grep &quot;^root&quot; pass     #匹配以root开头的行</span></span><br><span class="line"><span class="comment"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span></span><br><span class="line"><span class="comment"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span></span><br><span class="line"><span class="comment"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span></span><br><span class="line"><span class="comment"># grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的下2行</span></span><br><span class="line"><span class="comment"># grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上2行</span></span><br><span class="line"><span class="comment"># grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上下2行</span></span><br></pre></td></tr></table></figure><h3 id="6-联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#6-联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="6.联网下载文件 (wget、curl)、文件上传与下载 (rz、sz)"></a>6.联网下载文件 (wget、curl)、文件上传与下载 (rz、sz)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选项: -O: 指定下载地址</span></span><br><span class="line"><span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项: -o: 指定下载地址</span></span><br><span class="line"><span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yum install lrzsz -y  #不安装软件则无法执行该命令</span></span><br><span class="line"><span class="comment"># rz            #只能上传文件</span></span><br><span class="line"><span class="comment"># sz /path/file #只能下载文件</span></span><br></pre></td></tr></table></figure><h3 id="7-文件或命令查找-locate、which、whereis、find"><a href="#7-文件或命令查找-locate、which、whereis、find" class="headerlink" title="7.文件或命令查找 (locate、which、whereis、find)"></a>7.文件或命令查找 (locate、which、whereis、find)</h3><blockquote><p>1.文件查找</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># locate /etc/sh       #搜索etc目录下所有以sh开头的文件</span></span><br><span class="line"><span class="comment"># locate -i /etc/sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span></span><br></pre></td></tr></table></figure><blockquote><p>2.命令查找</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which ls  #查找ls命令的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis ls       #查找命令的路径、帮助手册、等</span></span><br><span class="line"><span class="comment"># whereis -b ls    #仅显示命令所在的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -a ls       #查看命令的绝对路径(包括别名)</span></span><br></pre></td></tr></table></figure><h3 id="8-字符处理命令-sort、uniq、cut、sed、awk、wc"><a href="#8-字符处理命令-sort、uniq、cut、sed、awk、wc" class="headerlink" title="8.字符处理命令 (sort、uniq、cut、sed、awk、wc)"></a>8.字符处理命令 (sort、uniq、cut、sed、awk、wc)</h3><blockquote><p>1.sort 排序</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"><span class="comment"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort file.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@demo ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat ip.txt </span></span><br><span class="line">192.168.3.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.3.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.2.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.0.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.1.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.1.12 00:30:15:A2:3A:A1</span><br><span class="line">192.168.1.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.2.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.1.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.1.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.3.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.3.12 00:30:15:A2:3A:A1</span><br><span class="line"></span><br><span class="line">[答案]: sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span><br></pre></td></tr></table></figure><blockquote><p>2.uniq 去重</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line"><span class="comment">#选项：-c  计算重复的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建一个file.txt文件:</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"><span class="comment">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt |sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure><blockquote><p>3.cut 截取字段</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line"><span class="comment">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span></span><br><span class="line"><span class="comment">#echo &quot;Im demo, is QQ 123456&quot; &gt;file.txt   #过滤出文件里 demo以及123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>4.统计行号</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line"><span class="comment">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure><blockquote><p>练习：分析如下日志，统计每个域名被访问的次数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@student tmp]<span class="comment"># cat web.log </span></span><br><span class="line">http://www.demo.com/index.html</span><br><span class="line">http://www.demo.com/1.html</span><br><span class="line">http://post.demo.com/index.html</span><br><span class="line">http://mp3.demo.com/index.html</span><br><span class="line">http://www.demo.com/3.html</span><br><span class="line">http://post.demo.com/2.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># awk -F &#x27;/&#x27; &#x27;&#123;print $3&#125;&#x27; web.log|sort -rn|uniq –c</span></span><br><span class="line"><span class="comment"># cut -d / -f3 web.log|sort -rn|uniq –c</span></span><br></pre></td></tr></table></figure><h2 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ls anaconda-ks.cfg -l</span></span><br><span class="line">-rw-------. 1 root root 1523 Aug  6 00:37 anaconda-ks.cfg  <span class="comment">#文件属性，文件的属性分为十列</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">1523        ⑤:文件大小</span><br><span class="line">Aug6 00:37 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">anaconda-ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure><h2 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h2><blockquote><p>通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过 ls -l 以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ll -d /etc/hosts /tmp /bin/ls  /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client</span></span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 /bin/ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 /dev/<span class="built_in">log</span></span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 /dev/sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 /dev/tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 /etc/grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 /etc/hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 /run/dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">-   <span class="comment">#普通文件(文本, 二进制, 压缩, 图片, 日志等) </span></span><br><span class="line">d   <span class="comment">#目录文件</span></span><br><span class="line">b   <span class="comment">#设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2</span></span><br><span class="line">c   <span class="comment">#设备文件(字符设备)，终端 /dev/tty1, /dev/zero</span></span><br><span class="line">s   <span class="comment">#套接字文件, 进程间通信(socket)</span></span><br><span class="line">p   <span class="comment">#管道文件</span></span><br><span class="line">l   <span class="comment">#链接文件</span></span><br></pre></td></tr></table></figure><blockquote><p>但有些情况下，我们无法通过 ls -l 文件的类型，比如：一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用 file 来更加精准的判断这个文件的类型。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># file /etc/hosts</span></span><br><span class="line">/etc/hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /dev/sda</span></span><br><span class="line">/dev/sda: block special</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /dev/tty1</span></span><br><span class="line">/dev/tty1: character special</span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># file /etc/grub2.cfg</span></span><br><span class="line">/etc/grub2.cfg: broken symbolic link to `../boot/grub2/grub.cfg<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@demo ~]# file /home</span></span><br><span class="line"><span class="string">/home: directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@demo ~]# file /run/dmeventd-client</span></span><br><span class="line"><span class="string">/run/dmeventd-client: fifo (named pipe)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@demo ~]# ll but</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span></span><br><span class="line"><span class="string">[root@xuliangwei ~]# file but</span></span><br><span class="line"><span class="string">but: Zip archive data, at least v1.0 to extract</span></span><br></pre></td></tr></table></figure><h2 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h2><blockquote><p>文件有文件名与数据，在 Linux 中数据又分为两种：</p><p><strong>1.元数据，既属性数据：metadata</strong>，它包含文件的文件名 (filename)、大小 (size)、占用了多少&gt;个数据块 (block)、节点号 inode、链接 (links)、等等信息。。。<br><strong>2.数据本身：data</strong><br>在 Linux 中，inode 是文件元数据的一部分但其并不包含文件名，文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。下图展示了程序通过文件名获取文件内容的过程。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2.jpg" alt="2"></p><h3 id="1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link）"><a href="#1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link）" class="headerlink" title="1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）"></a>1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）</h3><blockquote><p>1.软链接，软链接相当于 Windows 的快捷方式，软链接文件会将 inode 指向源文件的 block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个 inode 指向同一个 block。当我们删除软链接文件时，其实只是删除了一个 inode 指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/3.jpg" alt="3"></p></blockquote><blockquote><p>2.硬链接，一个 inode 号对应多个文件名，换言之，硬链接就是同一个文件使用了多个别名，如下图 hard link 就是 file 的一个别名，他们有共同的 inode。<br><img src= "https://cdn.jsdelivr.net/gh/demon869/HexoStaticFile@1.0.3/source/img/loading.gif" data-lazy-src="https://www.demon-w.com/2018/01/02/Linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/4.jpg" alt="4"></p></blockquote><blockquote><p>3.软链接实践</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件软链接示例</span></span><br><span class="line">touch /root/file</span><br><span class="line">ln -s /root/file /tmp/file_bak    <span class="comment">#root下file链接到/tmp下并重命名为file_bak</span></span><br><span class="line">ll /tmp/file_bak      <span class="comment">#查看链接指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目录软链接示例</span></span><br><span class="line">mkdir /soft/nginx1.1 -p</span><br><span class="line">ln -s /soft/nginx1.1/ /soft/nginx    <span class="comment">#将/soft/下nginx1.1链接到/soft下并重命名为nginx</span></span><br><span class="line">ll /soft/nginx   <span class="comment">#查看链接指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#软链接使用场景</span></span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure><blockquote><p>4.硬链接实践</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件硬链接示例</span></span><br><span class="line">ln  /root/file /tmp/file_hard <span class="comment">#将/root/下file链接到/tmp/下并重命名为file_hard</span></span><br><span class="line">ll /tmp/file_hard    <span class="comment">#查看链接指向</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>【注意】：目录不能创建硬链接，硬链接文件可以用 rm 命令删除</p>          </div><blockquote><p>5.硬链接与软链接区别</p><ol><li>ln 命令创建硬链接，ln -s 命令创建软链接</li><li>目录不能创建硬链接，并且硬链接不可以跨越分区系统</li><li>目录软链接特别常用，并且软链接支持跨越分区系统</li><li>硬链接文件与源文件的 inode 相同，软链接文件与源文件 inode 不同</li><li>删除软链接文件，对源文件及硬链接文件无任何影响</li><li>删除文件的硬链接文件，对源文件及链接文件无任何影响</li><li>删除链接文件的源文件，对硬链接无影响，会导致软链接失效</li><li>删除源文件及其硬链接文件，整个文件会被真正的删除</li></ol></blockquote>]]></content>
    
    
    <summary type="html">Linux 文件管理</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 文件管理" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统命令行入门</title>
    <link href="https://www.demon-w.com/2018/01/01/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/"/>
    <id>https://www.demon-w.com/2018/01/01/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/</id>
    <published>2017-12-31T16:30:00.000Z</published>
    <updated>2020-08-23T02:48:54.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Bash-Shell-初步认识"><a href="#1-Bash-Shell-初步认识" class="headerlink" title="1.Bash Shell 初步认识"></a>1.Bash Shell 初步认识</h2><h3 id="1-什么是Bash-Shell？"><a href="#1-什么是Bash-Shell？" class="headerlink" title="1.什么是Bash Shell？"></a>1.什么是Bash Shell？</h3><blockquote><p>Shell 是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。当我们使用远程连接工具连接 Linux 服务，系统则会给打开一个默认的 shell，我们可在这个界面执行命令，比如：获取系统当前时间，创建一个用户等等。</p></blockquote><h3 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么?"></a>2.Bash Shell能干什么?</h3><blockquote><p>使用 Shell 实现对 Linux 系统的大部分管理</p><ul><li>1.文件管理</li><li>2.权限管理</li><li>3.用户管理</li><li>4.磁盘管理</li><li>5.网络管理</li><li>6.软件管理</li><li>7.等等。。。</li></ul></blockquote><h3 id="3-平时我们如何使用-Shell-呢？"><a href="#3-平时我们如何使用-Shell-呢？" class="headerlink" title="3.平时我们如何使用 Shell 呢？"></a>3.平时我们如何使用 Shell 呢？</h3><blockquote><ul><li>1.输入命令 –&gt; 效率低 –&gt; 适合少量的工作</li><li>2.Shell Script –&gt; 效率高–&gt; 适合复杂重复性的工作，例如：创建 100 个用户，单纯输入命令需要执行 100 次，而 Shell 脚本只需要几行命令即可完成 100 个用户的创建</li></ul></blockquote><h3 id="4-Shell-提示符"><a href="#4-Shell-提示符" class="headerlink" title="4.Shell 提示符"></a>4.Shell 提示符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># whoami   #代表root用户(超级管理员)</span></span><br><span class="line">root</span><br><span class="line">[root@demo ~]$ whoami   $代表普通用户</span><br><span class="line">jack</span><br></pre></td></tr></table></figure><h3 id="5-Shell-基础语法"><a href="#5-Shell-基础语法" class="headerlink" title="5.Shell 基础语法"></a>5.Shell 基础语法</h3><blockquote><p>命令行 bash shell，为用户提供输入， 执行命令的界面</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [arguments]</span><br><span class="line"><span class="comment">#命令    选项        参数</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># ls             #命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls -a          #命令+选项</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls -a /home/   #命令+选项+参数</span></span><br><span class="line"></span><br><span class="line">命令: 整条shell命令的主体</span><br><span class="line">选项: 用于调节命令的具体功能</span><br><span class="line">   以 <span class="string">&quot;-&quot;</span> 引导短格式选项(单个字符)，例如 <span class="string">&quot;-a&quot;</span></span><br><span class="line">   以 <span class="string">&quot;--&quot;</span> 引导长格式选项(多个字符)，例如 <span class="string">&quot;--color&quot;</span></span><br><span class="line">   多个短格式选项可以写在一起，只用一个 <span class="string">&quot;-&quot;</span> 引导，例如 <span class="string">&quot;-al&quot;</span></span><br><span class="line">参数: 命令操作的对象，如文件、目录名等</span><br></pre></td></tr></table></figure><div class="note danger">            <p>命令必须写在前，选项和参数位置可以发生变化</p>          </div><h2 id="2-Bash-Shell-基本特性"><a href="#2-Bash-Shell-基本特性" class="headerlink" title="2.Bash Shell 基本特性"></a>2.Bash Shell 基本特性</h2><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a>1.命令补全</h3><blockquote><p>当使用 windows 查找一个目录层级特别多的文件时，打开的效率会非常的慢，但如果使用 linux 查找一个目录层级特别多的文件时，可以通过 tab 键快速的补全</p></blockquote><div class="note success">            <p>tab 键可以实现命令补全，路径补全，在实际生产中 tab 补全往往是我们使用的最多的，因为可以减少执行命令以及路径出错率。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看ip时忘记具体了命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifcon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按下tab键会自动补全</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按一下tab键没有反应, 按两下tab键列出所有if开头的命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># if</span></span><br><span class="line"><span class="keyword">if</span>         ifconfig   ifenslave  ifrename</span><br><span class="line">ifcfg      ifdown     ifnames    ifup</span><br><span class="line"></span><br><span class="line"><span class="comment">#linux目录较深，经常使用tab键进行补全, 如果路径出错是没有办法补全</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls /etc/sysconfig/network-scripts/</span></span><br></pre></td></tr></table></figure><h3 id="2-命令快捷键"><a href="#2-命令快捷键" class="headerlink" title="2.命令快捷键"></a>2.命令快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a    <span class="comment">#光标跳转至正在输入的命令行的首部</span></span><br><span class="line">Ctrl + e    <span class="comment">#光标跳转至正在输入的命令行的尾部</span></span><br><span class="line">Ctrl + c    <span class="comment">#终止前台运行的程序</span></span><br><span class="line">Ctrl + d    <span class="comment">#在shell中，ctrl-d表示推出当前shell。</span></span><br><span class="line">Ctrl + z    <span class="comment">#将任务暂停，挂至后台</span></span><br><span class="line">Ctrl + l    <span class="comment">#清屏，和clear命令等效。</span></span><br><span class="line">Ctrl + k    <span class="comment">#删除从光标到行末的所有字符</span></span><br><span class="line">Ctrl + u    <span class="comment">#删除从光标到行首的所有字符</span></span><br><span class="line">Ctrl + r    <span class="comment">#搜索历史命令, 利用关键字</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>在命令行前加面加 “#” 则该命令不会被执行</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># #ls</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-历史命令-History"><a href="#3-历史命令-History" class="headerlink" title="3.历史命令 History"></a>3.历史命令 History</h3><blockquote><p>用于显示历史记录和执行过的指令命令，history 命令读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。该命令单独使用时，仅显示历史命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line"><span class="built_in">history</span> (选项) (参数)</span><br><span class="line">-w 保存命令历史到历史文件</span><br><span class="line">-c 清空命令历史记录, 不会清空文件</span><br><span class="line">-d 删除命令历史的第 N 条行</span><br><span class="line"></span><br><span class="line">1.使用双 !! 可执行上一条执行过的命令</span><br><span class="line">[root@demo ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">[root@demo ~]<span class="comment"># !!</span></span><br><span class="line">ls</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line"></span><br><span class="line">2.输入!6, 执行<span class="built_in">history</span>命令历史中第 6 行命令</span><br><span class="line">[root@demo ~]<span class="comment"># !6</span></span><br><span class="line">touch 1.txt</span><br><span class="line"></span><br><span class="line">3.使用!cat, 调用<span class="built_in">history</span>命令历史最近一次执行过的cat命令</span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">[root@demo ~]<span class="comment"># !cat</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">4.小技巧:</span><br><span class="line">[root@demo ~]<span class="comment"># ls /etc/passwd</span></span><br><span class="line">调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 <span class="string">&quot;.&quot;</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat</span></span><br><span class="line">[root@demo ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line">第二种方式, 输入!$</span><br><span class="line">[root@demo ~]<span class="comment"># ls !$</span></span><br><span class="line">ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure><h4 id="历史命令生产实践"><a href="#历史命令生产实践" class="headerlink" title="历史命令生产实践"></a>历史命令生产实践</h4><blockquote><p>显示执行历史记录时间:<br>1、默认情况下，history 并不记录命令的执行时间，分析起来很困难。可以使用 HISTTIMEFORMAT 在历史中显示 TIMESTAMP。<br>2、将 export HISTTIMEFORMAT=”% F % T “ 变量加入到～/.bashrc 中即可在登录后自动开启 history 时间戳了。添加完成后，执行 source ~/.bashrc 让其生效。仅针对当前账号有效。<br>3、其实 HISTTIMEFORMAT 的格式就是 strftime 函数的格式，比如上面的 “% F % T “，% F 表示显示出 Y-M-D 格式的日期，% T 表示显示出 H-M-S 这样格式的时间。<br>4、用 Ctrl+R 搜索历史命令；当执行了一串相当长的命令之后，用关键字搜索一下历史命令然后重新执行这条命令而不需要将整条命令再输一遍。方法是：按下 Ctrl+R 然后输入关键字。如搜索 ”date”，则显示历史的命令中含有 ”date” 的命令 date “+ 今天是:% F,% A, 时间是:% T. 准备吃饭去”。按回车，就可以重新执行这条命令了，而按左箭头键或右箭头键则可以直接修改，改完之后按回车执行，非常方便！<br><mark>【注：在命令行提示符下按下 Ctrl+R，终端将显示如下提示】</mark><br><code>[root@demo ~]#</code><br><code>(reverse-i-search)</code>‘: </p><p>#配置 HISTTIMEFORMAT 环境变量，给 history 记录添加上时间戳，效果是临时的<br><code>[root@demo ~]# export HISTTIMEFORMAT=&quot;%F %T &quot; #配置HISTTIMEFORMAT环境变量，给history记录添加上时间戳</code><br>#当我们再次执行 history 命令时，就会有时间戳<br><code>[root@demo ~]# export HISTTIMEFORMAT=&quot;%F %T &quot;</code><br><code>1 2020-08-14 00:15:39 ping baidu.com</code><br><code>2 2020-08-13 22:32:58 ls -al</code><br><code>3 2020-08-13 22:57:16 ls</code></p></blockquote><h3 id="3-命令别名"><a href="#3-命令别名" class="headerlink" title="3.命令别名"></a>3.命令别名</h3><blockquote><p>命令别名将用户经常使用的复杂命令简单化，可以用：”alias 别名名称 = 命令” 命令创建属于自己的命令别名，若要取消一个命令别名，则使用：”unalias 别名名称命令”</p><p>1.定义临时别名，wk 为查看 eth0 网卡别名<br><code>[root@demo ~]# alias wk=&#39;ifconfig&#39;</code><br><code>[root@demo ~]# wk</code></p><p>2.如果定义命令本身，会执行什么？<br><code>[root@demo ~]# alias ifconfig=&#39;ifconfig eth0&#39;</code><br>#会以绝对路径执行，调用命令本身<br><code>[root@demo ~]# /sbin/ifconfig</code><br>#通过 \ 转义字符，调用命令本身<br><code>[root@demo ~]# \ifconfig</code></p><p>3.取消别名<br><code>[root@demo ~]# unalias ifconfig</code></p><p>4.永久生效，/etc/bashrc<br><code>[root@demo ~]# echo &quot;alias ifconfig=&#39;ifconfig eth0&#39;&quot; &gt;&gt; /etc/bashrc</code></p></blockquote><h2 id="3-Bash-Shell-获取帮助"><a href="#3-Bash-Shell-获取帮助" class="headerlink" title="3.Bash Shell 获取帮助"></a>3.Bash Shell 获取帮助</h2><blockquote><p><strong>1.help 帮助</strong><br><strong>用法：命令 - -help</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># ls --help</span></span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 常见选项</span></span><br><span class="line">-a  <span class="comment">#查看目录下的所有文件，包括隐藏文件</span></span><br><span class="line">-l  <span class="comment">#以长格式的方式显示文件的详细内容</span></span><br><span class="line">-h  <span class="comment">#以人性化的方式显示内容，配合-l使用</span></span><br><span class="line">-d  <span class="comment">#只列出目录名，不列出目录以下的内容</span></span><br><span class="line">-t  <span class="comment">#按修改时间进行排序</span></span><br><span class="line">-i  <span class="comment">#显示文件的inode(该文件在该分区的一个编号)</span></span><br><span class="line"></span><br><span class="line">[root@demo ~]<span class="comment"># date --help</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@demo ~]<span class="comment"># date +%F   #查看日期</span></span><br><span class="line">2019-03-28</span><br><span class="line">[root@demo ~]<span class="comment"># date -s 12:00  #修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间不是用来查看，而是有其他的用途</span></span><br><span class="line">[root@demo ~]<span class="comment"># touch `date +%F`_file.txt</span></span><br><span class="line">[root@demo ~]<span class="comment"># ls</span></span><br><span class="line">2018-01-01_file.txt</span><br></pre></td></tr></table></figure><blockquote><p><strong>2.man 手册</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># man ls    #查看ls命令的手册</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>3.通过百度寻找帮助</strong></p></blockquote><h2 id="4-Bash-Shell-命令流程"><a href="#4-Bash-Shell-命令流程" class="headerlink" title="4.Bash Shell 命令流程"></a>4.Bash Shell 命令流程</h2><blockquote><p>当我们执行一个命令，整个命令执行流程如下:</p><ol><li>判断命令是否通过绝对路径执行</li><li>判断命令是否存在 alias 别名</li><li>判断用户输入的是内部命令还是外部命</li><li>Bash 内部命令直接执行，外部命令检测是否存在缓存</li><li>通过 PATH 路径查找命令，有执行，无报错</li></ol></blockquote><h3 id="1-什么是内部命令，什么是外部命令"><a href="#1-什么是内部命令，什么是外部命令" class="headerlink" title="1.什么是内部命令，什么是外部命令"></a>1.什么是内部命令，什么是外部命令</h3><blockquote><p><strong>内部命令:  shell 程序自带的命令。</strong><br><strong>外部命令：在系统 PATH 变量的某个路径下的可执行程序。</strong></p></blockquote><h3 id="2-如何检查用户输入的命令是内部命令还是外部命令"><a href="#2-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="2.如何检查用户输入的命令是内部命令还是外部命令"></a>2.如何检查用户输入的命令是内部命令还是外部命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># type -a cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"><span class="comment">#cd命令属于shell内部命令</span></span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># type -a  ping</span></span><br><span class="line">ping is /bin/ping</span><br><span class="line"><span class="comment">#ping属于外部命令, 同时会打印当前命令路径</span></span><br></pre></td></tr></table></figure><h3 id="3-如果是外置命令，Bash-可以通过查找-PATH-变量，获取该命令的绝对路径。"><a href="#3-如果是外置命令，Bash-可以通过查找-PATH-变量，获取该命令的绝对路径。" class="headerlink" title="3.如果是外置命令，Bash 可以通过查找 PATH 变量，获取该命令的绝对路径。"></a>3.如果是外置命令，Bash 可以通过查找 PATH 变量，获取该命令的绝对路径。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印当前环境变量目录</span></span><br><span class="line">[root@demo ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><p><mark>【PATH 由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到 Bash 解释器对 Linux 命令的查找】</mark></p><h3 id="4-如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索-PATH-路径。"><a href="#4-如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索-PATH-路径。" class="headerlink" title="4.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索 PATH 路径。"></a>4.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索 PATH 路径。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#表缓存命令所在位置</span></span><br><span class="line">[root@demo ~]<span class="comment"># hash</span></span><br><span class="line">hits    <span class="built_in">command</span></span><br><span class="line">   1    /usr/bin/tty</span><br><span class="line">   3    /sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#已缓存命令,如果移动位置会导致无法找到该命令</span></span><br><span class="line">[root@demo ~]<span class="comment"># mv /sbin/ifconfig /bin/</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig</span></span><br><span class="line">-bash: /sbin/ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除缓存过的ifconfig命令, 即可执行</span></span><br><span class="line">[root@demo ~]<span class="comment"># hash -d ifconfig</span></span><br><span class="line">[root@demo ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然可以清空缓存表</span></span><br><span class="line">[root@demo ~]<span class="comment"># hash -r</span></span><br></pre></td></tr></table></figure><div class="note danger">            <p>注意：命令缓存 hash 需要注意如下情况:<br>1.只要执行外部命令 1 次就会对该命令进行缓存<br>2.如果将命令移动了位置，该如何执行:<br>a. 使用绝对路径执行<br>b. 删除 hash 表的缓存指令</p>          </div><h3 id="命令执行流程总结"><a href="#命令执行流程总结" class="headerlink" title="命令执行流程总结"></a>命令执行流程总结</h3><blockquote><p><strong>当我们执行了一个 ping 命令之后，整个命令执行的流程步骤如下:</strong></p><ol><li>检查执行的命令是否使用的是绝对路径执行的。</li><li>检查 ping 命令是否存在 alias 别名</li><li>检查 ping 命令是内部命令还是外部命令</li><li>如果是内部命令 Bash 直接执行，如果是外部命令，首先检查 Hash 缓存，存在则直接调取</li><li>如果该命令不存在 Hash 缓存，则通过 PATH 路径进行逐行查找该命令所在的位置</li><li>如果 PATH 路径没有查找到该命令所在的路径，则返回错误码：command not found</li></ol></blockquote>]]></content>
    
    
    <summary type="html">Linux 系统命令行入门</summary>
    
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Linux 系统命令行入门" scheme="https://www.demon-w.com/categories/Linux%E5%9F%BA%E7%A1%80/Linux-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Linux基础" scheme="https://www.demon-w.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
